/*!
 jodit - Jodit is awesome and usefully wysiwyg editor with filebrowser
 Author: Chupurnov <chupurnov@gmail.com> (https://xdsoft.net/)
 Version: v3.3.17
 Url: https://xdsoft.net/jodit/
 License(s): GPL-2.0-or-later OR MIT OR Commercial
*/

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 96);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports.default = ["Type something","About Jodit","Jodit Editor","Free Non-commercial Version","GNU General Public License, version 2 or later","Jodit User's Guide","contains detailed help for using","For information about the license, please go to our website:","Buy full version","Copyright Â© XDSoft.net - Chupurnov Valeriy. All rights reserved.","Anchor","Open in new tab","Open editor in fullsize","Clear Formatting","Fill color or set the text color","Redo","Undo","Bold","Italic","Insert Unordered List","Insert Ordered List","Align Center","Align Justify","Align Left","Align Right","Insert Horizontal Line","Insert Image","Insert file","Insert youtube/vimeo video","Insert link","Font size","Font family","Insert format block","Normal","Heading 1","Heading 2","Heading 3","Heading 4","Quote","Code","Insert","Insert table","Decrease Indent","Increase Indent","Select Special Character","Insert Special Character","Paint format","Change mode","Margins","top","right","bottom","left","Styles","Classes","Align","Right","Center","Left","--Not Set--","Src","Title","Alternative","Link","Open link in new tab","Image","file","Advanced","Image properties","Cancel","Ok","File Browser","Error on load list","Error on load folders","Are you sure?","Enter Directory name","Create directory","type name","Drop image","Drop file","or click","Alternative text","Upload","Browse","Background","Text","Top","Middle","Bottom","Insert column before","Insert column after","Insert row above","Insert row below","Delete table","Delete row","Delete column","Empty cell","Chars: %d","Words: %d","Strike through","Underline","superscript","subscript","Cut selection","Select all","Break","Search for","Replace with","Replace","Paste","Choose Content to Paste","source","bold","italic","brush","link","undo","redo","table","image","eraser","paragraph","fontsize","video","font","about","print","symbol","underline","strikethrough","indent","outdent","fullsize","shrink","copyformat","hr","ul","ol","cut","selectall","Embed code","Open link","Edit link","No follow","Unlink","Update","pencil","Eye"," URL","Edit","Horizontal align","Filter","Sort by changed","Sort by name","Sort by size","Add folder","Reset","Save","Save as ...","Resize","Crop","Width","Height","Keep Aspect Ratio","Yes","No","Remove","Select","Select %s","Vertical align","Split","Merge","Add column","Add row","License: %s","Delete","Split vertical","Split horizontal","Border","Your code is similar to HTML. Keep as HTML?","Paste as HTML","Keep","Insert as Text","Insert only Text","You can only edit your own images. Download this image on the host?","The image has been successfully uploaded to the host!","palette","There are no files","rename","Enter new name","preview","download","Paste from clipboard","Your browser doesn't support direct access to the clipboard.","Copy selection","copy","Border radius"]

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1088 1256v240q0 16-12 28t-28 12h-240q-16 0-28-12t-12-28v-240q0-16 12-28t28-12h240q16 0 28 12t12 28zm316-600q0 54-15.5 101t-35 76.5-55 59.5-57.5 43.5-61 35.5q-41 23-68.5 65t-27.5 67q0 17-12 32.5t-28 15.5h-240q-15 0-25.5-18.5t-10.5-37.5v-45q0-83 65-156.5t143-108.5q59-27 84-56t25-76q0-42-46.5-74t-107.5-32q-65 0-108 29-35 25-107 115-13 16-31 16-12 0-25-8l-164-125q-13-10-15.5-25t5.5-28q160-266 464-266 80 0 161 31t146 83 106 127.5 41 158.5z\"/> </svg> "

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 18.151 18.151\"> <g> <g> <path d=\"M6.237,16.546H3.649V1.604h5.916v5.728c0.474-0.122,0.968-0.194,1.479-0.194 c0.042,0,0.083,0.006,0.125,0.006V0H2.044v18.15h5.934C7.295,17.736,6.704,17.19,6.237,16.546z\"/> <path d=\"M11.169,8.275c-2.723,0-4.938,2.215-4.938,4.938s2.215,4.938,4.938,4.938s4.938-2.215,4.938-4.938 S13.892,8.275,11.169,8.275z M11.169,16.81c-1.983,0-3.598-1.612-3.598-3.598c0-1.983,1.614-3.597,3.598-3.597 s3.597,1.613,3.597,3.597C14.766,15.198,13.153,16.81,11.169,16.81z\"/> <polygon points=\"11.792,11.073 10.502,11.073 10.502,12.578 9.03,12.578 9.03,13.868 10.502,13.868 10.502,15.352 11.792,15.352 11.792,13.868 13.309,13.868 13.309,12.578 11.792,12.578 \"/> </g> </g> </svg> "

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 432 432\"> <g> <g> <polygon points=\"203.688,96 0,96 0,144 155.688,144 \"/> <polygon points=\"155.719,288 0,288 0,336 203.719,336 \"/> <rect x=\"252\" y=\"96\"/> <rect/> <rect x=\"252\" y=\"288\"/> <rect y=\"384\"/> <path d=\"M97.844,230.125c-3.701-3.703-5.856-8.906-5.856-14.141s2.154-10.438,5.856-14.141l9.844-9.844H0v48h107.719 L97.844,230.125z\"/> <polygon points=\"232,176 232,96 112,216 232,336 232,256 432,256 432,176 \"/> </g> </g> </svg> "

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1395 736q0 13-10 23l-466 466q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l393 393 393-393q10-10 23-10t23 10l50 50q10 10 10 23z\"/> </svg>"

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50 50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23 10l50 50q10 10 10 23z\"/></svg>"

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1171 960q0 13-10 23l-466 466q-10 10-23 10t-23-10l-50-50q-10-10-10-23t10-23l393-393-393-393q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l466 466q10 10 10 23z\"/></svg>"

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1395 1184q0 13-10 23l-50 50q-10 10-23 10t-23-10l-393-393-393 393q-10 10-23 10t-23-10l-50-50q-10-10-10-23t10-23l466-466q10-10 23-10t23 10l466 466q10 10 10 23z\"/></svg>"

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17 39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355 355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59 39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12 0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144 144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19 45v448q0 42-39 59-13 5-25 5-26 0-45-19z\"/></svg>"

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1792 896q0 26-19 45l-256 256q-19 19-45 19t-45-19-19-45v-128h-1024v128q0 26-19 45t-45 19-45-19l-256-256q-19-19-19-45t19-45l256-256q19-19 45-19t45 19 19 45v128h1024v-128q0-26 19-45t45-19 45 19l256 256q19 19 19 45z\"/></svg>"

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1596 1385q0 117-79 196t-196 79q-135 0-235-100l-777-776q-113-115-113-271 0-159 110-270t269-111q158 0 273 113l605 606q10 10 10 22 0 16-30.5 46.5t-46.5 30.5q-13 0-23-10l-606-607q-79-77-181-77-106 0-179 75t-73 181q0 105 76 181l776 777q63 63 145 63 64 0 106-42t42-106q0-82-63-145l-581-581q-26-24-60-24-29 0-48 19t-19 48q0 32 25 59l410 410q10 10 10 22 0 16-31 47t-47 31q-12 0-22-10l-410-410q-63-61-63-149 0-82 57-139t139-57q88 0 149 63l581 581q100 98 100 235z\"/></svg>"

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M704 1376v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zm256 0v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zm256 0v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zm-544-992h448l-48-117q-7-9-17-11h-317q-10 2-17 11zm928 32v64q0 14-9 23t-23 9h-96v948q0 83-47 143.5t-113 60.5h-832q-66 0-113-58.5t-47-141.5v-952h-96q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h309l70-167q15-37 54-63t79-26h320q40 0 79 26t54 63l70 167h309q14 0 23 9t9 23z\"/></svg>"

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M747 1521q74 32 140 32 376 0 376-335 0-114-41-180-27-44-61.5-74t-67.5-46.5-80.5-25-84-10.5-94.5-2q-73 0-101 10 0 53-.5 159t-.5 158q0 8-1 67.5t-.5 96.5 4.5 83.5 12 66.5zm-14-746q42 7 109 7 82 0 143-13t110-44.5 74.5-89.5 25.5-142q0-70-29-122.5t-79-82-108-43.5-124-14q-50 0-130 13 0 50 4 151t4 152q0 27-.5 80t-.5 79q0 46 1 69zm-541 889l2-94q15-4 85-16t106-27q7-12 12.5-27t8.5-33.5 5.5-32.5 3-37.5.5-34v-65.5q0-982-22-1025-4-8-22-14.5t-44.5-11-49.5-7-48.5-4.5-30.5-3l-4-83q98-2 340-11.5t373-9.5q23 0 68.5.5t67.5.5q70 0 136.5 13t128.5 42 108 71 74 104.5 28 137.5q0 52-16.5 95.5t-39 72-64.5 57.5-73 45-84 40q154 35 256.5 134t102.5 248q0 100-35 179.5t-93.5 130.5-138 85.5-163.5 48.5-176 14q-44 0-132-3t-132-3q-106 0-307 11t-231 12z\"/></svg>"

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M896 1152q0-36-20-69-1-1-15.5-22.5t-25.5-38-25-44-21-50.5q-4-16-21-16t-21 16q-7 23-21 50.5t-25 44-25.5 38-15.5 22.5q-20 33-20 69 0 53 37.5 90.5t90.5 37.5 90.5-37.5 37.5-90.5zm512-128q0 212-150 362t-362 150-362-150-150-362q0-145 81-275 6-9 62.5-90.5t101-151 99.5-178 83-201.5q9-30 34-47t51-17 51.5 17 33.5 47q28 93 83 201.5t99.5 178 101 151 62.5 90.5q81 127 81 275z\"/></svg>"

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 16 16\"> <g transform=\"translate(0,-1036.3622)\"> <path d=\"m 2,1050.3622 12,-12\" style=\"fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none\"/> <path d=\"m 2,1038.3622 12,12\" style=\"fill:none;stroke-width:2;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none\"/> </g> </svg> "

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1792 1344v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45zm-384-384v128q0 26-19 45t-45 19h-896q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h896q26 0 45 19t19 45zm256-384v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zm-384-384v128q0 26-19 45t-45 19h-640q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h640q26 0 45 19t19 45z\"/></svg>"

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M503 1271l-256 256q-10 9-23 9-12 0-23-9-9-10-9-23t9-23l256-256q10-9 23-9t23 9q9 10 9 23t-9 23zm169 41v320q0 14-9 23t-23 9-23-9-9-23v-320q0-14 9-23t23-9 23 9 9 23zm-224-224q0 14-9 23t-23 9h-320q-14 0-23-9t-9-23 9-23 23-9h320q14 0 23 9t9 23zm1264 128q0 120-85 203l-147 146q-83 83-203 83-121 0-204-85l-334-335q-21-21-42-56l239-18 273 274q27 27 68 27.5t68-26.5l147-146q28-28 28-67 0-40-28-68l-274-275 18-239q35 21 56 42l336 336q84 86 84 204zm-617-724l-239 18-273-274q-28-28-68-28-39 0-68 27l-147 146q-28 28-28 67 0 40 28 68l274 274-18 240q-35-21-56-42l-336-336q-84-86-84-204 0-120 85-203l147-146q83-83 203-83 121 0 204 85l334 335q21 21 42 56zm633 84q0 14-9 23t-23 9h-320q-14 0-23-9t-9-23 9-23 23-9h320q14 0 23 9t9 23zm-544-544v320q0 14-9 23t-23 9-23-9-9-23v-320q0-14 9-23t23-9 23 9 9 23zm407 151l-256 256q-11 9-23 9t-23-9q-9-10-9-23t9-23l256-256q10-9 23-9t23 9q9 10 9 23t-9 23z\"/></svg>"

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1472 930v318q0 119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119 84.5-203.5t203.5-84.5h832q63 0 117 25 15 7 18 23 3 17-9 29l-49 49q-10 10-23 10-3 0-9-2-23-6-45-6h-832q-66 0-113 47t-47 113v832q0 66 47 113t113 47h832q66 0 113-47t47-113v-254q0-13 9-22l64-64q10-10 23-10 6 0 12 3 20 8 20 29zm231-489l-814 814q-24 24-57 24t-57-24l-430-430q-24-24-24-57t24-57l110-110q24-24 57-24t57 24l263 263 647-647q24-24 57-24t57 24l110 110q24 24 24 57t-24 57z\"/></svg>"

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M813 1299l614-614q19-19 19-45t-19-45l-102-102q-19-19-45-19t-45 19l-467 467-211-211q-19-19-45-19t-45 19l-102 102q-19 19-19 45t19 45l358 358q19 19 45 19t45-19zm851-883v960q0 119-84.5 203.5t-203.5 84.5h-960q-119 0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5 84.5t84.5 203.5z\"/></svg>"

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 16 16\"><path d=\"M16 9v-6h-3v-1c0-0.55-0.45-1-1-1h-11c-0.55 0-1 0.45-1 1v3c0 0.55 0.45 1 1 1h11c0.55 0 1-0.45 1-1v-1h2v4h-9v2h-0.5c-0.276 0-0.5 0.224-0.5 0.5v5c0 0.276 0.224 0.5 0.5 0.5h2c0.276 0 0.5-0.224 0.5-0.5v-5c0-0.276-0.224-0.5-0.5-0.5h-0.5v-1h9zM12 3h-11v-1h11v1z\"/></svg> "

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M621 1280h595v-595zm-45-45l595-595h-595v595zm1152 77v192q0 14-9 23t-23 9h-224v224q0 14-9 23t-23 9h-192q-14 0-23-9t-9-23v-224h-864q-14 0-23-9t-9-23v-864h-224q-14 0-23-9t-9-23v-192q0-14 9-23t23-9h224v-224q0-14 9-23t23-9h192q14 0 23 9t9 23v224h851l246-247q10-9 23-9t23 9q9 10 9 23t-9 23l-247 246v851h224q14 0 23 9t9 23z\"/> </svg>"

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 32 32\" xmlns=\"http://www.w3.org/2000/svg\"> <path d=\"M24.89,6.61H22.31V4.47A2.47,2.47,0,0,0,19.84,2H6.78A2.47,2.47,0,0,0,4.31,4.47V22.92a2.47,2.47,0,0,0,2.47,2.47H9.69V27.2a2.8,2.8,0,0,0,2.8,2.8h12.4a2.8,2.8,0,0,0,2.8-2.8V9.41A2.8,2.8,0,0,0,24.89,6.61ZM6.78,23.52a.61.61,0,0,1-.61-.6V4.47a.61.61,0,0,1,.61-.6H19.84a.61.61,0,0,1,.61.6V6.61h-8a2.8,2.8,0,0,0-2.8,2.8V23.52Zm19,3.68a.94.94,0,0,1-.94.93H12.49a.94.94,0,0,1-.94-.93V9.41a.94.94,0,0,1,.94-.93h12.4a.94.94,0,0,1,.94.93Z\"/> <path d=\"M23.49,13.53h-9.6a.94.94,0,1,0,0,1.87h9.6a.94.94,0,1,0,0-1.87Z\"/> <path d=\"M23.49,17.37h-9.6a.94.94,0,1,0,0,1.87h9.6a.94.94,0,1,0,0-1.87Z\"/> <path d=\"M23.49,21.22h-9.6a.93.93,0,1,0,0,1.86h9.6a.93.93,0,1,0,0-1.86Z\"/> </svg> "

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M960 896q26 0 45 19t19 45-19 45-45 19-45-19-19-45 19-45 45-19zm300 64l507 398q28 20 25 56-5 35-35 51l-128 64q-13 7-29 7-17 0-31-8l-690-387-110 66q-8 4-12 5 14 49 10 97-7 77-56 147.5t-132 123.5q-132 84-277 84-136 0-222-78-90-84-79-207 7-76 56-147t131-124q132-84 278-84 83 0 151 31 9-13 22-22l122-73-122-73q-13-9-22-22-68 31-151 31-146 0-278-84-82-53-131-124t-56-147q-5-59 15.5-113t63.5-93q85-79 222-79 145 0 277 84 83 52 132 123t56 148q4 48-10 97 4 1 12 5l110 66 690-387q14-8 31-8 16 0 29 7l128 64q30 16 35 51 3 36-25 56zm-681-260q46-42 21-108t-106-117q-92-59-192-59-74 0-113 36-46 42-21 108t106 117q92 59 192 59 74 0 113-36zm-85 745q81-51 106-117t-21-108q-39-36-113-36-100 0-192 59-81 51-106 117t21 108q39 36 113 36 100 0 192-59zm178-613l96 58v-11q0-36 33-56l14-8-79-47-26 26q-3 3-10 11t-12 12q-2 2-4 3.5t-3 2.5zm224 224l96 32 736-576-128-64-768 431v113l-160 96 9 8q2 2 7 6 4 4 11 12t11 12l26 26zm704 416l128-64-520-408-177 138q-2 3-13 7z\"/> </svg>"

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M384 544v576q0 13-9.5 22.5t-22.5 9.5q-14 0-23-9l-288-288q-9-9-9-23t9-23l288-288q9-9 23-9 13 0 22.5 9.5t9.5 22.5zm1408 768v192q0 13-9.5 22.5t-22.5 9.5h-1728q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1728q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1088q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1088q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1088q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1088q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1728q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1728q13 0 22.5 9.5t9.5 22.5z\"/></svg>"

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = "<svg enable-background=\"new 0 0 24 24\" viewBox=\"0 0 24 24\" xml:space=\"preserve\" > <circle cx=\"12\" cy=\"12\" r=\"2.2\"/> <circle cx=\"12\" cy=\"5\" r=\"2.2\"/> <circle cx=\"12\" cy=\"19\" r=\"2.2\"/> </svg> "

/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 10 10\"> <path d=\"M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z\"/> </svg> "

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 128 128\" xml:space=\"preserve\"> <g> <polygon points=\"112.4560547,23.3203125 112.4560547,75.8154297 31.4853516,75.8154297 31.4853516,61.953125 16.0131836,72.6357422 0.5410156,83.3164063 16.0131836,93.9990234 31.4853516,104.6796875 31.4853516,90.8183594 112.4560547,90.8183594 112.4560547,90.8339844 127.4589844,90.8339844 127.4589844,23.3203125 \"/> </g> </svg>"

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M832 1408l336-384h-768l-336 384h768zm1013-1077q15 34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38 0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38 0 69.5 20.5t47.5 54.5z\"/></svg>"

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z\"/></svg>"

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1152 512v-472q22 14 36 28l408 408q14 14 28 36h-472zm-128 32q0 40 28 68t68 28h544v1056q0 40-28 68t-68 28h-1344q-40 0-68-28t-28-68v-1600q0-40 28-68t68-28h800v544z\"/> </svg>"

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1728 608v704q0 92-66 158t-158 66h-1216q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h672q92 0 158 66t66 158z\"/> </svg> "

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0 57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29 31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15 34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 4-.5 13t-.5 13q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0 12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11 2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0 22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58 0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\"/></svg>"

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1744 1408q33 0 42 18.5t-11 44.5l-126 162q-20 26-49 26t-49-26l-126-162q-20-26-11-44.5t42-18.5h80v-1024h-80q-33 0-42-18.5t11-44.5l126-162q20-26 49-26t49 26l126 162q20 26 11 44.5t-42 18.5h-80v1024h80zm-1663-1279l54 27q12 5 211 5 44 0 132-2t132-2q36 0 107.5.5t107.5.5h293q6 0 21 .5t20.5 0 16-3 17.5-9 15-17.5l42-1q4 0 14 .5t14 .5q2 112 2 336 0 80-5 109-39 14-68 18-25-44-54-128-3-9-11-48t-14.5-73.5-7.5-35.5q-6-8-12-12.5t-15.5-6-13-2.5-18-.5-16.5.5q-17 0-66.5-.5t-74.5-.5-64 2-71 6q-9 81-8 136 0 94 2 388t2 455q0 16-2.5 71.5t0 91.5 12.5 69q40 21 124 42.5t120 37.5q5 40 5 50 0 14-3 29l-34 1q-76 2-218-8t-207-10q-50 0-151 9t-152 9q-3-51-3-52v-9q17-27 61.5-43t98.5-29 78-27q19-42 19-383 0-101-3-303t-3-303v-117q0-2 .5-15.5t.5-25-1-25.5-3-24-5-14q-11-12-162-12-33 0-93 12t-80 26q-19 13-34 72.5t-31.5 111-42.5 53.5q-42-26-56-44v-383z\"/></svg>"

/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 24 24\" > <path d=\"M22,20.6L3.4,2H8V0H0v8h2V3.4L20.6,22H16v2h8v-8h-2V20.6z M16,0v2h4.7l-6.3,6.3l1.4,1.4L22,3.5V8h2V0H16z M8.3,14.3L2,20.6V16H0v8h8v-2H3.5l6.3-6.3L8.3,14.3z\"/> </svg>"

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1600 736v192q0 40-28 68t-68 28h-1216q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h1216q40 0 68 28t28 68z\"/></svg>"

/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M576 576q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm1024 384v448h-1408v-192l320-320 160 160 512-512zm96-704h-1600q-13 0-22.5 9.5t-9.5 22.5v1216q0 13 9.5 22.5t22.5 9.5h1600q13 0 22.5-9.5t9.5-22.5v-1216q0-13-9.5-22.5t-22.5-9.5zm160 32v1216q0 66-47 113t-113 47h-1600q-66 0-113-47t-47-113v-1216q0-66 47-113t113-47h1600q66 0 113 47t47 113z\"/></svg>"

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M352 832q0 14-9 23l-288 288q-9 9-23 9-13 0-22.5-9.5t-9.5-22.5v-576q0-13 9.5-22.5t22.5-9.5q14 0 23 9l288 288q9 9 9 23zm1440 480v192q0 13-9.5 22.5t-22.5 9.5h-1728q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1728q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1088q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1088q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1088q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1088q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1728q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1728q13 0 22.5 9.5t9.5 22.5z\"/> </svg>"

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1152 1376v-160q0-14-9-23t-23-9h-96v-512q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v160q0 14 9 23t23 9h96v320h-96q-14 0-23 9t-9 23v160q0 14 9 23t23 9h448q14 0 23-9t9-23zm-128-896v-160q0-14-9-23t-23-9h-192q-14 0-23 9t-9 23v160q0 14 9 23t23 9h192q14 0 23-9t9-23zm640 416q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z\"/></svg>"

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M384 1662l17-85q6-2 81.5-21.5t111.5-37.5q28-35 41-101 1-7 62-289t114-543.5 52-296.5v-25q-24-13-54.5-18.5t-69.5-8-58-5.5l19-103q33 2 120 6.5t149.5 7 120.5 2.5q48 0 98.5-2.5t121-7 98.5-6.5q-5 39-19 89-30 10-101.5 28.5t-108.5 33.5q-8 19-14 42.5t-9 40-7.5 45.5-6.5 42q-27 148-87.5 419.5t-77.5 355.5q-2 9-13 58t-20 90-16 83.5-6 57.5l1 18q17 4 185 31-3 44-16 99-11 0-32.5 1.5t-32.5 1.5q-29 0-87-10t-86-10q-138-2-206-2-51 0-143 9t-121 11z\"/></svg>"

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1792 1344v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45zm0-384v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45zm0-384v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45zm0-384v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45z\"/></svg>"

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1792 1344v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45zm-384-384v128q0 26-19 45t-45 19h-1280q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1280q26 0 45 19t19 45zm256-384v128q0 26-19 45t-45 19h-1536q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1536q26 0 45 19t19 45zm-384-384v128q0 26-19 45t-45 19h-1152q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1152q26 0 45 19t19 45z\"/></svg>"

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1520 1216q0-40-28-68l-208-208q-28-28-68-28-42 0-72 32 3 3 19 18.5t21.5 21.5 15 19 13 25.5 3.5 27.5q0 40-28 68t-68 28q-15 0-27.5-3.5t-25.5-13-19-15-21.5-21.5-18.5-19q-33 31-33 73 0 40 28 68l206 207q27 27 68 27 40 0 68-26l147-146q28-28 28-67zm-703-705q0-40-28-68l-206-207q-28-28-68-28-39 0-68 27l-147 146q-28 28-28 67 0 40 28 68l208 208q27 27 68 27 42 0 72-31-3-3-19-18.5t-21.5-21.5-15-19-13-25.5-3.5-27.5q0-40 28-68t68-28q15 0 27.5 3.5t25.5 13 19 15 21.5 21.5 18.5 19q33-31 33-73zm895 705q0 120-85 203l-147 146q-83 83-203 83-121 0-204-85l-206-207q-83-83-83-203 0-123 88-209l-88-88q-86 88-208 88-120 0-204-84l-208-208q-84-84-84-204t85-203l147-146q83-83 203-83 121 0 204 85l206 207q83 83 83 203 0 123-88 209l88 88q86-88 208-88 120 0 204 84l208 208q84 84 84 204z\"/></svg>"

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z\"/></svg>"

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1664 1344v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zm0-512v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45zm0-512v128q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1408q26 0 45 19t19 45z\"/></svg>"

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 312 312\"> <g transform=\"translate(0.000000,312.000000) scale(0.100000,-0.100000)\" stroke=\"none\"> <path d=\"M50 3109 c0 -7 -11 -22 -25 -35 l-25 -23 0 -961 0 -961 32 -29 32 -30 501 -2 500 -3 3 -502 2 -502 31 -30 31 -31 958 0 958 0 23 25 c13 13 30 25 37 25 9 0 12 199 12 960 0 686 -3 960 -11 960 -6 0 -24 12 -40 28 l-29 27 -503 5 -502 5 -5 502 -5 503 -28 29 c-15 16 -27 34 -27 40 0 8 -274 11 -960 11 -710 0 -960 -3 -960 -11z m1738 -698 l2 -453 -40 -40 c-22 -22 -40 -43 -40 -47 0 -4 36 -42 79 -85 88 -87 82 -87 141 -23 l26 27 455 -2 454 -3 0 -775 0 -775 -775 0 -775 0 -3 450 -2 449 47 48 47 48 -82 80 c-44 44 -84 80 -87 80 -3 0 -25 -18 -48 -40 l-41 -40 -456 2 -455 3 -3 765 c-1 421 0 771 3 778 3 10 164 12 777 10 l773 -3 3 -454z\"/> <path d=\"M607 2492 c-42 -42 -77 -82 -77 -87 0 -6 86 -96 190 -200 105 -104 190 -197 190 -205 0 -8 -41 -56 -92 -107 -65 -65 -87 -94 -77 -98 8 -3 138 -4 289 -3 l275 3 3 275 c1 151 0 281 -3 289 -4 10 -35 -14 -103 -82 -54 -53 -103 -97 -109 -97 -7 0 -99 88 -206 195 -107 107 -196 195 -198 195 -3 0 -39 -35 -82 -78z\"/> <path d=\"M1470 1639 c-47 -49 -87 -91 -89 -94 -5 -6 149 -165 160 -165 9 0 189 179 189 188 0 12 -154 162 -165 161 -6 0 -48 -41 -95 -90z\"/> <path d=\"M1797 1303 c-9 -8 -9 -568 0 -576 4 -4 50 36 103 88 54 52 101 95 106 95 5 0 95 -85 199 -190 104 -104 194 -190 200 -190 6 0 46 36 90 80 l79 79 -197 196 c-108 108 -197 199 -197 203 0 4 45 52 99 106 55 55 98 103 95 108 -6 10 -568 11 -577 1z\"/> </g> </svg> "

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = "<svg role=\"img\" viewBox=\"0 0 1792 1792\"> <path d=\"M381 1620q0 80-54.5 126t-135.5 46q-106 0-172-66l57-88q49 45 106 45 29 0 50.5-14.5t21.5-42.5q0-64-105-56l-26-56q8-10 32.5-43.5t42.5-54 37-38.5v-1q-16 0-48.5 1t-48.5 1v53h-106v-152h333v88l-95 115q51 12 81 49t30 88zm2-627v159h-362q-6-36-6-54 0-51 23.5-93t56.5-68 66-47.5 56.5-43.5 23.5-45q0-25-14.5-38.5t-39.5-13.5q-46 0-81 58l-85-59q24-51 71.5-79.5t105.5-28.5q73 0 123 41.5t50 112.5q0 50-34 91.5t-75 64.5-75.5 50.5-35.5 52.5h127v-60h105zm1409 319v192q0 13-9.5 22.5t-22.5 9.5h-1216q-13 0-22.5-9.5t-9.5-22.5v-192q0-14 9-23t23-9h1216q13 0 22.5 9.5t9.5 22.5zm-1408-899v99h-335v-99h107q0-41 .5-122t.5-121v-12h-2q-8 17-50 54l-71-76 136-127h106v404h108zm1408 387v192q0 13-9.5 22.5t-22.5 9.5h-1216q-13 0-22.5-9.5t-9.5-22.5v-192q0-14 9-23t23-9h1216q13 0 22.5 9.5t9.5 22.5zm0-512v192q0 13-9.5 22.5t-22.5 9.5h-1216q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1216q13 0 22.5 9.5t9.5 22.5z\"/> </svg>"

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 270 270\"> <path d=\"m240.443652,220.45085l-47.410809,0l0,-10.342138c13.89973,-8.43655 25.752896,-19.844464 34.686646,-33.469923c11.445525,-17.455846 17.496072,-37.709239 17.496072,-58.570077c0,-59.589197 -49.208516,-108.068714 -109.693558,-108.068714s-109.69263,48.479517 -109.69263,108.069628c0,20.860839 6.050547,41.113316 17.497001,58.570077c8.93375,13.625459 20.787845,25.032458 34.686646,33.469008l0,10.342138l-47.412666,0c-10.256959,0 -18.571354,8.191376 -18.571354,18.296574c0,10.105198 8.314395,18.296574 18.571354,18.296574l65.98402,0c10.256959,0 18.571354,-8.191376 18.571354,-18.296574l0,-39.496814c0,-7.073455 -4.137698,-13.51202 -10.626529,-16.537358c-25.24497,-11.772016 -41.557118,-37.145704 -41.557118,-64.643625c0,-39.411735 32.545369,-71.476481 72.549922,-71.476481c40.004553,0 72.550851,32.064746 72.550851,71.476481c0,27.497006 -16.312149,52.87161 -41.557118,64.643625c-6.487902,3.026253 -10.6256,9.464818 -10.6256,16.537358l0,39.496814c0,10.105198 8.314395,18.296574 18.571354,18.296574l65.982163,0c10.256959,0 18.571354,-8.191376 18.571354,-18.296574c0,-10.105198 -8.314395,-18.296574 -18.571354,-18.296574z\"/> </svg>"

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M384 544v576q0 13-9.5 22.5t-22.5 9.5q-14 0-23-9l-288-288q-9-9-9-23t9-23l288-288q9-9 23-9 13 0 22.5 9.5t9.5 22.5zm1408 768v192q0 13-9.5 22.5t-22.5 9.5h-1728q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1728q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1088q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1088q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1088q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1088q13 0 22.5 9.5t9.5 22.5zm0-384v192q0 13-9.5 22.5t-22.5 9.5h-1728q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1728q13 0 22.5 9.5t9.5 22.5z\"/> </svg>"

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = "<svg x=\"0px\" y=\"0px\" viewBox=\"0 0 459 459\"> <g> <g> <path d=\"M229.5,0C102,0,0,102,0,229.5S102,459,229.5,459c20.4,0,38.25-17.85,38.25-38.25c0-10.2-2.55-17.85-10.2-25.5 c-5.1-7.65-10.2-15.3-10.2-25.5c0-20.4,17.851-38.25,38.25-38.25h45.9c71.4,0,127.5-56.1,127.5-127.5C459,91.8,357,0,229.5,0z M89.25,229.5c-20.4,0-38.25-17.85-38.25-38.25S68.85,153,89.25,153s38.25,17.85,38.25,38.25S109.65,229.5,89.25,229.5z M165.75,127.5c-20.4,0-38.25-17.85-38.25-38.25S145.35,51,165.75,51S204,68.85,204,89.25S186.15,127.5,165.75,127.5z M293.25,127.5c-20.4,0-38.25-17.85-38.25-38.25S272.85,51,293.25,51s38.25,17.85,38.25,38.25S313.65,127.5,293.25,127.5z M369.75,229.5c-20.4,0-38.25-17.85-38.25-38.25S349.35,153,369.75,153S408,170.85,408,191.25S390.15,229.5,369.75,229.5z\" /> </g> </g> </svg> "

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1534 189v73q0 29-18.5 61t-42.5 32q-50 0-54 1-26 6-32 31-3 11-3 64v1152q0 25-18 43t-43 18h-108q-25 0-43-18t-18-43v-1218h-143v1218q0 25-17.5 43t-43.5 18h-108q-26 0-43.5-18t-17.5-43v-496q-147-12-245-59-126-58-192-179-64-117-64-259 0-166 88-286 88-118 209-159 111-37 417-37h479q25 0 43 18t18 43z\"/></svg>"

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"> <path d=\"M10.5 20H2a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h1V3l2.03-.4a3 3 0 0 1 5.94 0L13 3v1h1a2 2 0 0 1 2 2v1h-2V6h-1v1H3V6H2v12h5v2h3.5zM8 4a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm2 4h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2zm0 2v8h8v-8h-8z\"/> </svg> "

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z\"/></svg>"

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1600 736v192q0 40-28 68t-68 28h-416v416q0 40-28 68t-68 28h-192q-40 0-68-28t-28-68v-416h-416q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h416v-416q0-40 28-68t68-28h192q40 0 68 28t28 68v416h416q40 0 68 28t28 68z\"/></svg>"

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M448 1536h896v-256h-896v256zm0-640h896v-384h-160q-40 0-68-28t-28-68v-160h-640v640zm1152 64q0-26-19-45t-45-19-45 19-19 45 19 45 45 19 45-19 19-45zm128 0v416q0 13-9.5 22.5t-22.5 9.5h-224v160q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-160h-224q-13 0-22.5-9.5t-9.5-22.5v-416q0-79 56.5-135.5t135.5-56.5h64v-544q0-40 28-68t68-28h672q40 0 88 20t76 48l152 152q28 28 48 76t20 88v256h64q79 0 135.5 56.5t56.5 135.5z\"/> </svg>"

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5 163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0 225-52t179-147q7-10 23-12 14 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109 132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298 164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14 39 17 39 59z\"/> </svg>"

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 24 24\" > <g> <g transform=\"translate(-251.000000, -443.000000)\"> <g transform=\"translate(215.000000, 119.000000)\"/> <path d=\"M252,448 L256,448 L256,444 L252,444 L252,448 Z M257,448 L269,448 L269,446 L257,446 L257,448 Z M257,464 L269,464 L269,462 L257,462 L257,464 Z M270,444 L270,448 L274,448 L274,444 L270,444 Z M252,462 L252,466 L256,466 L256,462 L252,462 Z M270,462 L270,466 L274,466 L274,462 L270,462 Z M254,461 L256,461 L256,449 L254,449 L254,461 Z M270,461 L272,461 L272,449 L270,449 L270,461 Z\"/> </g> </g> </svg>"

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M844 472q0 60-19 113.5t-63 92.5-105 39q-76 0-138-57.5t-92-135.5-30-151q0-60 19-113.5t63-92.5 105-39q77 0 138.5 57.5t91.5 135 30 151.5zm-342 483q0 80-42 139t-119 59q-76 0-141.5-55.5t-100.5-133.5-35-152q0-80 42-139.5t119-59.5q76 0 141.5 55.5t100.5 134 35 152.5zm394-27q118 0 255 97.5t229 237 92 254.5q0 46-17 76.5t-48.5 45-64.5 20-76 5.5q-68 0-187.5-45t-182.5-45q-66 0-192.5 44.5t-200.5 44.5q-183 0-183-146 0-86 56-191.5t139.5-192.5 187.5-146 193-59zm239-211q-61 0-105-39t-63-92.5-19-113.5q0-74 30-151.5t91.5-135 138.5-57.5q61 0 105 39t63 92.5 19 113.5q0 73-30 151t-92 135.5-138 57.5zm432-104q77 0 119 59.5t42 139.5q0 74-35 152t-100.5 133.5-141.5 55.5q-77 0-119-59t-42-139q0-74 35-152.5t100.5-134 141.5-55.5z\"/> </svg>"

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1792 1344v128q0 26-19 45t-45 19h-1664q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1664q26 0 45 19t19 45zm0-384v128q0 26-19 45t-45 19h-1280q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1280q26 0 45 19t19 45zm0-384v128q0 26-19 45t-45 19h-1536q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1536q26 0 45 19t19 45zm0-384v128q0 26-19 45t-45 19h-1152q-26 0-45-19t-19-45v-128q0-26 19-45t45-19h1152q26 0 45 19t19 45z\"/> </svg>"

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M512 1536h768v-384h-768v384zm896 0h128v-896q0-14-10-38.5t-20-34.5l-281-281q-10-10-34-20t-39-10v416q0 40-28 68t-68 28h-576q-40 0-68-28t-28-68v-416h-128v1280h128v-416q0-40 28-68t68-28h832q40 0 68 28t28 68v416zm-384-928v-320q0-13-9.5-22.5t-22.5-9.5h-192q-13 0-22.5 9.5t-9.5 22.5v320q0 13 9.5 22.5t22.5 9.5h192q13 0 22.5-9.5t9.5-22.5zm640 32v928q0 40-28 68t-68 28h-1344q-40 0-68-28t-28-68v-1344q0-40 28-68t68-28h928q40 0 88 20t76 48l280 280q28 28 48 76t20 88z\"/> </svg>"

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 18 18\"> <g fill-rule=\"evenodd\" stroke=\"none\" stroke-width=\"1\"> <g transform=\"translate(-381.000000, -381.000000)\"> <g transform=\"translate(381.000000, 381.000000)\"> <path d=\"M0,2 L2,2 L2,0 C0.9,0 0,0.9 0,2 L0,2 Z M0,10 L2,10 L2,8 L0,8 L0,10 L0,10 Z M4,18 L6,18 L6,16 L4,16 L4,18 L4,18 Z M0,6 L2,6 L2,4 L0,4 L0,6 L0,6 Z M10,0 L8,0 L8,2 L10,2 L10,0 L10,0 Z M16,0 L16,2 L18,2 C18,0.9 17.1,0 16,0 L16,0 Z M2,18 L2,16 L0,16 C0,17.1 0.9,18 2,18 L2,18 Z M0,14 L2,14 L2,12 L0,12 L0,14 L0,14 Z M6,0 L4,0 L4,2 L6,2 L6,0 L6,0 Z M8,18 L10,18 L10,16 L8,16 L8,18 L8,18 Z M16,10 L18,10 L18,8 L16,8 L16,10 L16,10 Z M16,18 C17.1,18 18,17.1 18,16 L16,16 L16,18 L16,18 Z M16,6 L18,6 L18,4 L16,4 L16,6 L16,6 Z M16,14 L18,14 L18,12 L16,12 L16,14 L16,14 Z M12,18 L14,18 L14,16 L12,16 L12,18 L12,18 Z M12,2 L14,2 L14,0 L12,0 L12,2 L12,2 Z M4,14 L14,14 L14,4 L4,4 L4,14 L4,14 Z M6,6 L12,6 L12,12 L6,12 L6,6 L6,6 Z\"/> </g> </g> </g> </svg>"

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M896 960v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45zm755-672q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23z\"/> </svg>"

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M553 1399l-50 50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23 10l50 50q10 10 10 23t-10 23l-393 393 393 393q10 10 10 23t-10 23zm591-1067l-373 1291q-4 13-15.5 19.5t-23.5 2.5l-62-17q-13-4-19.5-15.5t-2.5-24.5l373-1291q4-13 15.5-19.5t23.5-2.5l62 17q13 4 19.5 15.5t2.5 24.5zm657 651l-466 466q-10 10-23 10t-23-10l-50-50q-10-10-10-23t10-23l393-393-393-393q-10-10-10-23t10-23l50-50q10-10 23-10t23 10l466 466q10 10 10 23t-10 23z\"/> </svg>"

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 48 48\"> <path d=\"M6 42h4v-4h-4v4zm4-28h-4v4h4v-4zm-4 20h4v-4h-4v4zm8 8h4v-4h-4v4zm-4-36h-4v4h4v-4zm8 0h-4v4h4v-4zm16 0h-4v4h4v-4zm-8 8h-4v4h4v-4zm0-8h-4v4h4v-4zm12 28h4v-4h-4v4zm-16 8h4v-4h-4v4zm-16-16h36v-4h-36v4zm32-20v4h4v-4h-4zm0 12h4v-4h-4v4zm-16 16h4v-4h-4v4zm8 8h4v-4h-4v4zm8 0h4v-4h-4v4z\"/><path d=\"M0 0h48v48h-48z\" fill=\"none\"/> </svg>"

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 48 48\"> <path d=\"M6 18h4v-4h-4v4zm0-8h4v-4h-4v4zm8 32h4v-4h-4v4zm0-16h4v-4h-4v4zm-8 0h4v-4h-4v4zm0 16h4v-4h-4v4zm0-8h4v-4h-4v4zm8-24h4v-4h-4v4zm24 24h4v-4h-4v4zm-16 8h4v-36h-4v36zm16 0h4v-4h-4v4zm0-16h4v-4h-4v4zm0-20v4h4v-4h-4zm0 12h4v-4h-4v4zm-8-8h4v-4h-4v4zm0 32h4v-4h-4v4zm0-16h4v-4h-4v4z\"/> <path d=\"M0 0h48v48h-48z\" fill=\"none\"/> </svg>"

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1760 896q14 0 23 9t9 23v64q0 14-9 23t-23 9h-1728q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h1728zm-1277-64q-28-35-51-80-48-97-48-188 0-181 134-309 133-127 393-127 50 0 167 19 66 12 177 48 10 38 21 118 14 123 14 183 0 18-5 45l-12 3-84-6-14-2q-50-149-103-205-88-91-210-91-114 0-182 59-67 58-67 146 0 73 66 140t279 129q69 20 173 66 58 28 95 52h-743zm507 256h411q7 39 7 92 0 111-41 212-23 55-71 104-37 35-109 81-80 48-153 66-80 21-203 21-114 0-195-23l-140-40q-57-16-72-28-8-8-8-22v-13q0-108-2-156-1-30 0-68l2-37v-44l102-2q15 34 30 71t22.5 56 12.5 27q35 57 80 94 43 36 105 57 59 22 132 22 64 0 139-27 77-26 122-86 47-61 47-129 0-84-81-157-34-29-137-71z\"/></svg>"

/***/ }),
/* 65 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1025 1369v167h-248l-159-252-24-42q-8-9-11-21h-3l-9 21q-10 20-25 44l-155 250h-258v-167h128l197-291-185-272h-137v-168h276l139 228q2 4 23 42 8 9 11 21h3q3-9 11-21l25-42 140-228h257v168h-125l-184 267 204 296h109zm639 217v206h-514l-4-27q-3-45-3-46 0-64 26-117t65-86.5 84-65 84-54.5 65-54 26-64q0-38-29.5-62.5t-70.5-24.5q-51 0-97 39-14 11-36 38l-105-92q26-37 63-66 80-65 188-65 110 0 178 59.5t68 158.5q0 66-34.5 118.5t-84 86-99.5 62.5-87 63-41 73h232v-80h126z\"/> </svg>"

/***/ }),
/* 66 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"> <path d=\"M1025 1369v167h-248l-159-252-24-42q-8-9-11-21h-3l-9 21q-10 20-25 44l-155 250h-258v-167h128l197-291-185-272h-137v-168h276l139 228q2 4 23 42 8 9 11 21h3q3-9 11-21l25-42 140-228h257v168h-125l-184 267 204 296h109zm637-679v206h-514l-3-27q-4-28-4-46 0-64 26-117t65-86.5 84-65 84-54.5 65-54 26-64q0-38-29.5-62.5t-70.5-24.5q-51 0-97 39-14 11-36 38l-105-92q26-37 63-66 83-65 188-65 110 0 178 59.5t68 158.5q0 56-24.5 103t-62 76.5-81.5 58.5-82 50.5-65.5 51.5-30.5 63h232v-80h126z\"/> </svg>"

/***/ }),
/* 67 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M576 1376v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm0-384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm-512-768v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm-512-768v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm512 384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm0-384v-192q0-14-9-23t-23-9h-320q-14 0-23 9t-9 23v192q0 14 9 23t23 9h320q14 0 23-9t9-23zm128-320v1088q0 66-47 113t-113 47h-1344q-66 0-113-47t-47-113v-1088q0-66 47-113t113-47h1344q66 0 113 47t47 113z\"/></svg>"

/***/ }),
/* 68 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M512 1248v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm0-512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm640 512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm-640-1024v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm640 512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm640 512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm-640-1024v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm640 512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm0-512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68z\"/></svg>"

/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M512 1248v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm0-512v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm1280 512v192q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h960q40 0 68 28t28 68zm-1280-1024v192q0 40-28 68t-68 28h-320q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h320q40 0 68 28t28 68zm1280 512v192q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h960q40 0 68 28t28 68zm0-512v192q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-192q0-40 28-68t68-28h960q40 0 68 28t28 68z\"/></svg>"

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M384 1408q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm0-512q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm1408 416v192q0 13-9.5 22.5t-22.5 9.5h-1216q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1216q13 0 22.5 9.5t9.5 22.5zm-1408-928q0 80-56 136t-136 56-136-56-56-136 56-136 136-56 136 56 56 136zm1408 416v192q0 13-9.5 22.5t-22.5 9.5h-1216q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1216q13 0 22.5 9.5t9.5 22.5zm0-512v192q0 13-9.5 22.5t-22.5 9.5h-1216q-13 0-22.5-9.5t-9.5-22.5v-192q0-13 9.5-22.5t22.5-9.5h1216q13 0 22.5 9.5t9.5 22.5z\"/></svg>"

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M176 223q-37-2-45-4l-3-88q13-1 40-1 60 0 112 4 132 7 166 7 86 0 168-3 116-4 146-5 56 0 86-2l-1 14 2 64v9q-60 9-124 9-60 0-79 25-13 14-13 132 0 13 .5 32.5t.5 25.5l1 229 14 280q6 124 51 202 35 59 96 92 88 47 177 47 104 0 191-28 56-18 99-51 48-36 65-64 36-56 53-114 21-73 21-229 0-79-3.5-128t-11-122.5-13.5-159.5l-4-59q-5-67-24-88-34-35-77-34l-100 2-14-3 2-86h84l205 10q76 3 196-10l18 2q6 38 6 51 0 7-4 31-45 12-84 13-73 11-79 17-15 15-15 41 0 7 1.5 27t1.5 31q8 19 22 396 6 195-15 304-15 76-41 122-38 65-112 123-75 57-182 89-109 33-255 33-167 0-284-46-119-47-179-122-61-76-83-195-16-80-16-237v-333q0-188-17-213-25-36-147-39zm1488 1409v-64q0-14-9-23t-23-9h-1472q-14 0-23 9t-9 23v64q0 14 9 23t23 9h1472q14 0 23-9t9-23z\"/></svg>"

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1664 896q0 156-61 298t-164 245-245 164-298 61q-172 0-327-72.5t-264-204.5q-7-10-6.5-22.5t8.5-20.5l137-138q10-9 25-9 16 2 23 12 73 95 179 147t225 52q104 0 198.5-40.5t163.5-109.5 109.5-163.5 40.5-198.5-40.5-198.5-109.5-163.5-163.5-109.5-198.5-40.5q-98 0-188 35.5t-160 101.5l137 138q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59 39-17 69 14l130 129q107-101 244.5-156.5t284.5-55.5q156 0 298 61t245 164 164 245 61 298z\"/></svg>"

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M503 1271l-256 256q-10 9-23 9-12 0-23-9-9-10-9-23t9-23l256-256q10-9 23-9t23 9q9 10 9 23t-9 23zm169 41v320q0 14-9 23t-23 9-23-9-9-23v-320q0-14 9-23t23-9 23 9 9 23zm-224-224q0 14-9 23t-23 9h-320q-14 0-23-9t-9-23 9-23 23-9h320q14 0 23 9t9 23zm1264 128q0 120-85 203l-147 146q-83 83-203 83-121 0-204-85l-334-335q-21-21-42-56l239-18 273 274q27 27 68 27.5t68-26.5l147-146q28-28 28-67 0-40-28-68l-274-275 18-239q35 21 56 42l336 336q84 86 84 204zm-617-724l-239 18-273-274q-28-28-68-28-39 0-68 27l-147 146q-28 28-28 67 0 40 28 68l274 274-18 240q-35-21-56-42l-336-336q-84-86-84-204 0-120 85-203l147-146q83-83 203-83 121 0 204 85l334 335q21 21 42 56zm633 84q0 14-9 23t-23 9h-320q-14 0-23-9t-9-23 9-23 23-9h320q14 0 23 9t9 23zm-544-544v320q0 14-9 23t-23 9-23-9-9-23v-320q0-14 9-23t23-9 23 9 9 23zm407 151l-256 256q-11 9-23 9t-23-9q-9-10-9-23t9-23l256-256q10-9 23-9t23 9q9 10 9 23t-9 23z\"/></svg>"

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1728 576v256q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45v-256q0-106-75-181t-181-75-181 75-75 181v192h96q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h672v-192q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5z\"/></svg>"

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1639 1056q0 5-1 7-64 268-268 434.5t-478 166.5q-146 0-282.5-55t-243.5-157l-129 129q-19 19-45 19t-45-19-19-45v-448q0-26 19-45t45-19h448q26 0 45 19t19 45-19 45l-137 137q71 66 161 102t187 36q134 0 250-65t186-179q11-17 53-117 8-23 30-23h192q13 0 22.5 9.5t9.5 22.5zm25-800v448q0 26-19 45t-45 19h-448q-26 0-45-19t-19-45 19-45l138-138q-148-137-349-137-134 0-250 65t-186 179q-11 17-53 117-8 23-30 23h-199q-13 0-22.5-9.5t-9.5-22.5v-7q65-268 270-434.5t480-166.5q146 0 284 55.5t245 156.5l130-129q19-19 45-19t45 19 19 45z\"/></svg>"

/***/ }),
/* 76 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1344 1472q0-26-19-45t-45-19-45 19-19 45 19 45 45 19 45-19 19-45zm256 0q0-26-19-45t-45-19-45 19-19 45 19 45 45 19 45-19 19-45zm128-224v320q0 40-28 68t-68 28h-1472q-40 0-68-28t-28-68v-320q0-40 28-68t68-28h427q21 56 70.5 92t110.5 36h256q61 0 110.5-36t70.5-92h427q40 0 68 28t28 68zm-325-648q-17 40-59 40h-256v448q0 26-19 45t-45 19h-256q-26 0-45-19t-19-45v-448h-256q-42 0-59-40-17-39 14-69l448-448q18-19 45-19t45 19l448 448q31 30 14 69z\"/></svg>"

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1216 320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19 19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26 0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\"/></svg>"

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 1792 1792\"><path d=\"M1792 352v1088q0 42-39 59-13 5-25 5-27 0-45-19l-403-403v166q0 119-84.5 203.5t-203.5 84.5h-704q-119 0-203.5-84.5t-84.5-203.5v-704q0-119 84.5-203.5t203.5-84.5h704q119 0 203.5 84.5t84.5 203.5v165l403-402q18-19 45-19 12 0 25 5 39 17 39 59z\"/></svg>"

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports.default = ["Ø¥Ø¨Ø¯Ø£ ÙÙ Ø§ÙÙØªØ§Ø¨Ø©...","Ø­ÙÙ Ø¬ÙØ¯ÙØª","ÙØ­Ø±Ø± Ø¬ÙØ¯ÙØª","Ø§ÙØ¥ØµØ¯Ø§Ø± Ø§ÙØºÙØ± ØªØ¬Ø§Ø±Ù ÙØ¬Ø§ÙÙ","Ø±Ø®ØµØ© Ø¬ÙÙ Ø§ÙØ¹ÙÙÙÙØ© Ø§ÙØ¹Ø§ÙØ© Ø Ø§ÙØ¥ØµØ¯Ø§Ø± Ø§ÙØ«Ø§ÙÙ Ø£Ù Ø§ÙØ£Ø­Ø¯Ø«","Ø¯ÙÙÙ ÙØ³ØªØ®Ø¯Ù Ø¬ÙØ¯ÙØª","ÙØ­ØªÙÙ Ø¹ÙÙ ÙØ³Ø§Ø¹Ø¯Ø© ÙÙØµÙØ© ÙÙØ§Ø³ØªØ®Ø¯Ø§Ù","ÙÙØ­ØµÙÙ Ø¹ÙÙ ÙØ¹ÙÙÙØ§Øª Ø­ÙÙ Ø§ÙØªØ±Ø®ÙØµØ ÙØ±Ø¬Ù Ø§ÙØ°ÙØ§Ø¨ ÙÙÙÙØ¹ÙØ§:","Ø´Ø±Ø§Ø¡ Ø§ÙÙØ³Ø®Ø© Ø§ÙÙØ§ÙÙØ©","Ø­ÙÙÙ Ø§ÙØ·Ø¨Ø¹ ÙØ§ÙÙØ´Ø± Â© XDSoft.net - Chupurnov Valeriy. ÙÙ Ø§ÙØ­ÙÙÙ ÙØ­ÙÙØ¸Ø©.","ÙÙØ±ÙØ³Ø§Ø©","ÙØªØ­ ÙÙ ÙØ§ÙØ°Ø© Ø¬Ø¯ÙØ¯Ø©","ÙØªØ­ Ø§ÙÙØ­Ø±Ø± ÙÙ Ø§ÙØ­Ø¬Ù Ø§ÙÙØ§ÙÙ","ÙØ³Ø­ Ø§ÙØªÙØ³ÙÙ","ÙÙØ¡ Ø§ÙÙÙÙ Ø£Ù ØªØ¹ÙÙÙ ÙÙÙ Ø§ÙÙØµ","Ø¥Ø¹Ø§Ø¯Ø©","ØªØ±Ø§Ø¬Ø¹","Ø¹Ø±ÙØ¶","ÙØ§Ø¦Ù","Ø¥Ø¯Ø±Ø§Ø¬ ÙØ§Ø¦ÙØ© ØºÙØ± ÙØ±ØªØ¨Ø©","Ø¥Ø¯Ø±Ø§Ø¬ ÙØ§Ø¦ÙØ© ÙØ±ØªØ¨Ø©","ÙØ­Ø§Ø°Ø§Ø© ÙÙÙØ³Ø·","ÙØ­Ø§Ø°Ø§Ø© ÙØ«Ø¨ØªØ©","ÙØ­Ø§Ø°Ø§Ø© ÙÙÙØ³Ø§Ø±","ÙØ­Ø§Ø°Ø§Ø© ÙÙÙÙÙÙ","Ø¥Ø¯Ø±Ø§Ø¬ Ø®Ø· Ø£ÙÙÙ","Ø¥Ø¯Ø±Ø§Ø¬ ØµÙØ±Ø©","Ø§Ø¯Ø®Ø§Ù Ø§ÙÙÙÙ","Ø¥Ø¯Ø±Ø§Ø¬ ÙÙØ¯ÙÙ ÙÙØªÙÙØ¨/ÙÙÙÙÙ ","Ø¥Ø¯Ø±Ø§Ø¬ Ø±Ø§Ø¨Ø·","Ø­Ø¬Ù Ø§ÙØ®Ø·","ÙÙØ¹ Ø§ÙØ®Ø·","Ø¥Ø¯Ø±Ø§Ø¬ ÙØªÙØ© ØªÙØ³ÙÙ","Ø¹Ø§Ø¯Ù","Ø¹ÙÙØ§Ù 1","Ø¹ÙÙØ§Ù 2","Ø¹ÙÙØ§Ù 3","Ø¹ÙÙØ§Ù 4","Ø¥ÙØªØ¨Ø§Ø³","ÙÙØ¯","Ø¥Ø¯Ø±Ø§Ø¬","Ø¥Ø¯Ø±Ø§Ø¬ Ø¬Ø¯ÙÙ","ØªÙÙÙÙ Ø§ÙÙØ³Ø§ÙØ© Ø§ÙØ¨Ø§Ø¯Ø¦Ø©","Ø²ÙØ§Ø¯Ø© Ø§ÙÙØ³Ø§ÙØ© Ø§ÙØ¨Ø§Ø¯Ø¦Ø©","ØªØ­Ø¯ÙØ¯ Ø£Ø­Ø±Ù Ø®Ø§ØµØ©","Ø¥Ø¯Ø±Ø§Ø¬ Ø­Ø±Ù Ø®Ø§Øµ","ØªÙØ³ÙÙ Ø§ÙØ±Ø³Ù","ØªØºÙÙØ± Ø§ÙÙØ¶Ø¹","ÙÙØ§ÙØ´","Ø£Ø¹ÙÙ","ÙÙÙÙ","Ø£Ø³ÙÙ","ÙØ³Ø§Ø±","Ø§ÙØ£ÙÙØ§Ø·","Ø§ÙØ·Ø¨ÙØ§Øª","ÙØ­Ø§Ø°Ø§Ø©","Ø§ÙÙÙÙÙ","Ø§ÙÙØ³Ø·","Ø§ÙÙØ³Ø§Ø±","--ØºÙØ± ÙØ¶Ø¨ÙØ·--","Src","Ø§ÙØ¹ÙÙØ§Ù","Ø§ÙØ¹ÙÙØ§Ù Ø§ÙØ¨Ø¯ÙÙ","Ø§ÙØ±Ø§Ø¨Ø·","Ø§ÙØªØ­ Ø§ÙØ±Ø§Ø¨Ø· ÙÙ ÙØ§ÙØ°Ø© Ø¬Ø¯ÙØ¯Ø©","Ø§ÙØµÙØ±Ø©","ÙÙÙ","ÙØªÙØ¯Ù","Ø®ØµØ§Ø¦Øµ Ø§ÙØµÙØ±Ø©","Ø¥ÙØºØ§Ø¡","Ø­Ø³ÙØ§","ÙØªØµÙØ­ Ø§ÙÙÙÙØ§Øª","Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙ ØªØ­ÙÙÙ Ø§ÙÙØ§Ø¦ÙØ© ","Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙ ØªØ­ÙÙÙ Ø§ÙÙØ¬ÙØ¯Ø§Øª","ÙÙ Ø£ÙØª ÙØ§Ø«ÙØ","Ø£Ø¯Ø®Ù Ø§Ø³Ù Ø§ÙÙØ¬ÙØ¯","Ø¥ÙØ´Ø§Ø¡ ÙØ¬ÙØ¯","Ø£ÙØªØ¨ Ø¥Ø³Ù","Ø¥Ø³ÙØ§Ø· ØµÙØ±Ø©","Ø¥Ø³ÙØ§Ø· Ø§ÙÙÙÙ","Ø£Ù Ø£ÙÙØ±","Ø§ÙÙØµ Ø§ÙØ¨Ø¯ÙÙ","Ø±ÙØ¹","ØªØµÙØ­","Ø§ÙØ®ÙÙÙØ©","ÙØµ","Ø£Ø¹ÙÙ","Ø§ÙÙØ³Ø·","Ø§ÙØ£Ø³ÙÙ","Ø¥Ø¯Ø±Ø§Ø¬ Ø¹ÙÙØ¯ ÙØ¨Ù","Ø¥Ø¯Ø±Ø§Ø¬ Ø¹ÙÙØ¯ Ø¨Ø¹Ø¯","Ø¥Ø¯Ø±Ø§Ø¬ ØµÙ Ø£Ø¹ÙÙ","Ø¥Ø¯Ø±Ø§Ø¬ ØµÙ Ø£Ø³ÙÙ","Ø­Ø°Ù Ø§ÙØ¬Ø¯ÙÙ","Ø­Ø°Ù Ø§ÙØµÙ","Ø­Ø°Ù Ø§ÙØ¹ÙÙØ¯","Ø®ÙÙØ© ÙØ§Ø±ØºØ©","%d Ø­Ø±Ù","%d ÙÙØ§Ù","Ø§Ø¶Ø±Ø¨ ÙÙ Ø®ÙØ§Ù","Ø£ÙØ¯","Ø­Ø±Ù ÙÙÙÙ","ÙØ®Ø·ÙØ·Ø©","ÙØ·Ø¹ Ø§ÙØ§Ø®ØªÙØ§Ø±","Ø§Ø®ØªØ± Ø§ÙÙÙ","Ø§Ø³ØªØ±Ø§Ø­Ø©","Ø§ÙØ¨Ø­Ø« Ø¹Ù","Ø§Ø³ØªØ¨Ø¯Ù Ø¨","ÙØ­Ù ÙØ­Ù","ÙØ¹Ø¬ÙÙ","Ø§Ø®ØªØ± ÙØ­ØªÙÙ ÙÙØµÙ","ÙØµØ¯Ø±","Ø¨Ø§ÙØ®Ø· Ø§ÙØ¹Ø±ÙØ¶","ÙØ§Ø¦Ù","Ø´ØºÙ","ØµÙØ©","Ø¥ÙØºØ§Ø¡","ÙØ±Ø±","Ø·Ø§ÙÙØ©","ØµÙØ±Ø©","ÙØ¸ÙÙ","ÙÙØ±Ø©","Ø­Ø¬Ù Ø§ÙØ®Ø·","ÙÙØ¯ÙÙ","Ø§ÙØ®Ø·","Ø­ÙÙ Ø§ÙÙØ­Ø±Ø±","Ø·Ø¨Ø§Ø¹Ø©","Ø±ÙØ²","Ø£ÙØ¯","Ø´Ø·Ø¨","Ø§ÙÙØ³Ø§ÙØ© Ø§ÙØ¨Ø§Ø¯Ø¦Ø©","ÙØªÙØ¡","ÙÙØ¡ Ø§ÙØ´Ø§Ø´Ø©","Ø§ÙØ­Ø¬Ù Ø§ÙØªÙÙÙØ¯Ù","ÙØ³Ø® Ø§ÙØªÙØ³ÙÙ","Ø§ÙØ®Ø·","ÙØ§Ø¦ÙØ©","ÙØ§Ø¦ÙØ© ÙØ±ÙÙØ©","ÙØ·Ø¹","Ø§Ø®ØªØ± Ø§ÙÙÙ","ÙØ§ÙÙÙ","ÙØªØ­ Ø§ÙØ±Ø§Ø¨Ø·","ØªØ¹Ø¯ÙÙ Ø§ÙØ±Ø§Ø¨Ø·","Ø³ÙØ© Nofollow","Ø¥Ø²Ø§ÙØ© Ø§ÙØ±Ø§Ø¨Ø·","ØªØ­Ø¯ÙØ«","ÙØªØ­Ø±ÙØ±","ÙØ±Ø§Ø¬Ø¹Ø©","URL","ØªØ­Ø±ÙØ±","ÙØ­Ø§Ø°Ø§Ø© Ø£ÙÙÙØ©","ÙÙØªØ±","Ø¹Ù Ø·Ø±ÙÙ Ø§ÙØªØºÙÙØ±","Ø¨Ø§ÙØ§Ø³Ù","Ø­Ø³Ø¨ Ø§ÙØ­Ø¬Ù","Ø¥Ø¶Ø§ÙØ© ÙØ¬ÙØ¯","Ø¥Ø¹Ø§Ø¯Ø©","Ø§Ø­ØªÙØ¸","Ø­ÙØ¸ Ø¨Ø§Ø³Ù","ØªØºÙÙØ± Ø§ÙØ­Ø¬Ù","Ø­Ø¬Ù Ø§ÙÙØ·Ø¹","Ø¹Ø±Ø¶","Ø§Ø±ØªÙØ§Ø¹","Ø­Ø§ÙØ¸ Ø¹ÙÙ Ø§ÙÙØ³Ø¨","Ø£Ù","ÙØ§","Ø­Ø°Ù","ØªÙÙØ²","ØªÙÙØ² %s","ÙØ­Ø§Ø°Ø§Ø© Ø¹ÙÙØ¯ÙØ©","Ø§ÙØ´ÙØ ÙØ²Ù","Ø§Ø°ÙØ¨","Ø£Ø¶Ù Ø§ÙØ¹ÙÙØ¯","Ø§Ø¶Ù Ø³Ø·Ø±","Ø±Ø®ØµØ© %s","Ø­Ø°Ù","Ø§ÙÙØ³Ø§Ù Ø¹ÙÙØ¯Ù","ØªÙØ³ÙÙ Ø£ÙÙÙ","Ø§ÙØ­Ø¯ÙØ¯","ÙØ´Ø¨Ù Ø§ÙÙÙØ¯ Ø§ÙØ®Ø§Øµ Ø¨Ù HTML. ØªØ¨ÙÙ ÙÙØ§ HTMLØ","Ø§ÙØµÙ Ù HTML","Ø§Ø­ØªÙØ¸","Ø¥Ø¯Ø±Ø§Ø¬ ÙÙØµ","Ø¥Ø¯Ø±Ø§Ø¬ Ø§ÙÙØµ ÙÙØ·","ÙÙÙÙÙ ÙÙØ· ØªØ­Ø±ÙØ± ØµÙØ±Ù Ø§ÙØ®Ø§ØµØ©. ØªØ­ÙÙÙ ÙØ°Ù Ø§ÙØµÙØ±Ø© Ø¹ÙÙ Ø§ÙÙØ¶ÙÙØ","ØªÙ ØªØ­ÙÙÙ Ø§ÙØµÙØ±Ø© Ø¨ÙØ¬Ø§Ø­ Ø¹ÙÙ Ø§ÙØ®Ø§Ø¯Ù!","ÙÙØ­Ø©","ÙØ§ ØªÙØ¬Ø¯ ÙÙÙØ§Øª ÙÙ ÙØ°Ø§ Ø§ÙØ¯ÙÙÙ.","Ø¥Ø¹Ø§Ø¯Ø© ØªØ³ÙÙØ©","Ø£Ø¯Ø®Ù Ø§Ø³Ù Ø¬Ø¯ÙØ¯","ÙØ¹Ø§ÙÙØ©","ØªØ­ÙÙÙ","ÙØµÙ ÙÙ Ø§ÙØ­Ø§ÙØ¸Ø©","ÙØªØµÙØ­Ù ÙØ§ ÙØ¯Ø¹Ù Ø¥ÙÙØ§ÙÙØ© Ø§ÙÙØµÙÙ Ø§ÙÙØ¨Ø§Ø´Ø± Ø¥ÙÙ Ø§ÙØ­Ø§ÙØ¸Ø©.","ÙØ³Ø® Ø§ÙØªØ­Ø¯ÙØ¯","ÙØ³Ø®","Ø¯Ø§Ø¦Ø±Ø© ÙØµÙ ÙØ·Ø±ÙØ§ Ø§ÙØ­Ø¯ÙØ¯"]

/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports.default = ["NapiÅ¡ nÄco","O Jodit","Editor Jodit","Verze pro nekomerÄnÃ­ pouÅ¾itÃ­","Licence GNU (GPL), verze 2 nebo vyÅ¡Å¡Ã­","Jodit UÅ¾ivatelskÃ¡ pÅÃ­ruÄka","obsahuje detailnÃ­ nÃ¡povÄdu","Pro informace o licenci, prosÃ­m, pÅejdÄte na naÅ¡i strÃ¡nku:","Koupit plnou verzi","Copyright Â© XDSoft.net - Chupurnov Valeriy. VÅ¡echna prÃ¡va vyhrazena.","Anchor","OtevÅÃ­t v novÃ© zÃ¡loÅ¾ce","OtevÅÃ­t v celoobrazovkovÃ©m reÅ¾imu","VyÄistit formÃ¡tovÃ¡nÃ­","Barva vÃ½plnÄ a pÃ­sma","VpÅed","ZpÄt","TuÄnÃ©","KurzÃ­va","OdrÃ¡Å¾ky","ÄÃ­slovanÃ½ seznam","Zarovnat na stÅed","Zarovnat do bloku","Zarovnat vlevo","Zarovnat vpravo","VloÅ¾it horizontÃ¡lnÃ­ linku","VloÅ¾it obrÃ¡zek","VloÅ¾it soubor","VloÅ¾it video (YT/Vimeo)","VloÅ¾it odkaz","Velikost pÃ­sma","Typ pÃ­sma","FormÃ¡tovat blok","NormÃ¡lnÃ­ text","Nadpis 1","Nadpis 2","Nadpis 3","Nadpis 4","CitÃ¡t","KÃ³d","VloÅ¾it","VloÅ¾it tabulku","ZmenÅ¡it odsazenÃ­","ZvÄtÅ¡it odsazenÃ­","Vybrat speciÃ¡lnÃ­ symbol","VloÅ¾it speciÃ¡lnÃ­ symbol","PouÅ¾Ã­t formÃ¡t","ZmÄnit mÃ³d","Okraje","hornÃ­","pravÃ½","spodnÃ­","levÃ½","Styly","TÅÃ­dy","ZarovnÃ¡nÃ­","Vpravo","Na stÅed","Vlevo","--nenastaveno--","src","Titulek","AlternativnÃ­ text (alt)","Link","OtevÅÃ­t link v novÃ© zÃ¡loÅ¾ce","ObrÃ¡zek","soubor","RozÅ¡Ã­ÅenÃ©","Vlastnosti obrÃ¡zku","ZpÄt","Ok","ProhlÃ­Å¾eÄ souborÅ¯","Chyba pÅi naÄÃ­tÃ¡nÃ­ seznamu souborÅ¯","Chyba pÅi naÄÃ­tÃ¡nÃ­ sloÅ¾ek","Jste si jistÃ½(Ã¡)?","NÃ¡zev sloÅ¾ky","VytvoÅit sloÅ¾ku","nÃ¡zev","PÅetÃ¡hnÄte sem obrÃ¡zek","PÅetÃ¡hnÄte sem soubor","nebo kliknÄte","AlternativnÃ­ text","NahrÃ¡t","Server","PozadÃ­","Text","Nahoru","Na stÅed","Dolu","VloÅ¾it sloupec pÅed","VloÅ¾it sloupec za","VloÅ¾it ÅÃ¡dek nad","VloÅ¾it ÅÃ¡dek pod","Vymazat tabulku","Vymazat ÅÃ¡dku","Vymazat sloupec","VyÄistit buÅku","Znaky: %d","Slova: %d","PÅeÅ¡krtnuto","PodtrÅ¾eno","HornÃ­ index","DolnÃ­ index","Vyjmout oznaÄenÃ©","OznaÄit vÅ¡e","ZalomenÃ­","Najdi","Nahradit za","Nahradit","VloÅ¾it","Vyber obsah pro vloÅ¾enÃ­","HTML","tuÄnÄ","kurzÃ­va","Å¡tÄtec","odkaz","zpÄt","vpÅed","tabulka","obrÃ¡zek","guma","odstavec","velikost pÃ­sma","video","pÃ­smo","Ð¾ editoru","tisk","symbol","podtrÅ¾eno","pÅeÅ¡krtnuto","zvÄtÅ¡it odsazenÃ­","zmenÅ¡it odsazenÃ­","celoobrazovkovÃ½ reÅ¾im","smrsknout","KopÃ­rovat formÃ¡t","Linka","OdrÃ¡Å¾ka","ÄÃ­slovanÃ½ seznam","Vyjmout","OznaÄit vÅ¡e","KÃ³d","OtevÅÃ­t odkaz","Upravit odkaz","Atribut no-follow","Odstranit odkaz","Aktualizovat","Chcete-li upravit","Zobrazit","URL","Editovat","HorizontÃ¡lnÃ­ zarovnÃ¡nÃ­","Filtr","Dle poslednÃ­ zmÄny","Dle nÃ¡zvu","Dle velikosti","PÅidat sloÅ¾ku","Reset","UloÅ¾it","UloÅ¾it jako...","ZmÄnit rozmÄr","OÅezat","Å Ã­Åka","VÃ½Å¡ka","Ponechat pomÄr","Ano","Ne","Vyjmout","OznaÄit","OznaÄit %s","VertikÃ¡lnÃ­ zarovnÃ¡nÃ­","RozdÄlit","Spojit","PÅidat sloupec","PÅidat ÅÃ¡dek","Licence: %s","Vymazat","RozdÄlit vertikÃ¡lnÄ","RozdÄlit horizontÃ¡lnÄ","Okraj","VÃ¡Å¡ text se podobÃ¡ HTML. VloÅ¾it ho jako HTML?","VloÅ¾it jako HTML","Ponechat originÃ¡l","VloÅ¾it jako TEXT","VloÅ¾it pouze TEXT","MÅ¯Å¾ete upravovat pouze svÃ© obrÃ¡zky. NaÄÃ­st obrÃ¡zek?","ObrÃ¡zek byl ÃºspÄÅ¡nÄ nahrÃ¡n!","paleta","V tomto adresÃ¡Åi nejsou Å¾Ã¡dnÃ© soubory.","pÅejmenovat","Zadejte novÃ½ nÃ¡zev","nÃ¡hled","StaÅ¾enÃ­","VloÅ¾it ze schrÃ¡nky","VÃ¡Å¡ prohlÃ­Å¾eÄ nepodporuje pÅÃ­mÃ½ pÅÃ­stup do schrÃ¡nky.","KopÃ­rovat vÃ½bÄr","kopÃ­rovÃ¡nÃ­","Border radius"]

/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports.default = ["Bitte geben Sie einen Text ein","Ãber Jodit","Jodit Editor","Freie Nicht-kommerzielle Version","GNU General Public License, Version 2 oder hÃ¶her","Das Jodit Benutzerhandbuch","beinhaltet ausfÃ¼hrliche Informationen wie Sie den Editor verwenden kÃ¶nnen.","FÃ¼r Lizenz-Informationen, besuchen Sie bitte unsere Webseite:","Vollversion kaufen","Copyright Â© XDSoft.net - Chupurnov Valeriy. Alle Rechte vorbehalten.","Anker","In neuer Registerkarte Ã¶ffnen","Editor in voller GrÃ¶Ãe Ã¶ffnen","Formatierung lÃ¶schen","FÃ¼llfarbe oder Textfarbe Ã¤ndern","Wiederholen","RÃ¼ckgÃ¤ngig machen","Fett","Kursiv","Ungeordnete Liste einfÃ¼gen","Sortierte Liste einfÃ¼gen","Mittig ausrichten","Blocksatz","Links ausrichten","Rechts ausrichten","Horizontale Linie einfÃ¼gen","Bild einfÃ¼gen","Datei einfÃ¼gen","Youtube/vimeo Video einfÃ¼gen","Link einfÃ¼gen","SchriftgrÃ¶Ãe","Schriftfamilie","Formatblock einfÃ¼gen","Normal","Ãberschrift 1","Ãberschrift 2","Ãberschrift 3","Ãberschrift 4","Zitat","Code","EinfÃ¼gen","Tabelle einfÃ¼gen","Einzug verkleinern","Einzug vergrÃ¶Ãern","Sonderzeichen auswÃ¤hlen","Sonderzeichen einfÃ¼gen","Format kopieren","Ãnderungsmodus","RÃ¤nder","Oben","Rechts","Unten","Links","CSS Stiel","CSS Klassen","Ausrichten","Rechts","Zentriert","Links","Keine","Pfad","Titel","Alternativer Text","Link","Link in neuem Tab Ã¶ffnen","Bild","Datei","Fortgeschritten","Bildeigenschaften","Abbrechen","OK","Dateibrowser","Fehler beim Laden der Liste","Fehler beim Laden der Ordner","Sind Sie sicher?","Geben Sie den Verzeichnisnamen ein","Verzeichnis erstellen","Typname","Bild hier hinziehen","Datei lÃ¶schen","oder hier klicken","Alternativtext","Hochladen","AuswÃ¤hlen","Hintergrund","Text","Oben","Mittig","Unten","Spalte einfÃ¼gen vor","Spalte einfÃ¼gen nach","Zeile einfÃ¼gen oberhalb","Zeile unterhalb einfÃ¼gen","Tabelle lÃ¶schen","Zeile lÃ¶schen","Spalte lÃ¶schen","Leere Zelle","Zeichen: %d","WÃ¶rter: %d","Durchschlagen","Unterstreichen","hochgestellt","Index","Auswahl ausschneid","WÃ¤hlen Sie Alle aus","Pause","Suche nach","Ersetzen durch","Ersetzen","EinfÃ¼gen","WÃ¤hlen Sie Inhalt zum EinfÃ¼gen","HTML","Fett gedruckt","kursiv","BÃ¼rste","VerknÃ¼pfung","rÃ¼ckgÃ¤ngig machen","wiederholen","Tabelle","Bild","Radiergummi","Absatz","SchriftgrÃ¶Ãe","Video","Schriftart","Ãber","drucken","Symbol","unterstreichen","durchgestrichen","Einzug","Aussenseiter","VollgrÃ¶Ãe","schrumpfen","Format kopierenÑ","die Linie","Liste von","Nummerierte Liste","Schnitt","WÃ¤hlen Sie Alle aus","Code einbetten","Link Ã¶ffnen","Link bearbeiten","Nofollow-Attribut","Link entfernen","Aktualisieren","Bearbeiten","Ansehen","URL","Bearbeiten","Horizontale Ausrichtung","filter","Sortieren nach geÃ¤ndert","Nach Name sortieren","Nach GrÃ¶Ãe sortiert","Ordner hinzufÃ¼gen","Wiederherstellen","Speichern","Speichern als","Ãndern Sie die GrÃ¶Ãe","GrÃ¶Ãe anpassen","Breite","HÃ¶he","Halten Sie Proportionen","Ja","Nein","Entfernen","Markieren","Markieren: %s","Vertikale Ausrichtung","Split","Verschmelzen","Spalte hinzufÃ¼gen","Zeile hinzufÃ¼gen",null,"LÃ¶schen","Split vertikal","Split horizontally","Rand","Es scheint als dass Sie HTML-Text einfÃ¼gen mÃ¶chten","Als HTML einfÃ¼gen?","Original speichern","Als Text einfÃ¼gen","Nur Text einfÃ¼gen","Sie kÃ¶nnen nur Ihre eigenen Bilder bearbeiten. Laden Sie dieses Bild auf dem Host herunter?","Das Bild wurde erfolgreich auf den Server hochgeladen!null","Palette","In diesem Verzeichnis befinden sich keine Dateien.","umbenennen","Geben Sie einen neuen Namen ein","Vorschau","Herunterladen","Aus der Zwischenablage einfÃ¼gen","Ihr browser unterstÃ¼tzt kein direkter Zugriff auf die Zwischenablage.","Auswahl kopieren","kopieren","Border-radius"]

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports.default = ["Escriba algo...","Acerca de Jodit","Jodit Editor","VersiÃ³n gratis no comercial","GNU General Public License, VersiÃ³n 2 o posterior","GuÃ­a de usuario Jodit","contiene ayuda detallada para el uso.","Para informaciÃ³n sobre la licencia, por favor visite nuestro sitio:","Compre la versiÃ³n completa","Copyright Â© XDSoft.net - Chupurnov Valeriy. Todos los derechos reservados.","Anclar","Abrir en nueva pestaÃ±a","Abrir editor en pantalla completa","Limpiar formato","Color de relleno o de letra","Rehacer","Deshacer","Negrita","Cursiva","Insertar lista no ordenada","Insertar lista ordenada","Alinear Centrado","Alinear Justificado","Alinear Izquierda","Alinear Derecha","Insertar lÃ­nea horizontal","Insertar imagen","Insertar archivo","Insertar video de Youtube/vimeo","Insertar vÃ­nculo","TamaÃ±o de letra","Familia de letra","Insertar bloque","Normal","Encabezado 1","Encabezado 2","Encabezado 3","Encabezado 4","Cita","CÃ³digo","Insertar","Insertar tabla","Disminuir sangrÃ­a","Aumentar sangrÃ­a","Seleccionar caracter especial","Insertar caracter especial","Copiar formato","Cambiar modo","MÃ¡rgenes","arriba","derecha","abajo","izquierda","Estilos CSS","Clases CSS","Alinear","Derecha","Centrado","Izquierda","--No Establecido--","Fuente","TÃ­tulo","Texto Alternativo","VÃ­nculo","Abrir vÃ­nculo en nueva pestaÃ±a","Imagen","Archivo","Avanzado","Propiedades de imagen","Cancelar","Aceptar","Buscar archivo","Error al cargar la lista","Error al cargar las carpetas","Â¿EstÃ¡ seguro?","Entre nombre de carpeta","Crear carpeta","Entre el nombre","Soltar imagen","Soltar archivo","o click","Texto alternativo","Subir","Buscar","Fondo","Texto","Arriba","Centro","Abajo","Insertar columna antes","Interar columna despuÃ©s","Insertar fila arriba","Insertar fila debajo","Borrar tabla","Borrar fila","Borrar columna","Vaciar celda","Caracteres: %d","Palabras: %d","Tachado","Subrayado","superÃ­ndice","subÃ­ndice","Cortar selecciÃ³n","Seleccionar todo","Pausa","Buscar","Reemplazar con","Reemplazar","Pegar","Seleccionar contenido para pegar","HTML","negrita","cursiva","Brocha","VÃ­nculo","deshacer","rehacer","Tabla","Imagen","Borrar","PÃ¡rrafo","TamaÃ±o de letra","Video","Letra","Acerca de","Imprimir","SÃ­mbolo","subrayar","tachar","sangrÃ­a","quitar sangrÃ­a","TamaÃ±o completo","encoger","Copiar formato","lÃ­nea horizontal","lista sin ordenar","lista ordenada","Cortar","Seleccionar todo","Incluir cÃ³digo","Abrir vÃ­nculo","Editar vÃ­nculo","No seguir","Desvincular","Actualizar","Para editar","Ver","URL","Editar","AlineaciÃ³n horizontal","filtrar","Ordenar por fecha modificaciÃ³n","Ordenar por nombre","Ordenar por tamaÃ±o","Agregar carpeta","Resetear","Guardar","Guardar como...","Redimensionar","Recortar","Ancho","Alto","Mantener relaciÃ³n de aspecto","Si","No","Quitar","Seleccionar","Seleccionar: %s","AlineaciÃ³n vertical","Dividir","Mezclar","Agregar columna","Agregar fila",null,"Borrar","Dividir vertical","Dividir horizontal","Borde","El cÃ³digo es similar a HTML. Â¿Mantener como HTML?","Pegar como HTML?","Mantener","Insertar como texto","Insertar solo texto","Solo puedes editar tus propias imÃ¡genes. Â¿Descargar esta imagen en el servidor?","Â¡La imagen se ha subido correctamente al servidor!","paleta","No hay archivos en este directorio.","renombrar","Ingresa un nuevo nombre","avance","Descargar","Pegar desde el portapapeles","Su navegador no soporta el acceso directo en el portapapeles.","SelecciÃ³n de copia","copia","Radio frontera"]

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports.default = ["Ecrivez ici","A propos de Jodit","Editeur Jodit","Version gratuite, non commerciale","GNU General Public License, version 2 ou ultÃ©rieure","Guide de l'utilisateur","Aide dÃ©taillÃ©e Ã  l'utilisation","Consulter la licence sur notre site web:","Acheter la version complÃ¨te","Copyright Â© XDSoft.net - Chupurnov Valeriy. Tous droits rÃ©servÃ©s.","Ancre","Ouvrir dans un nouvel onglet","Ouvrir l'Ã©diteur en pleine page","Supprimer le formattage","Modifier la couleur du fond ou du texte","Refaire","DÃ©faire","Gras","Italique","Liste non ordonnÃ©e","Liste ordonnÃ©e","Centrer","Justifier","Aligner Ã  gauche ","Aligner Ã  droite","InsÃ©rer une ligne horizontale","InsÃ©rer une image","InsÃ©rer un fichier","InsÃ©rer une vidÃ©o","InsÃ©rer un lien","Taille des caractÃ¨res","Famille des caractÃ¨res","Bloc formattÃ©","Normal","Titre 1","Titre 2","Titre 3","Titre 4","Citation","Code","InsÃ©rer","InsÃ©rer un tableau","Diminuer le retrait","Retrait plus","SÃ©lectionnez un caractÃ¨re spÃ©cial","InsÃ©rer un caractÃ¨re spÃ©cial","Cloner le format","Mode wysiwyg <-> code html","Marges","haut","droite","Bas","gauche","Styles","Classes","Alignement","Droite","Centre","Gauche","--Non disponible--","Source","Titre","Alternative","Lien","Ouvrir le lien dans un nouvel onglet","Image","fichier","AvancÃ©","PropriÃ©tÃ©s de l'image","Effacer","OK","Explorateur de fichiers","Erreur de liste de chargement","Erreur de dossier de chargement","Etes-vous sÃ»rs ?","Entrer le non de dossier","CrÃ©er un dossier","type de fichier","Coller une image","DÃ©poser un fichier","ou cliquer","Texte de remplacemement","Charger","Chercher","ArriÃ¨re-plan","Texte","Haut","Milieu","Bas","InsÃ©rer une colonne avant","InsÃ©rer une colonne aprÃ¨s","InsÃ©rer une ligne en dessus","InsÃ©rer une ligne en dessous","Supprimer le tableau","Supprimer la ligne","Supprimer la colonne","Vider la cellule","Symboles: %d","Mots: %d","Frapper Ã  travers","Souligner","exposant","indice","Couper la sÃ©lection","Tout sÃ©lectionner","Pause","Rechercher","Remplacer par","Remplacer","Coller","Choisissez le contenu Ã  coller","la source","graisseux","italique","verser","lien","abolir","prÃªt","graphique","Image","la gommen","clause","taille de police","Video","police","Ã  propos de l'Ã©diteur","impression","caractÃ¨re","soulignÃ©","barrÃ©","indentation","indiffÃ©rent","taille rÃ©elle","taille conventionnelle","Format de copie","la ligne","Liste des","Liste numÃ©rotÃ©e","Couper","SÃ©lectionner tout",null,"Ouvrir le lien","Modifier le lien","Attribut Nofollow","Supprimer le lien","Mettre Ã  jour","Pour Ã©diter","Voir","URL",null,"Alignement horizontal","Filtre","Trier par modifiÃ©","Trier par nom","Classer par taille","Ajouter le dossier","Restaurer","Sauvegarder","Enregistrer sous","Changer la taille","Taille de garniture","Largeur","Hauteur","Garder les proportions","Oui","Non","Supprimer","Mettre en Ã©vidence","Mettre en Ã©vidence: %s","Alignement vertical","Split","aller","Ajouter une colonne","Ajouter une rangÃ©e",null,"Effacer","Split vertical","Split horizontal",null,"Votre texte que vous essayez de coller est similaire au HTML. Collez-le en HTML?","Coller en HTML?","Sauvegarder l'original","Coller en tant que texte","Coller le texte seulement","Vous ne pouvez Ã©diter que vos propres images. TÃ©lÃ©chargez cette image sur l'hÃ´te?","L'image a Ã©tÃ© tÃ©lÃ©chargÃ©e avec succÃ¨s sur le serveur!null","Palette","Il n'y a aucun fichier dans ce rÃ©pertoire.","renommer","Entrez un nouveau nom","AperÃ§u","TÃ©lÃ©charger","Coller Ã  partir du presse-papiers","Votre navigateur ne prend pas en charge l'accÃ¨s direct Ã  la presse-papiers.","Copier la sÃ©lection","copie","Rayon des frontiÃ¨res"]

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports.default = ["××§×× ××©××...","About Jodit","Jodit Editor","Free Non-commercial Version","GNU General Public License, version 2 or later","Jodit User's Guide","contains detailed help for using.","For information about the license, please go to our website:","Buy full version","Copyright Â© XDSoft.net - Chupurnov Valeriy. All rights reserved.","××§×× ×¢××××","×¤×ª× ×××¨×××¡×× ×××©×","×¤×ª× ××ª ××¢××¨× ××××× ×××©","× ×§× ×¢××¦××","×©× × ×¦××¢ ××§×¡× ×× ×¨×§×¢","××¦×¢ ×©××","×××","×××××©","× ×××","××× ×¡ ×¨×©×××ª ×ª××××××","××× ×¡ ×¨×©××× ××××¡×¤×¨×ª","××¨××","××©×¨ ","××©×¨ ××©×××","××©×¨ ×××××","××× ×¡ ×§× ×××¤×§×","××× ×¡ ×ª××× ×","××× ×¡ ×§×××¥","××× ×¡ ×¡×¨××× ××××× ×YouTube/Vimeo","××× ×¡ ×§××©××¨","×××× ×××¤×","×××¤×","××¢××¦× ××¨××©","×¨×××","×××ª×¨×ª 1","×××ª×¨×ª 2","×××ª×¨×ª 3","×××ª×¨×ª 4","×¦××××","×§××","××× ×¡","××× ×¡ ××××","××§×× ×× ××¡×","×××× ×× ××¡×","×××¨ ×ª× ×××××","××× ×¡ ×ª× ×××××","××¢×ª×§ ×¢××¦××","××××£ ××¦×","×¨××××","×¢××××","××××","×ª××ª××","×©×××","×¢××¦×× CSS","××××§×ª CSS","×××©××¨","××××","××¨××","×©×××","--×× × ×§××¢--","××§××¨","×××ª×¨×ª","×××ª×× ××××¤×","×§××©××¨","×¤×ª× ×××¨×××¡×× ×××©×","×ª××× ×","×§×××¥","××ª×§××","×××¤××× × ×ª××× ×","×××××","×××©××¨","×¡×××¨ ××§××¦××","×©××××  ×××× ××¢×× ×ª ×¨×©×××","×©×××× ×××× ××¢×× ×ª ×ª×§×××ª","××× ××ª× ××××?","××× ×¡ ×©× ×ª×§××","×¦××¨ ×ª×§××","×¡×× ××§×××¥","××¡×¨ ×ª××× ×","××¡×¨ ×§×××¥","×× ×××¥","×××ª×× ××××¤×","××¢××","×¡×××¨","×¨×§×¢","××§×¡×","×¢××××","××¨××","×ª××ª××","××× ×¡ ×¢×××× ××¤× ×","××× ×¡ ×¢×××× ×××¨×","××× ×¡ ×©××¨× ××¢×","××× ×¡ ×©××¨× ××ª××ª","×××§ ××××","×××§ ×©××¨×","×××§ ×¢××××","×¨××§× ×ª×","×ª××××: %d","×××××: %d","×§× ×××¦×","×§× ×ª××ª××","superscript","subscript","××××¨ ××××¨×","×××¨ ×××","×©×××¨×ª ×©××¨×","××¤×©","××××£ ×","××××£","××××§","×××¨ ×ª××× ×××××§×","HTML","×××××©","× ×××","×××¨×©×ª","×§××©××¨","×××","××¦×¢ ×©××","××××","×ª××× ×","×××§","×¤×¡×§×","×××× ×××¤×","×××××","×××¤×","×¢××× ×","×××¤×¡","×ª× ×××××","×§× ×ª××ª××","×§× ×××¦×","×××× ×× ××¡×","××§×× ×× ××¡×","×××× ×××","××××¥","××¢×ª×§ ×¢××¦××","×§× ×××¤×§×","×¨×©×××ª ×ª××××××","×¨×©××× ××××¡×¤×¨×ª","××ª××","×××¨ ×××","×××¡×£ ×§××","×¤×ª× ×§××©××¨","×¢×¨×× ×§××©××¨","××× ××¢×§×","××× ×§××©××¨","×¢×××","××× ××¢×¨××","××¦×","××ª×××ª","×¢×¨××","×××©××¨ ×××¤×§×","×¡× ×","××× ××¤× ×©×× ××","×××× ××¤× ×©×","×××× ××¤× ××××","×××¡×£ ×ª×§×××","××¤×¡","×©×××¨","×©×××¨ ××©×...","×©× × ××××","××ª××","×¨×××","××××","×©×××¨ ×××¡","××","××","××¡×¨","×××¨","× ×××¨: %s","×××©××¨ ×× ××","×¤××¦××","×××","×××¡×£ ×¢××××","×××¡×£ ×©××¨×",null,"×××§","×¤××¦×× ×× ××","×¤××¦×× ×××¤×§×","××¡××¨×ª","××§×× ×××× ×HTML, ××× ×××©×××¨ ×HTML","××××§ ×HTML","××©××¨","××× ×¡ ×××§×¡×","××× ×¡ ××§×¡× ××××","×¨×§ ×§××¦×× ×××©×××××× ×©×× × ××ª× ×× ××¢×¨×××. ××× ××××¨×× ××ª ××§×××¥?","××ª××× × ×¢××ª× ×××¦×××!","×××","××× ×§××¦×× ××¡×¤×¨×× ××.","××× ××¨××ª","××× ×©× ×××©","×ª×¦××× ××§××××","×××¨×","××××××§ ×××××","×××¤××¤× ×©×× ×× ×ª××× ×××©× ××©××¨× ××××.","××¢×ª×§ ××××¨×","××¢×ª×§","×¨××××¡ ×××××"]

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports.default = ["Ãrjon be valamit","JoditrÃ³l","Jodit Editor","Ingyenes vÃ¡ltozat","GNU General Public License, VerziÃ³ 2 vagy kÃ©sÅbbi","Jodit ÃºtmutatÃ³","tovÃ¡bbi segÃ­tsÃ©get tartalmaz","TovÃ¡bbi licence informÃ¡ciÃ³kÃ©rt lÃ¡togassa meg a weboldalunkat:","Teljes verziÃ³ megvÃ¡sÃ¡rlÃ¡sa","Copyright Â© XDSoft.net - Chupurnov Valeriy. Minden jog fenntartva.","Horgony","MegnyitÃ¡s Ãºj lapon","MegnyitÃ¡s teljes mÃ©retben","FormÃ¡zÃ¡s tÃ¶rlÃ©se","HÃ¡ttÃ©r/szÃ¶veg szÃ­n","Ãjra","Visszavon","FÃ©lkÃ¶vÃ©r","DÅlt","Pontozott lista","SzÃ¡mozott lista","KÃ¶zÃ©pre zÃ¡rt","SorkizÃ¡rt","Balra zÃ¡rt","Jobbra zÃ¡rt","VÃ­zszintes vonal beszÃºrÃ¡sa","KÃ©p beszÃºrÃ¡s","FÃ¡jl beszÃºrÃ¡s","Youtube videÃ³ beszÃºrÃ¡sa","Link beszÃºrÃ¡s","BetÅ±mÃ©ret","BetÅ±tÃ­pus","FormÃ¡zott blokk beszÃºrÃ¡sa","NormÃ¡l","FejlÃ©c 1","FejlÃ©c 2","FejlÃ©c 3","FejlÃ©c 4","IdÃ©zet","KÃ³d","BeszÃºr","TÃ¡blÃ¡zat beszÃºrÃ¡sa","BehÃºzÃ¡s csÃ¶kkentÃ©se","BehÃºzÃ¡s nÃ¶velÃ©se","SpeciÃ¡lis karakter kivÃ¡lasztÃ¡sa","SpeciÃ¡lis karakter beszÃºrÃ¡sa","KÃ©p formÃ¡zÃ¡sa","NÃ©zet vÃ¡ltÃ¡sa","SzegÃ©lyek","felsÅ","jobb","alsÃ³","bal","CSS stÃ­lusok","CSS osztÃ¡lyok","IgazÃ­tÃ¡s","Jobbra","KÃ¶zÃ©pre","Balra","Nincs","ForrÃ¡s","CÃ­m","HelyettesÃ­tÅ szÃ¶veg","Link","Link megnyitÃ¡sa Ãºj lapon","KÃ©p","FÃ¡jl","HaladÃ³","KÃ©p tulajdonsÃ¡gai","MÃ©gsem","OK","FÃ¡jl tallÃ³zÃ³","Hiba a lista betÃ¶ltÃ©se kÃ¶zben","Hiba a mappÃ¡k betÃ¶ltÃ©se kÃ¶zben","Biztosan ezt szeretnÃ©?","Ãrjon be egy mappanevet","Mappa lÃ©trehozÃ¡sa","Ã­rjon be bevet","HÃºzza ide a kÃ©pet","HÃºzza ide a fÃ¡jlt","vagy kattintson","HelyettesÃ­tÅ szÃ¶veg","FeltÃ¶lt","TallÃ³z","HÃ¡ttÃ©r","SzÃ¶veg","Fent","KÃ¶zÃ©pen","Lent","Oszlop beszÃºrÃ¡s elÃ©","Oszlop beszÃºrÃ¡s utÃ¡na","Sor beszÃºrÃ¡s fÃ¶lÃ©","Sor beszÃºrÃ¡s alÃ¡","TÃ¡blÃ¡zat tÃ¶rlÃ©se","Sor tÃ¶rlÃ©se","Oszlop tÃ¶rlÃ©se","Cella tartalmÃ¡nak tÃ¶rlÃ©se","Karakterek szÃ¡ma: %d","Szavak szÃ¡ma: %d","ÃthÃºzott","AlÃ¡hÃºzott","FelsÅ index","AlsÃ³ index","KivÃ¡gÃ¡s","Ãsszes kijelÃ¶lÃ©se","SzÃ¼net","KeresÃ©s","Csere erre","Csere","BeillesztÃ©s","VÃ¡lasszon tartalmat a beillesztÃ©shez","HTML","FÃ©lkÃ¶vÃ©r","DÅlt","Ecset","Link","Visszavon","Ãjra","TÃ¡blÃ¡zat","KÃ©p","TÃ¶rlÃ©s","ParagrÃ¡fus","BetÅ±mÃ©ret","VideÃ³","BetÅ±","RÃ³lunk","Nyomtat","SzimbÃ³lum","AlÃ¡hÃºzott","ÃthÃºzott","BehÃºzÃ¡s","Aussenseiter","Teljes mÃ©ret","Ãsszenyom","FormÃ¡tum mÃ¡solÃ¡s","Egyenes vonal","Lista","SzÃ¡mozott lista","KivÃ¡g","Ãsszes kijelÃ¶lÃ©se","BeÃ¡gyazott kÃ³d","Link megnyitÃ¡sa","Link szerkesztÃ©se","Nincs kÃ¶vetÃ©s","Link levÃ¡lasztÃ¡sa","FrissÃ­t","SzerkesztÃ©s","felÃ¼lvizsgÃ¡lat","URL","Szerkeszt","VÃ­zszintes igazÃ­tÃ¡s","SzÅ±rÅ","RendezÃ©s mÃ³dosÃ­tÃ¡s szerint","RendezÃ©s nÃ©v szerint","RendezÃ©s mÃ©ret szerint","Mappa hozzÃ¡adÃ¡s","VisszaÃ¡llÃ­t","MentÃ©s","MentÃ©s mÃ¡skÃ©nt...","ÃtmÃ©retezÃ©s","KivÃ¡g","SzÃ©lessÃ©g","MagassÃ¡g","KÃ©parÃ¡ny megtartÃ¡sa","Igen","Nem","EltÃ¡volÃ­t","KijelÃ¶l","KijelÃ¶l: %s","FÃ¼ggÅleges igazÃ­tÃ¡s","FelosztÃ¡s","ÃsszevonÃ¡s","Oszlop hozzÃ¡adÃ¡s","Sor hozzÃ¡adÃ¡s",null,"TÃ¶rlÃ©s","FÃ¼ggÅleges felosztÃ¡s","VÃ­zszintes felosztÃ¡s","SzegÃ©ly","A beillesztett szÃ¶veg HTML-nek tÅ±nik. Megtartsuk HTML-kÃ©nt?","BeszÃºrÃ¡s HTML-kÃ©nt","MegtartÃ¡s","BeszÃºrÃ¡s szÃ¶vegkÃ©nt","Csak szÃ¶veg beillesztÃ©se","Csak a sajÃ¡t kÃ©peit tudja szerkeszteni. LetÃ¶lti ezt a kÃ©pet?","KÃ©p sikeresen feltÃ¶ltve!","Palette","Er zijn geen bestanden in deze map.","Ã¡tnevezÃ©s","Adja meg az Ãºj nevet","elÅnÃ©zet","LetÃ¶ltÃ©s","Illessze be a vÃ¡gÃ³lap","A bÃ¶ngÃ©szÅ nem tÃ¡mogatja a kÃ¶zvetlen hozzÃ¡fÃ©rÃ©st biztosÃ­t a vÃ¡gÃ³lapra.","MÃ¡solÃ¡s kivÃ¡lasztÃ¡sa","mÃ¡solÃ¡s","HatÃ¡r sugÃ¡r"]

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports.default = ["Ketik sesuatu","Tentang Jodit","Editor Jodit","Versi Bebas Non-komersil","Lisensi Publik Umum (GPL), versi 2 atau terbaru","Panduan Pengguna Jodit","mencakup detail bantuan penggunaan","Untuk informasi tentang lisensi, silakan kunjungi website:","Beli versi lengkap","Hak Cipta Â© XDSoft.net - Chupurnov Valeriy. Hak cipta dilindungi undang-undang.","Tautan","Buka di tab baru","Buka editor dalam ukuran penuh","Hapus Pemformatan","Isi warna atau atur warna teks","Ulangi","Batalkan","Tebal","Miring","Sisipkan Daftar Tidak Berurut","Sisipkan Daftar Berurut","Tengah","Penuh","Kiri","Kanan","Sisipkan Garis Horizontal","Sisipkan Gambar","Sisipkan Berkas","Sisipkan video youtube/vimeo","Sisipkan tautan","Ukuran font","Keluarga font","Sisipkan blok format","Normal","Heading 1","Heading 2","Heading 3","Heading 4","Kutip","Kode","Sisipkan","Sisipkan tabel","Kurangi Indentasi","Tambah Indentasi","Pilih Karakter Spesial","Sisipkan Karakter Spesial","Formar warna","Ubah mode","Batas","atas","kanan","bawah","kiri","Gaya","Class","Rata","Kanan","Tengah","Kiri","--Tidak diset--","Src","Judul","Teks alternatif","Tautan","Buka tautan di tab baru","Gambar","berkas","Lanjutan","Properti gambar","Batal","Ya","Penjelajah Berkas","Error ketika memuat list","Error ketika memuat folder","Apakah Anda yakin?","Masukkan nama Direktori","Buat direktori","ketik nama","Letakkan gambar","Letakkan berkas","atau klik","Teks alternatif","Unggah","Jelajahi","Latar Belakang","Teks","Atas","Tengah","Bawah","Sisipkan kolom sebelumnya","Sisipkan kolom setelahnya","Sisipkan baris di atasnya","Sisipkan baris di bawahnya","Hapus tabel","Hapus baris","Hapus kolom","Kosongkan cell","Karakter: %d","Kata: %d","Coret","Garis Bawah","Superskrip","Subskrip","Potong pilihan","Pilih semua","Berhenti","Mencari","Ganti dengan","Ganti","Paste","Pilih konten untuk dipaste","sumber","tebal","miring","sikat","tautan","batalkan","ulangi","tabel","gambar","penghapus","paragraf","ukuran font","video","font","tentang","cetak","simbol","garis bawah","coret","menjorok ke dalam","menjorok ke luar","ukuran penuh","menyusut","salin format","hr","ul","ol","potong","Pilih semua","Kode embed","Buka tautan","Edit tautan","No follow","Hapus tautan","Perbarui","pensil","Mata","URL","Edit","Perataan horizontal","Filter","Urutkan berdasarkan perubahan","Urutkan berdasarkan nama","Urutkan berdasarkan ukuran","Tambah folder","Reset","Simpan","Simpan sebagai...","Ubah ukuran","Crop","Lebar","Tinggi","Jaga aspek rasio","Ya","Tidak","Copot","Pilih","Pilih %s","Rata vertikal","Bagi","Gabungkan","Tambah kolom","tambah baris","Lisensi: %s","Hapus","Bagi secara vertikal","Bagi secara horizontal","Bingkai","Kode Anda cenderung ke HTML. Biarkan sebagai HTML?","Paste sebagai HTML","Jaga","Sisipkan sebagai teks","Sisipkan hanya teks","Anda hanya dapat mengedit gambar Anda sendiri. Unduh gambar ini di host?","Gambar telah sukses diunggah ke host!","palet","Tidak ada berkas","ganti nama","Masukkan nama baru","pratinjau","Unduh","Paste dari clipboard","Browser anda tidak mendukung akses langsung ke clipboard.","Copy seleksi","copy","Border radius"]

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports.default = ["Scrivi qualcosa...","A proposito di Jodit","Jodit Editor","Versione gratuita non commerciale","Licenza pubblica generale GNU, versione 2 o successiva","Guida utente di Jodit","contiene una guida dettagliata per l'uso.","Per informazioni sulla licenza, si prega di visitare il nostro sito:","Acquista la versione completa","Copyright Â© XDSoft.net - Chupurnov Valeriy. Alle Rechte vorbehalten.","Ancora","Apri in una nuova scheda","Apri l'editor a schermo intero","Formato chiaro","Riempi colore o lettera","Ripristina","Annulla","Grassetto","Corsivo","Inserisci lista non ordinata","Inserisci l'elenco ordinato","Allinea Centra","Allineare Giustificato","Allinea a Sinistra","Allinea a Destra","Inserisci la linea orizzontale","Inserisci immagine","Inserisci un file","Inserisci video Youtube/Vimeo","Inserisci il link","Dimensione del carattere","Tipo di font","Inserisci blocco","Normale","Heading 1","Heading 2","Heading 3","Heading 4","Citazione","Codice","Inserisci","Inserisci tabella","Riduci il rientro","Aumenta il rientro","Seleziona una funzione speciale","Inserisci un carattere speciale","Copia formato","Cambia modo","Margini","su","destra","giÃ¹","sinistra","Stili CSS","Classi CSS","Allinea","Destra","Centro","Sinistra","--Non Impostato--","Fonte","Titolo","Testo Alternativo","Link","Apri il link in una nuova scheda","Immagine","Archivio","Avanzato","ProprietÃ  dell'immagine","Annulla","Accetta","Cerca il file","Errore durante il caricamento dell'elenco","Errore durante il caricamento delle cartelle","Sei sicuro?","Inserisci il nome della cartella","Crea cartella","Entre el nombre","Rilascia l'immagine","Rilascia file","o click","Testo alternativo","Carica","Sfoglia","Sfondo","Testo","Su","Centro","Sotto","Inserisci prima la colonna","Inserisci colonna dopo","Inserisci la riga sopra","Inserisci la riga sotto","Elimina tabella","Elimina riga","Elimina colonna","Cella vuota","Caratteri: %d","Parole: %d","Barrato","Sottolineato","indice","deponente","Taglia la selezione","Seleziona tutto","Pausa","Cerca","Sostituisci con","Sostituisci","Incolla","Seleziona il contenuto da incollare","HTML","Grassetto","Corsivo","Pennello","Link","Annulla","Ripristina","Tabella","Immagine","Gomma","Paragrafo","Dimensione del carattere","Video","Font","Approposito di","Stampa","Simbolo","Sottolineato","Barrato","trattino","annulla rientro","A grandezza normale","comprimere","Copia il formato","linea orizzontale","lista non ordinata","lista ordinata","Taglia","Seleziona tutto","Includi codice","Apri link","Modifica link","Non seguire","Togli link","Aggiornare","Per modificare","Recensione"," URL","Modifica","Allineamento orizzontale","Filtro","Ordina per data di modifica","Ordina per nome","Ordina per dimensione","Aggiungi cartella","Reset","Salva","Salva con nome...","Ridimensiona","Tagliare","Larghezza","Altezza","Mantenere le proporzioni","Si","No","Rimuovere","Seleziona","Seleziona: %s","Allineamento verticala","Dividere","Fondi","Aggiungi colonna","Aggiungi riga",null,"Cancella","Dividere verticalmente","Diviso orizzontale","Bordo","Il codice Ã¨ simile all'HTML. Mantieni come HTML?","Incolla come HTML?","Mantieni","Inserisci come testo","Inserisci solo il testo","Puoi modificare solo le tue immagini. Scarica questa immagine sul server?","L'immagine Ã¨ stata caricata con successo sul server!","tavolozza","Non ci sono file in questa directory.","ungherese","Inserisci un nuovo nome","anteprima","Scaricare","Incolla dagli appunti","Il tuo browser non supporta l'accesso diretto agli appunti.","Selezione di copia","copia","Border radius"]

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports.default = ["ãªã«ãã¿ã¤ããã¦ãã ãã","Joditã«ã¤ãã¦","Jodit Editor","Free Non-commercial Version","GNU General Public License, version 2 or later","Jodit ã¦ã¼ã¶ã¼ãºã»ã¬ã¤ã","è©³ããä½¿ãæ¹","ã©ã¤ã»ã³ã¹è©³ç´°ã«ã¤ãã¦ã¯Jodit Webãµã¤ããç¢ºèªãã ããï¼","ãã«ãã¼ã¸ã§ã³ãè³¼å¥","Copyright Â© XDSoft.net - Chupurnov Valeriy. All rights reserved.","Anchor","æ°ããã¿ãã§éã","ã¨ãã£ã¿ã¼ã®ãµã¤ãºï¼ãã«/ãã¼ãã«ï¼","æ¸å¼ãã¯ãªã¢","ãã­ã¹ãã®è²","ããç´ã","åã«æ»ã","å¤ªå­","æä½","ç®æ¡æ¸ã","çªå·ä»ããªã¹ã","ä¸­å¤®æã","ä¸¡ç«¯æã","å·¦æã","å³æã","åºåãç·ãæ¿å¥","ç»åãæ¿å¥","ãã¡ã¤ã«ãæ¿å¥","Youtube/Vimeo åç»","ãªã³ã¯ãæ¿å¥","ãã©ã³ããµã¤ãº","ãã©ã³ã","ãã­ã¹ãã®ã¹ã¿ã¤ã«","æå®ãªã","ã¿ã¤ãã«1","ã¿ã¤ãã«2","ã¿ã¤ãã«3","ã¿ã¤ãã«4","å¼ç¨","ã³ã¼ã","æ¿å¥","è¡¨ãæ¿å¥","ã¤ã³ãã³ãæ¸","ã¤ã³ãã³ãå¢","ç¹æ®æå­ãé¸æ","ç¹æ®æå­ãæ¿å¥","æ¸å¼ãè²¼ä»ã","ç·¨éã¢ã¼ãåæ¿ã","ãã¼ã¸ã³","ä¸","å³","ä¸","å·¦","ã¹ã¿ã¤ã«","ã¯ã©ã¹","éç½®","å³å¯ã","ä¸­å¤®å¯ã","å·¦å¯ã","æå®ãªã","ã½ã¼ã¹","ã¿ã¤ãã«","ä»£æ¿ãã­ã¹ã","ãªã³ã¯","æ°ããã¿ãã§éã","ç»å","ãã¡ã¤ã«","é«åº¦ãªè¨­å®","ç»åã®ãã­ããã£ã¼","ã­ã£ã³ã»ã«","ç¢ºå®","File Browser","Error on load list","Error on load folders","Are you sure?","Enter Directory name","Create directory","type name","ããã«ç»åããã­ãã","ããã«ãã¡ã¤ã«ããã­ãã","or ã¯ãªãã¯","ä»£æ¿ãã­ã¹ã","ã¢ããã­ã¼ã","ãã©ã¦ãº","èæ¯","æå­","ä¸","ä¸­å¤®","ä¸","å·¦ã«åãæ¿å¥","å³ã«åãæ¿å¥","ä¸ã«è¡ãæ¿å¥","ä¸ã«è¡ãæ¿å¥","è¡¨ãåé¤","è¡ãåé¤","åãåé¤","ã»ã«ãç©ºã«ãã","æå­æ°: %d","åèªæ°: %d","åãæ¶ãç·","ä¸ç·","ä¸ä»ãæå­","ä¸ä»ãæå­","åãåã","ãã¹ã¦é¸æ","Pause","æ¤ç´¢","ç½®æ","ç½®æ","è²¼ä»ã","é¸æããåå®¹ãè²¼ä»ã","source","bold","italic","brush","link","undo","redo","table","image","eraser","paragraph","fontsize","video","font","about","print","symbol","underline","strikethrough","indent","outdent","fullsize","shrink","copyformat","åå²ç·","ç®æ¡æ¸ã","çªå·ä»ããªã¹ã","åãåã","ãã¹ã¦é¸æ","åãè¾¼ã¿ã³ã¼ã","ãªã³ã¯ãéã","ãªã³ã¯ãç·¨é","No follow","ãªã³ã¯è§£é¤","æ´æ°","éç­","ãµã¤ããç¢ºèª","URL","ç·¨é","æ°´å¹³æ¹åã®éç½®","Filter","Sort by changed","Sort by name","Sort by size","Add folder","ãªã»ãã","ä¿å­","Save as ...","ãªãµã¤ãº","Crop","å¹","é«ã","ç¸¦æ¨ªæ¯ãä¿æ","ã¯ã","ããã","ç§»é¤","é¸æ","é¸æ: %s","åç´æ¹åã®éç½®","åå²","ã»ã«ã®çµå","åãè¿½å ","è¡ãè¿½å ",null,"åé¤","ã»ã«ã®åå²ï¼åç´æ¹åï¼","ã»ã«ã®åå²ï¼æ°´å¹³æ¹åï¼","å¢çç·","HTMLã³ã¼ããä¿æãã¾ããï¼","HTMLã§è²¼ä»ã","HTMLãä¿æ","HTMLããã­ã¹ãã«ãã","ãã­ã¹ãã ã","You can only edit your own images. Download this image on the host?","The image has been successfully uploaded to the host!","ãã¬ãã","There are no files","rename","Enter new name","ãã¬ãã¥ã¼","ãã¦ã³ã­ã¼ã","è²¼ãä»ã","ãä½¿ãã®ãã©ã¦ã¶ã¯ã¯ãªãããã¼ããä½¿ç¨ã§ãã¾ãã","ã³ãã¼","copy","è§ã®ä¸¸ã¿"]

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports.default = ["Begin met typen..","Over Jodit","Jodit Editor","Gratis niet-commerciÃ«le versie","GNU General Public License, versie 2 of hoger","Jodit gebruikershandleiding","bevat gedetailleerde informatie voor gebruik.","Voor informatie over de licentie, ga naar onze website:","Volledige versie kopen","Copyright Â© XDSoft.net - Chupurnov Valeriy. Alle rechten voorbehouden.","Anker","Open in nieuwe tab","Editor in volledig scherm openen","Opmaak verwijderen","Vulkleur of tekstkleur aanpassen","Opnieuw","Ongedaan maken","Vet","Cursief","Geordende list invoegen","Ongeordende lijst invoegen","Centreren","Uitlijnen op volledige breedte","Links uitlijnen","Rechts uitlijnen","Horizontale lijn invoegen","Afbeelding invoegen","Bestand invoegen","Youtube/Vimeo video invoegen","Link toevoegen","Tekstgrootte","Lettertype","Format blok invoegen","Normaal","Koptekst 1","Koptekst 2","Koptekst 3","Koptekst 4","Citaat","Code","Invoegen","Tabel invoegen","Inspringing verkleinen","Inspringing vergroten","Symbool selecteren","Symbool invoegen","Opmaak kopieren","Modus veranderen","Marges","Boven","Rechts","Onder","Links","CSS styles","CSS classes","Uitlijning","Rechts","Gecentreerd","Links","--Leeg--","Src","Titel","Alternatieve tekst","Link","Link in nieuwe tab openen","Afbeelding","Bestand","Geavanceerd","Afbeeldingseigenschappen","Annuleren","OK","Bestandsbrowser","Fout bij het laden van de lijst","Fout bij het laden van de mappenlijst","Weet je het zeker?","Geef de map een naam","Map aanmaken","Type naam","Sleep hier een afbeelding naartoe","Sleep hier een bestand naartoe","of klik","Alternatieve tekst","Uploaden","Bladeren","Achtergrond","Tekst","Boven","Midden","Onder","Kolom invoegen (voor)","Kolom invoegen (na)","Rij invoegen (boven)","Rij invoegen (onder)","Tabel verwijderen","Rij verwijderen","Kolom verwijderen","Cel leegmaken","Tekens: %d","Woorden: %d","Doorstrepen","Onderstrepen","Superscript","Subscript","Selectie knippen","Selecteer alles","Enter","Zoek naar","Vervangen door","Vervangen","Plakken","Kies content om te plakken","Broncode","vet","cursief","kwast","link","ongedaan maken","opnieuw","tabel","afbeelding","gum","paragraaf","lettergrootte","video","lettertype","over","afdrukken","symbool","onderstreept","doorgestreept","inspringen","minder inspringen","volledige grootte","kleiner maken","opmaak kopiÃ«ren","horizontale lijn","lijst","genummerde lijst","knip","alles selecteren","Embed code","link openen","link aanpassen","niet volgen","link verwijderen","Updaten","Om te bewerken","Recensie"," URL","Bewerken","Horizontaal uitlijnen","Filteren","Sorteren op wijzigingsdatum","Sorteren op naam","Sorteren op grootte","Map toevoegen","Herstellen","Opslaan","Opslaan als ...","Grootte aanpassen","Bijknippen","Breedte","Hoogte","Verhouding behouden","Ja","Nee","Verwijderen","Selecteren","Selecteer: %s","Verticaal uitlijnen","Splitsen","Samenvoegen","Kolom toevoegen","Rij toevoegen",null,"Verwijderen","Verticaal splitsen","Horizontaal splitsen","Rand","Deze code lijkt op HTML. Als HTML behouden?","Invoegen als HTML","Origineel behouden","Als tekst invoegen","Als onopgemaakte tekst invoegen","Je kunt alleen je eigen afbeeldingen aanpassen. Deze afbeelding downloaden?","De afbeelding is succesvol geÃ¼ploadet!","Palette","Er zijn geen bestanden in deze map.","Hongaars","Voer een nieuwe naam in","voorvertoning","Download","Plakken van klembord","Uw browser ondersteunt geen directe toegang tot het klembord.","Selectie kopiÃ«ren","kopiÃ«ren","Border radius"]

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports.default = ["Napisz coÅ","O Jodit","Edytor Jodit","Darmowa wersja nie komercyjna","GNU General Public License, wersja 2 lub pÃ³Åºniejsza","Instrukcja Jodit","zawiera szczegÃ³Åowe informacje dotyczÄce uÅ¼ytkowania.","OdwiedÅº naszÄ stronÄ, aby uzyskaÄ wiÄcej informacji na temat licencji:","Zakup peÅnej wersji","Copyright Â© XDSoft.net - Chupurnov Valeriy. Wszystkie prawa zastrzeÅ¼one.","Kotwica","OtwÃ³rz w nowej zakÅadce","OtwÃ³rz edytor w peÅnym rozmiarze","WyczyÅÄ formatowanie","Kolor wypeÅnienia lub ustaw kolor tekstu","PonÃ³w","Cofnij","Pogrubienie","Kursywa","Wstaw listÄ wypunktowanÄ","Wstaw listÄ numerycznÄ","WyÅrodkuj","Wyjustuj","WyrÃ³wnaj do lewej","WyrÃ³wnaj do prawej","Wstaw liniÄ poziomÄ","Wstaw grafikÄ","Wstaw plik","Wstaw film Youtube/vimeo","Wstaw link","Rozmiar tekstu","KrÃ³j czcionki","Wstaw formatowanie","Normalne","NagÅÃ³wek 1","NagÅÃ³wek 2","NagÅÃ³wek 3","NagÅÃ³wek 4","Cytat","Kod","Wstaw","Wstaw tabelÄ","Zmniejsz wciÄcie","ZwiÄksz wciÄcie","Wybierz znak specjalny","Wstaw znak specjalny","Malarz formatÃ³w","ZmieÅ tryb","Marginesy","GÃ³rny","Prawy","Dolny","Levy","Style CSS","Klasy CSS","WyrÃ³wnanie","Prawa","Årodek","Lewa","brak","Å¹rÃ³dÅo","TytuÅ","Tekst alternatywny","Link","OtwÃ³rz w nowej zakÅadce","Grafika","Plik","Zaawansowane","WÅaÅciwoÅci grafiki","Anuluj","OK","PrzeglÄdarka plikÃ³w","BÅÄd Åadowania listy plikÃ³w","BÅÄd Åadowania folderÃ³w","Czy jesteÅ pewien?","WprowadÅº nazwÄ folderu","UtwÃ³rz folder","wprowadÅº nazwÄ","UpuÅÄ plik graficzny","UpuÅÄ plik","lub kliknij tu","Tekst alternatywny","Wczytaj","PrzeglÄdaj","TÅo","TreÅÄ","GÃ³ra","Årodek","DÃ³Å","Wstaw kolumnÄ przed","Wstaw kolumnÄ po","Wstaw wiersz przed","Wstaw wiersz po","UsuÅ tabelÄ","UsuÅ wiersz","UsuÅ kolumnÄ","WyczyÅÄ komÃ³rkÄ","Znaki: %d","SÅowa: %d","PrzekreÅlenie","PodkreÅlenie","indeks gÃ³rny","index dolny","Wytnij zaznaczenie","Wybierz wszystko","Przerwa","Szukaj","ZamieÅ na","ZamieÅ","Wklej","Wybierz zawartoÅÄ do wklejenia","HTML","pogrubienie","kursywa","pÄdzel","link","cofnij","ponÃ³w","tabela","grafika","wyczyÅÄ","akapit","rozmiar czcionki","wideo","czcionka","O programie","drukuj","symbol","podkreÅlenie","przekreÅlenie","wciÄcie","wyciÄcie","peÅen rozmiar","przytnij","format kopii","linia pozioma","lista","lista numerowana","wytnij","zaznacz wszystko","Wstaw kod","otwÃ³rz link","edytuj link","Atrybut no-follow","UsuÅ link","Aktualizuj","edytuj","szukaj","URL","Edytuj","WyrÃ³wnywanie w poziomie","Filtruj","Sortuj wg zmiany","Sortuj wg nazwy","Sortuj wg rozmiaru","Dodaj folder","wyczyÅÄ","zapisz","zapisz jako","ZmieÅ rozmiar","Przytnij","SzerokoÅÄ","WysokoÅÄ","Zachowaj proporcje","Tak","Nie","UsuÅ","Wybierz","Wybierz: %s","WyrÃ³wnywanie w pionie","Podziel","Scal","Dodaj kolumnÄ","Dodaj wiersz",null,"UsuÅ","Podziel w pionie","Podziel w poziomie","Obramowanie","TwÃ³j kod wyglÄda jak HTML. ZachowaÄ HTML?","WkleiÄ jako HTML?","Oryginalny tekst","Wstaw jako tekst","Wstaw tylko treÅÄ","MoÅ¼esz edytowaÄ tylko swoje grafiki. Czy chcesz pobraÄ tÄ grafikÄ?","Grafika zostaÅa pomyÅlnienie dodana na serwer","Paleta","Brak plikÃ³w.","zmieÅ nazwÄ","WprowadÅº nowÄ nazwÄ","podglÄd","pobierz","Wklej ze schowka","Twoja przeglÄdarka nie obsÅuguje schowka","Kopiuj zaznaczenie","kopiuj","ZaokrÄglenie krawÄdzi"]

/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports.default = ["Escreva algo...","Sobre o Jodit","Editor Jodit","VersÃ£o Gratuita nÃ£o-comercial","LicenÃ§a PÃºblica GNU General, VersÃ£o 2 ou posterior","Guia de usuÃ¡rio Jodit","contÃ©m ajuda detalhada para o uso.","Para informaÃ§Ã£o sobre a licenÃ§a, por favor visite nosso site:","Compre a versÃ£o completa","Copyright Â© XDSoft.net - Chupurnov Valeriy. Todos os direitos reservados.","Link","Abrir em nova aba","Abrir editor em tela cheia","Limpar formataÃ§Ã£o","Cor de preenchimento ou cor do texto","Refazer","Desfazer","Negrito","ItÃ¡lico","Inserir lista nÃ£o ordenada","Inserir lista ordenada","Centralizar","Justificar","Alinhar Ã  Esquerda","Alinhar Ã  Direita","Inserir linha horizontal","Inserir imagem","Inserir arquivo","Inserir vÃ­deo do Youtube/vimeo","Inserir link","Tamanho da letra","Fonte","Inserir bloco","Normal","CabeÃ§alho 1","CabeÃ§alho 2","CabeÃ§alho 3","CabeÃ§alho 4","CitaÃ§Ã£o","CÃ³digo","Inserir","Inserir tabela","Diminuir recuo","Aumentar recuo","Selecionar caractere especial","Inserir caractere especial","Copiar formato","Mudar modo","Margens","cima","direta","baixo","esquerda","Estilos CSS","Classes CSS","Alinhamento","Direita","Centro","Esquerda","--NÃ£o Estabelecido--","Fonte","TÃ­tulo","Texto Alternativo","Link","Abrir link em nova aba","Imagem","Arquivo","AvanÃ§ado","Propriedades da imagem","Cancelar","Ok","Procurar arquivo","Erro ao carregar a lista","Erro ao carregar as pastas","VocÃª tem certeza?","Escreva o nome da pasta","Criar pasta","Escreva seu nome","Soltar imagem","Soltar arquivo","ou clique","Texto alternativo","Upload","Explorar","Fundo","Texto","Cima","Meio","Baixo","Inserir coluna antes","Inserir coluna depois","Inserir linha acima","Inserir linha abaixo","Excluir tabela","Excluir linha","Excluir coluna","Limpar cÃ©lula","Caracteres: %d","Palavras: %d","Tachado","Sublinhar","sobrescrito","subscrito","Cortar seleÃ§Ã£o","Selecionar tudo","Pausa","Procurar por","Substituir com","Substituir","Colar","Escolher conteÃºdo para colar","HTML","negrito","itÃ¡lico","pincel","link","desfazer","refazer","tabela","imagem","apagar","parÃ¡grafo","tamanho da letra","vÃ­deo","fonte","Sobre de","Imprimir","SÃ­mbolo","sublinhar","tachado","recuar","diminuir recuo","Tamanho completo","diminuir","Copiar formato","linha horizontal","lista nÃ£o ordenada","lista ordenada","Cortar","Selecionar tudo","Incluir cÃ³digo","Abrir link","Editar link","NÃ£o siga","Remover link","Atualizar","Editar","Visualizar","URL","Editar","Alinhamento horizontal","filtrar","Ordenar por modificaÃ§Ã£o","Ordenar por nome","Ordenar por tamanho","Adicionar pasta","Resetar","Salvar","Salvar como...","Redimensionar","Recortar","Largura","Altura","Manter a proporÃ§Ã£o","Sim","NÃ£o","Remover","Selecionar","Selecionar: %s","Alinhamento vertical","Dividir","Mesclar","Adicionar coluna","Adicionar linha",null,"Excluir","Dividir vertical","Dividir horizontal","Borda","Seu cÃ³digo Ã© similar ao HTML. Manter como HTML?","Colar como HTML?","Manter","Inserir como Texto","Inserir somente o Texto","VocÃª sÃ³ pode editar suas prÃ³prias imagens. Baixar essa imagem pro servidor?","A imagem foi enviada com sucesso para o servidor!","Palette","NÃ£o hÃ¡ arquivos nesse diretÃ³rio.","HÃºngara","Digite um novo nome","preview","Baixar","Colar da Ã¡rea de transferÃªncia","O seu navegador nÃ£o oferece suporte a acesso direto para a Ã¡rea de transferÃªncia.","SelecÃ§Ã£o de cÃ³pia","cÃ³pia","Border radius"]

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports.default = ["ÐÐ°Ð¿Ð¸ÑÐ¸ÑÐµ ÑÑÐ¾-Ð»Ð¸Ð±Ð¾","Ð Jodit","Ð ÐµÐ´Ð°ÐºÑÐ¾Ñ Jodit","ÐÐµÑÑÐ¸Ñ Ð´Ð»Ñ Ð½Ðµ ÐºÐ¾Ð¼Ð¼ÐµÑÑÐµÑÐºÐ¾Ð³Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ","Ð¡ÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð°Ñ Ð¾Ð±ÑÐµÑÑÐ²ÐµÐ½Ð½Ð°Ñ Ð»Ð¸ÑÐµÐ½Ð·Ð¸Ñ GNU (GPL), Ð²ÐµÑÑÐ¸Ñ 2 Ð¸Ð»Ð¸ Ð²ÑÑÐµ","Jodit Ð ÑÐºÐ¾Ð²Ð¾Ð´ÑÑÐ²Ð¾ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ","ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ñ Ð´ÐµÑÐ°Ð»ÑÐ½ÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¿Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ","ÐÐ»Ñ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐ²ÐµÐ´ÐµÐ½Ð¸Ð¹ Ð¾ Ð»Ð¸ÑÐµÐ½Ð·Ð¸Ð¸ , Ð¿Ð¾Ð¶Ð°Ð»ÑÐ¹ÑÑÐ°, Ð¿ÐµÑÐµÐ¹Ð´Ð¸ÑÐµ Ð½Ð° Ð½Ð°Ñ ÑÐ°Ð¹Ñ:","ÐÑÐ¿Ð¸ÑÑ Ð¿Ð¾Ð»Ð½ÑÑ Ð²ÐµÑÑÐ¸Ñ","ÐÐ²ÑÐ¾ÑÑÐºÐ¸Ðµ Ð¿ÑÐ°Ð²Ð° Â© XDSoft.net - Ð§ÑÐ¿ÑÑÐ½Ð¾Ð² ÐÐ°Ð»ÐµÑÐ¸Ð¹. ÐÑÐµ Ð¿ÑÐ°Ð²Ð° Ð·Ð°ÑÐ¸ÑÐµÐ½Ñ.","ÐÐ½ÐºÐ¾Ñ","ÐÑÐºÑÑÐ²Ð°ÑÑ ÑÑÑÐ»ÐºÑ Ð² Ð½Ð¾Ð²Ð¾Ð¹ Ð²ÐºÐ»Ð°Ð´ÐºÐµ","ÐÑÐºÑÑÑÑ ÑÐµÐ´Ð°ÐºÑÐ¾Ñ Ð² Ð¿Ð¾Ð»Ð½Ð¾Ð¼ ÑÐ°Ð·Ð¼ÐµÑÐµ","ÐÑÐ¸ÑÑÐ¸ÑÑ ÑÐ¾ÑÐ¼Ð°ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ","Ð¦Ð²ÐµÑ Ð·Ð°Ð»Ð¸Ð²ÐºÐ¸ Ð¸Ð»Ð¸ ÑÐ²ÐµÑ ÑÐµÐºÑÑÐ°","ÐÐ¾Ð²ÑÐ¾Ñ","ÐÑÐ¼ÐµÐ½Ð°","ÐÐ¸ÑÐ½ÑÐ¹","ÐÐ°ÐºÐ»Ð¾Ð½Ð½ÑÐ¹","ÐÑÑÐ°Ð²ÐºÐ° Ð¼Ð°ÑÐºÐ¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°","ÐÑÑÐ°Ð²Ð¸ÑÑ Ð½ÑÐ¼ÐµÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ ÑÐ¿Ð¸ÑÐ¾Ðº","ÐÑÑÐ¾Ð²Ð½ÑÑÑ Ð¿Ð¾ ÑÐµÐ½ÑÑÑ","ÐÑÑÐ¾Ð²Ð½ÑÑÑ Ð¿Ð¾ ÑÐ¸ÑÐ¸Ð½Ðµ","ÐÑÑÐ¾Ð²Ð½ÑÑÑ Ð¿Ð¾ Ð»ÐµÐ²Ð¾Ð¼Ñ ÐºÑÐ°Ñ","ÐÑÑÐ¾Ð²Ð½ÑÑÑ Ð¿Ð¾ Ð¿ÑÐ°Ð²Ð¾Ð¼Ñ ÐºÑÐ°Ñ","ÐÑÑÐ°Ð²Ð¸ÑÑ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»ÑÐ½ÑÑ Ð»Ð¸Ð½Ð¸Ñ","ÐÑÑÐ°Ð²Ð¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÐ°Ð¹Ð»","ÐÑÑÐ°Ð²ÑÑÐµ Ð²Ð¸Ð´ÐµÐ¾","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÑÑÐ»ÐºÑ","Ð Ð°Ð·Ð¼ÐµÑ ÑÑÐ¸ÑÑÐ°","Ð¨ÑÐ¸ÑÑ","ÐÑÑÐ°Ð²Ð¸ÑÑ Ð±Ð»Ð¾ÑÐ½ÑÐ¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ","ÐÐ¾ÑÐ¼Ð°Ð»ÑÐ½ÑÐ¹ ÑÐµÐºÑÑ","ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº 1","ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº 2","ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº 3","ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº 4","Ð¦Ð¸ÑÐ°ÑÐ°","ÐÐ¾Ð´","ÐÑÑÐ°Ð²Ð¸ÑÑ","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÐ°Ð±Ð»Ð¸ÑÑ","Ð£Ð¼ÐµÐ½ÑÑÐ¸ÑÑ Ð¾ÑÑÑÑÐ¿","Ð£Ð²ÐµÐ»Ð¸ÑÐ¸ÑÑ Ð¾ÑÑÑÑÐ¿","ÐÑÐ±ÐµÑÐ¸ÑÐµ ÑÐ¿ÐµÑÐ¸Ð°Ð»ÑÐ½ÑÐ¹ ÑÐ¸Ð¼Ð²Ð¾Ð»","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÐ¿ÐµÑÐ¸Ð°Ð»ÑÐ½ÑÐ¹ ÑÐ¸Ð¼Ð²Ð¾Ð»","Ð¤Ð¾ÑÐ¼Ð°Ñ ÐºÑÐ°ÑÐºÐ¸","ÐÑÑÐ¾ÑÐ½Ð¸Ðº","ÐÑÑÑÑÐ¿Ñ","ÑÐ²ÐµÑÑÑ","ÑÐ¿ÑÐ°Ð²Ð°","ÑÐ½Ð¸Ð·Ñ","ÑÐ»ÐµÐ²Ð°","Ð¡ÑÐ¸Ð»Ð¸","ÐÐ»Ð°ÑÑÑ","ÐÑÑÐ°Ð²Ð½Ð¸Ð²Ð°Ð½Ð¸Ðµ","ÐÐ¾ Ð¿ÑÐ°Ð²Ð¾Ð¼Ñ ÐºÑÐ°Ñ","ÐÐ¾ ÑÐµÐ½ÑÑÑ","ÐÐ¾ Ð»ÐµÐ²Ð¾Ð¼Ñ ÐºÑÐ°Ñ","--Ð½Ðµ ÑÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÑÑ--","src","ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº","ÐÐ»ÑÑÐµÑÐ½Ð°ÑÐ¸Ð²Ð½ÑÐ¹ ÑÐµÐºÑÑ (alt)","Ð¡ÑÑÐ»ÐºÐ°","ÐÑÐºÑÑÐ²Ð°ÑÑ ÑÑÑÐ»ÐºÑ Ð² Ð½Ð¾Ð²Ð¾Ð¼ Ð¾ÐºÐ½Ðµ",null,"Ð¤Ð°Ð¹Ð»","Ð Ð°ÑÑÐ¸ÑÐµÐ½Ð½ÑÐµ","Ð¡Ð²Ð¾Ð¹ÑÑÐ²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ","ÐÑÐ¼ÐµÐ½Ð°","ÐÐº","ÐÑÐ°ÑÐ·ÐµÑ ÑÐ°Ð¹Ð»Ð¾Ð²","ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð·Ð°Ð³ÑÑÐ·ÐºÐµ ÑÐ¿Ð¸ÑÐºÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¹","ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð·Ð°Ð³ÑÑÐ·ÐºÐµ ÑÐ¿Ð¸ÑÐºÐ° Ð´Ð¸ÑÐµÐºÑÐ¾ÑÐ¸Ð¹","ÐÑ ÑÐ²ÐµÑÐµÐ½Ñ?","ÐÐ²ÐµÐ´Ð¸ÑÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð¸ÑÐµÐºÑÐ¾ÑÐ¸Ð¸","Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð´Ð¸ÑÐµÐºÑÐ¾ÑÐ¸Ñ","Ð²Ð²ÐµÐ´Ð¸ÑÐµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ","ÐÐµÑÐµÑÐ°ÑÐ¸ÑÐµ ÑÑÐ´Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ","ÐÐµÑÐµÑÐ°ÑÐ¸ÑÐµ ÑÑÐ´Ð° ÑÐ°Ð¹Ð»","Ð¸Ð»Ð¸ Ð½Ð°Ð¶Ð¼Ð¸ÑÐµ","ÐÐ»ÑÑÐµÑÐ½Ð°ÑÐ¸Ð²Ð½ÑÐ¹ ÑÐµÐºÑÑ","ÐÐ°Ð³ÑÑÐ·ÐºÐ°","Ð¡ÐµÑÐ²ÐµÑ","Ð¤Ð¾Ð½","Ð¢ÐµÐºÑÑ"," Ð Ð²ÐµÑÑÑ","ÐÐ¾ ÑÐµÑÐµÐ´Ð¸Ð½Ðµ","Ð Ð½Ð¸Ð·Ñ","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÑÐ¾Ð»Ð±ÐµÑ Ð´Ð¾","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÑÐ¾Ð»Ð±ÐµÑ Ð¿Ð¾ÑÐ»Ðµ","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÑÐ´ Ð²ÑÑÐµ","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÑÐ´ Ð½Ð¸Ð¶Ðµ","Ð£Ð´Ð°Ð»Ð¸ÑÑ ÑÐ°Ð±Ð»Ð¸ÑÑ","Ð£Ð´Ð°Ð»ÑÑÑ ÑÑÐ´","Ð£Ð´Ð°Ð»Ð¸ÑÑ ÑÑÐ¾Ð»Ð±ÐµÑ","ÐÑÐ¸ÑÑÐ¸ÑÑ ÑÑÐµÐ¹ÐºÑ","Ð¡Ð¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: %d","Ð¡Ð»Ð¾Ð²: %d","ÐÐµÑÐµÑÐµÑÐºÐ½ÑÑÑ","ÐÐ¾Ð´ÑÐµÑÐºÐ¸Ð²Ð°Ð½Ð¸Ðµ","Ð²ÐµÑÑÐ½Ð¸Ð¹ Ð¸Ð½Ð´ÐµÐºÑ","Ð¸Ð½Ð´ÐµÐºÑ","ÐÑÑÐµÐ·Ð°ÑÑ","ÐÑÐ´ÐµÐ»Ð¸ÑÑ Ð²ÑÐµ","Ð Ð°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»Ñ","ÐÐ°Ð¹ÑÐ¸","ÐÐ°Ð¼ÐµÐ½Ð¸ÑÑ Ð½Ð°","ÐÐ°Ð¼ÐµÐ½Ð¸ÑÑ","ÐÑÑÐ°Ð²Ð¸ÑÑ","ÐÑÐ±ÑÐ°ÑÑ ÐºÐ¾Ð½ÑÐµÐ½Ñ Ð´Ð»Ñ Ð²ÑÑÐ°Ð²ÐºÐ¸","HTML","Ð¶Ð¸ÑÐ½ÑÐ¹","ÐºÑÑÑÐ¸Ð²","Ð·Ð°Ð»Ð¸Ð²ÐºÐ°","ÑÑÑÐ»ÐºÐ°","Ð¾ÑÐ¼ÐµÐ½Ð¸ÑÑ","Ð¿Ð¾Ð²ÑÐ¾ÑÐ¸ÑÑ","ÑÐ°Ð±Ð»Ð¸ÑÐ°","ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ","Ð¾ÑÐ¸ÑÑÐ¸ÑÑ","Ð¿Ð°ÑÐ°Ð³ÑÐ°Ñ","ÑÐ°Ð·Ð¼ÐµÑ ÑÑÐ¸ÑÑÐ°","Ð²Ð¸Ð´ÐµÐ¾","ÑÑÐ¸ÑÑ","Ð¾ ÑÐµÐ´Ð°ÐºÑÐ¾ÑÐµ","Ð¿ÐµÑÐ°ÑÑ","ÑÐ¸Ð¼Ð²Ð¾Ð»","Ð¿Ð¾Ð´ÑÐµÑÐºÐ½ÑÑÑÐ¹","Ð¿ÐµÑÐµÑÐµÑÐºÐ½ÑÑÑÐ¹","Ð¾ÑÑÑÑÐ¿","Ð²ÑÑÑÑÐ¿","Ð²Ð¾ Ð²ÐµÑÑ ÑÐºÑÐ°Ð½","Ð¾Ð±ÑÑÐ½ÑÐ¹ ÑÐ°Ð·Ð¼ÐµÑ","ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ","Ð»Ð¸Ð½Ð¸Ñ","Ð¡Ð¿Ð¸ÑÐ¾Ðº","ÐÑÐ¼ÐµÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ ÑÐ¿Ð¸ÑÐ¾Ðº","ÐÑÑÐµÐ·Ð°ÑÑ","ÐÑÐ´ÐµÐ»Ð¸ÑÑ Ð²ÑÐµ","ÐÐ¾Ð´","ÐÑÐºÑÑÑÑ ÑÑÑÐ»ÐºÑ","Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÑÑÐ»ÐºÑ","ÐÑÑÐ¸Ð±ÑÑ nofollow","Ð£Ð±ÑÐ°ÑÑ ÑÑÑÐ»ÐºÑ","ÐÐ±Ð½Ð¾Ð²Ð¸ÑÑ","Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ","ÐÑÐ¾ÑÐ¼Ð¾ÑÑ","URL","Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ","ÐÐ¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»ÑÐ½Ð¾Ðµ Ð²ÑÑÐ°Ð²Ð½Ð¸Ð²Ð°Ð½Ð¸Ðµ","Ð¤Ð¸Ð»ÑÑÑ","ÐÐ¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ","ÐÐ¾ Ð¸Ð¼ÐµÐ½Ð¸","ÐÐ¾ ÑÐ°Ð·Ð¼ÐµÑÑ","ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð¿Ð°Ð¿ÐºÑ","ÐÐ¾ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ","Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ","Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÐºÐ°Ðº","ÐÐ·Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ°Ð·Ð¼ÐµÑ","ÐÐ±ÑÐµÐ·Ð°ÑÑ ÑÐ°Ð·Ð¼ÐµÑ","Ð¨Ð¸ÑÐ¸Ð½Ð°","ÐÑÑÐ¾ÑÐ°","Ð¡Ð¾ÑÑÐ°Ð½ÑÑÑ Ð¿ÑÐ¾Ð¿Ð¾ÑÑÐ¸Ð¸","ÐÐ°","ÐÐµÑ","Ð£Ð´Ð°Ð»Ð¸ÑÑ","ÐÑÐ´ÐµÐ»Ð¸ÑÑ","ÐÑÐ´ÐµÐ»Ð¸ÑÑ: %s","ÐÐµÑÑÐ¸ÐºÐ°Ð»ÑÐ½Ð¾Ðµ Ð²ÑÑÐ°Ð²Ð½Ð¸Ð²Ð°Ð½Ð¸Ðµ","Ð Ð°Ð·Ð´ÐµÐ»Ð¸ÑÑ","ÐÐ±ÑÐµÐ´Ð¸Ð½Ð¸ÑÑ Ð² Ð¾Ð´Ð½Ñ","ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÑÐ¾Ð»Ð±ÐµÑ","ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÑÑÐ¾ÐºÑ","ÐÐ¸ÑÐµÐ½Ð·Ð¸Ñ: %s","Ð£Ð´Ð°Ð»Ð¸ÑÑ","Ð Ð°Ð·Ð´ÐµÐ»Ð¸ÑÑ Ð¿Ð¾ Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ð¸","Ð Ð°Ð·Ð´ÐµÐ»Ð¸ÑÑ Ð¿Ð¾ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ð¸","Ð Ð°Ð¼ÐºÐ°","ÐÐ°Ñ ÑÐµÐºÑÑ, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð²Ñ Ð¿ÑÑÐ°ÐµÑÐµÑÑ Ð²ÑÑÐ°Ð²Ð¸ÑÑ Ð¿Ð¾ÑÐ¾Ð¶ Ð½Ð° HTML. ÐÑÑÐ°Ð²Ð¸ÑÑ ÐµÐ³Ð¾ ÐºÐ°Ðº HTML?","ÐÑÑÐ°Ð²Ð¸ÑÑ ÐºÐ°Ðº HTML?","Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¾ÑÐ¸Ð³Ð¸Ð½Ð°Ð»","ÐÑÑÐ°Ð²Ð¸ÑÑ ÐºÐ°Ðº ÑÐµÐºÑÑ","ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐµÐºÑÑ","ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ ÑÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ²Ð¾Ð¸ ÑÐ¾Ð±ÑÑÐ²ÐµÐ½Ð½ÑÐµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ. ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ ÑÑÐ¾ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð½Ð° Ð²Ð°Ñ ÑÐµÑÐ²ÐµÑ?","ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð¾ Ð½Ð° ÑÐµÑÐ²ÐµÑ!","Ð¿Ð°Ð»Ð¸ÑÑÐ°","Ð Ð´Ð°Ð½Ð½Ð¾Ð¼ ÐºÐ°ÑÐ°Ð»Ð¾Ð³Ðµ Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð¾Ð²","ÐÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°ÑÑ","ÐÐ²ÐµÐ´Ð¸ÑÐµ Ð½Ð¾Ð²Ð¾Ðµ Ð¸Ð¼Ñ","ÐÑÐµÐ´Ð¿ÑÐ¾ÑÐ¼Ð¾ÑÑ","Ð¡ÐºÐ°ÑÐ°ÑÑ","ÐÑÑÐ°Ð²Ð¸ÑÑ Ð¸Ð· Ð±ÑÑÐµÑÐ° Ð¾Ð±Ð¼ÐµÐ½Ð°","ÐÐ°Ñ Ð±ÑÐ°ÑÐ·ÐµÑ Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ Ð¿ÑÑÐ¼Ð¾Ð¹ Ð´Ð¾ÑÑÑÐ¿ Ðº Ð±ÑÑÐµÑÑ Ð¾Ð±Ð¼ÐµÐ½Ð°.","Ð¡ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ðµ","ÐºÐ¾Ð¿Ð¸Ñ","Ð Ð°Ð´Ð¸ÑÑ Ð³ÑÐ°Ð½Ð¸ÑÑ"]

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports.default = ["Bir Åey yazÄ±n.","Jodit HakkÄ±nda","Jodit Editor","Ãcretsiz, ticari olmayan versiyon","GNU General Public License, Versiyon 2 ve sonrasÄ± iÃ§in","Jodit KullanÄ±m KÄ±lavuzu","kullanÄ±m iÃ§in detaylÄ± bilgiler iÃ§erir","Lisans hakkÄ±nda bilgi iÃ§in lÃ¼tfen web sitemize gidin:","Tam versiyon satÄ±n al","Copyright Â© XDSoft.net - Chupurnov Valeriy. TÃ¼m HaklarÄ± SaklÄ±dÄ±r","BaÄlantÄ±","Yeni sekmede aÃ§","Tam ekran editÃ¶r","Stili temizle","Dolgu ve yazÄ± rengi seÃ§","Ä°leri Al","Geri Al","KalÄ±n","Ä°talik","SÄ±rasÄ±z Liste Ekle","SÄ±ralÄ± Liste Ekle","Ortala","Kenarlara Yasla","Sola Yasla","SaÄa Yasla","Yatay Ãizgi Ekle","Resim Ekle","Dosya Ekle","Youtube/vimeo Videosu Ekle","BaÄlantÄ± Ekle","Font Boyutu","Font Ailesi","Blok Ekle","Normal","BaÅlÄ±k 1","BaÅlÄ±k 2","BaÅlÄ±k 3","BaÅlÄ±k 4","AlÄ±ntÄ±","Code","Ekle","Tablo Ekle","Girintiyi Azalt","Girintiyi ArttÄ±r","Ãzel Karakter SeÃ§","Ãzel Karakter Ekle","Resim BiÃ§imi","Mod DeÄiÅtir","MEsafeler","Ãst","SaÄ","Alt","Sol","CSS Stilleri","CSS SÄ±nÄ±flarÄ±","Hizalama","SaÄ","OrtalÄ±","Sol","Belirlenmedi","Kaynak","BaÅlÄ±k","Alternatif YazÄ±","Link","BaÄlantÄ±yÄ± yeni sekmede aÃ§","Resim","Dosya","GeliÅmiÅ","Resim Ã¶zellikleri","Ä°ptal","Tamam","Dosya Gezgini","Liste yÃ¼klenirken hata oluÅtu","KlasÃ¶rler yÃ¼klenirken hata oluÅtur","Emin misiniz?","Dizin yolu giriniz","Dizin oluÅtur","Typname","Resim bÄ±rak","Dosya bÄ±rak","veya tÄ±kla","Alternatif yazÄ±","YÃ¼kle","Ekle","Arka plan","YazÄ±","Ãst","Orta","AÅaÄÄ±","Ãncesine kolon ekle","SonrasÄ±na kolon ekle","ÃstÃ¼ne satÄ±r ekle","AltÄ±na satÄ±r ekle","Tabloyu sil","SatÄ±r sil","Kolon sil","HÃ¼creyi boÅalt","Harfler: %d","Kelimeler: %d","Durchschlagen","Alt Ã§izgi","Ãst yazÄ±","Alt yazÄ±","SeÃ§ilimi kes","TÃ¼mÃ¼nÃ¼ seÃ§","Durdur","Ara","Åununla deÄiÅtir","DeÄiÅtir","YapÄ±ÅtÄ±r","YapÄ±ÅtÄ±rÄ±lacak iÃ§erik seÃ§","Kaynak","KalÄ±n","italik","FÄ±rÃ§a","BaÄlantÄ±","Geri al","Ä°leri al","Tablo","Resim","Silgi","Paragraf","Font boyutu","Video","Font","HakkÄ±nda","YazdÄ±r","Sembol","Alt Ã§izgi","ÃstÃ¼ Ã§izili","Girinti","ÃÄ±kÄ±ntÄ±","Tam ekran","KÃ¼Ã§Ã¼lt","Kopyalama BiÃ§imi","AyraÃ§","SÄ±rasÄ±z liste","SÄ±ralÄ± liste","Kes","TÃ¼mÃ¼nÃ¼ seÃ§","Kod ekle","BaÄlantÄ±yÄ± aÃ§","BaÄlantÄ±yÄ± dÃ¼zenle","Nofollow Ã¶zelliÄi","BaÄlantÄ±yÄ± kaldÄ±r","GÃ¼ncelle","DÃ¼zenlemek iÃ§in","Yorumu","URL","DÃ¼zenle","Yatay hizalama","Filtre","DeÄiÅime gÃ¶re sÄ±rala","Ä°sme gÃ¶re sÄ±rala","Boyuta gÃ¶re sÄ±rala","KlasÃ¶r ekle","SÄ±fÄ±rla","Kaydet","FarklÄ± kaydet","BoyutlandÄ±r","KÄ±rp","GeniÅlik","YÃ¼kseklik","En boy oranÄ±nÄ± koru","Evet","HayÄ±r","Sil","SeÃ§","SeÃ§: %s","Dikey hizalama","AyÄ±r","BirleÅtir","Kolon ekle","SatÄ±r ekle",null,"Sil","Dikey ayÄ±r","Yatay ayÄ±r","KenarlÄ±k","Kodunuz HTML koduna benziyor. HTML olarak devam etmek ister misiniz?","HTML olarak yapÄ±ÅtÄ±r","Sakla","YazÄ± olarak ekle","Nur Text einfÃ¼gen","Sadece kendi resimlerinizi dÃ¼zenleyebilirsiniz. Bu gÃ¶rseli kendi hostunuza indirmek ister misiniz?","GÃ¶rsel baÅarÄ±yla hostunuza yÃ¼klendi","Palette","Bu dizinde dosya yok.","Macarca","Yeni isim girin","Ãn izleme","Ä°ndir","Panodan yapÄ±ÅtÄ±r ","TarayÄ±cÄ±nÄ±z pano doÄrudan eriÅim desteklemiyor.","Kopya seÃ§imi","kopya","SÄ±nÄ±r yarÄ±Ã§apÄ±"]

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports.default = ["è¾å¥ä¸äºåå®¹","å³äºJodit","Jodit Editor","Free Non-commercial Version","GNU General Public License, version 2 or later","å¼åèæå","ä½¿ç¨å¸®å©","æå³è®¸å¯è¯çä¿¡æ¯ï¼è¯·è®¿é®æä»¬çç½ç«ï¼","è´­ä¹°å®æ´çæ¬","Copyright Â© XDSoft.net - Chupurnov Valeriy. All rights reserved.","Anchor","å¨æ°çªå£æå¼","å¨å±ç¼è¾","æ¸é¤æ ·å¼","é¢è²","éå","æ¤é","ç²ä½","æä½","ç¬¦å·åè¡¨","ç¼å·","å±ä¸­","å¯¹é½ææ¬","å·¦å¯¹é½","å³å¯¹é½","åå²çº¿","å¾ç","æä»¶","youtube/vimeo è§é¢","é¾æ¥","å­å·","å­ä½","æ ¼å¼å","ææ¬","æ é¢1","æ é¢2","æ é¢3","æ é¢4","å¼ç¨","ä»£ç ","æå¥","è¡¨æ ¼","åå°ç¼©è¿","å¢å ç¼©è¿","éæ©ç¹æ®ç¬¦å·","ç¹æ®ç¬¦å·","æ ¼å¼å¤å¶","æ¹åæ¨¡å¼","å¤è¾¹è·ï¼Marginsï¼","top","right","bottom","left","æ ·å¼","Classes","å¯¹é½æ¹å¼","å±å³","å±ä¸­","å±å·¦","æ ","Src","Title","Alternative","Link","å¨æ°çªå£æå¼é¾æ¥","å¾ç","file","é«çº§","å¾çå±æ§","åæ¶","ç¡®å®","æä»¶ç®¡ç","å è½½listéè¯¯","å è½½folderséè¯¯","ä½ ç¡®å®åï¼","è¾å¥è·¯å¾","åå»ºè·¯å¾","type name","æå¨å¾çå°æ­¤","æå¨æä»¶å°æ­¤","æç¹å»","Alternative text","ä¸ä¼ ","æµè§","èæ¯è²","æå­","é¡¶é¨","ä¸­é´","åºé¨","å¨ä¹åæå¥å","å¨ä¹åæå¥å","å¨ä¹åæå¥è¡","å¨ä¹åæå¥è¡","å é¤è¡¨æ ¼","å é¤è¡","å é¤å","æ¸é¤åå®¹","å­ç¬¦æ°: %d","åè¯æ°: %d","å é¤çº¿","ä¸åçº¿","ä¸æ ","ä¸æ ","åªå","å¨é","Pause","æ¥æ¾","æ¿æ¢ä¸º","æ¿æ¢","ç²è´´","éæ©åå®¹å¹¶ç²è´´","æºç ","ç²ä½","æä½","é¢è²","é¾æ¥","æ¤é","éå","è¡¨æ ¼","å¾ç","æ©¡ç®æ¦","æ®µè½","å­å·","è§é¢","å­ä½","å³äº","æå°","ç¬¦å·","ä¸åçº¿","ä¸åºç°","å¢å ç¼©è¿","åå°ç¼©è¿","å¨å±","æ¶ç¼©","å¤å¶æ ¼å¼","åå²çº¿","æ åºåè¡¨","é¡ºåºåè¡¨","åªå","å¨é","åµå¥ä»£ç ","æå¼é¾æ¥","ç¼è¾é¾æ¥","No follow","Unlink","æ´æ°","éç¬","åé¡§","URL",null,"æ°´å¹³å¯¹é½","ç­é","ä¿®æ¹æ¶é´æåº","åç§°æåº","å¤§å°æåº","æ°å»ºæä»¶å¤¹","éç½®","ä¿å­","ä¿å­ä¸º","è°æ´å¤§å°","Crop","å®½","é«","ä¿å­é¿å®½æ¯","æ¯","ä¸","ç§»é¤","éæ©","éæ©: %s","åç´å¯¹é½","æå","åå¹¶","æ·»å å","æ·»å è¡",null,"å é¤","åç´æå","æ°´å¹³æå","è¾¹æ¡","ä½ ç²è´´çææ¬æ¯ä¸æ®µhtmlä»£ç ï¼æ¯å¦ä¿çæºæ ¼å¼","htmlç²è´´","ä¿çæºæ ¼å¼","æhtmlä»£ç è§ä¸ºæ®éææ¬","åªä¿çææ¬","ä½ åªè½ç¼è¾ä½ èªå·±çå¾çãDownload this image on the host?","å¾çä¸ä¼ æå","è°è²æ¿","æ­¤ç®å½ä¸­æ²ææä»¶ã","éå½å","è¾å¥æ°åç§°","é¢è§","ä¸è½½","ç²è´´ä»åªè´´æ¿","ä½ æµè§å¨ä¸æ¯æç´æ¥è®¿é®çåªè´´æ¿ã","å¤å¶çéæ©","å¤å¶","è¾¹çåå¾"]

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports.default = ["è¼¸å¥ä¸äºå§å®¹","éæ¼Jodit","Jodit Editor","Free Non-commercial Version","GNU General Public License, version 2 or later","éç¼èæå","ä½¿ç¨å¹«å©","æéè¨±å¯è­çä¿¡æ¯ï¼è«è¨ªåæåçç¶²ç«ï¼","è³¼è²·å®æ´çæ¬","Copyright Â© XDSoft.net - Chupurnov Valeriy. All rights reserved.","Anchor","å¨æ°çªå£æé","å¨å±ç·¨è¼¯","æ¸é¤æ¨£å¼","é¡è²","éå","æ¤é·","ç²é«","æé«","ç¬¦èåè¡¨","ç·¨è","å±ä¸­","å°é½ææ¬","å·¦å°é½","å³å°é½","åå²ç·","åç","æä»¶","youtube/vimeo å½±ç","éæ¥","å­è","å­é«","æ ¼å¼å¡","ææ¬","æ¨é¡1","æ¨é¡2","æ¨é¡3","æ¨é¡4","å¼ç¨","ä»£ç¢¼","æå¥","è¡¨æ ¼","æ¸å°ç¸®é²","å¢å ç¸®é²","é¸æç¹æ®ç¬¦è","ç¹æ®ç¬¦è","æ ¼å¼è¤è£½","æ¹è®æ¨¡å¼","å¤éè·ï¼Marginsï¼","top","right","bottom","left","æ¨£å¼","Classes","å°é½æ¹å¼","å±å³","å±ä¸­","å±å·¦","ç¡","Src","Title","Alternative","Link","å¨æ°çªå£æééæ¥","åç","file","é«ç´","åçå±¬æ§","åæ¶","ç¢ºå®","æä»¶ç®¡ç","å è¼listé¯èª¤","å è¼foldersé¯èª¤","ä½ ç¢ºå®åï¼","è¼¸å¥è·¯å¾","åµå»ºè·¯å¾","type name","æååçå°æ­¤","æåæä»¶å°æ­¤","æé»æ","Alternative text","ä¸å³","çè¦½","èæ¯è²","æå­","é é¨","ä¸­é","åºé¨","å¨ä¹åæå¥å","å¨ä¹å¾æå¥å","å¨ä¹åæå¥è¡","å¨ä¹å¾æå¥è¡","åªé¤è¡¨æ ¼","åªé¤è¡","åªé¤å","æ¸é¤å§å®¹","å­ç¬¦æ¸: %d","å®è©æ¸: %d","åªé¤ç·","ä¸åç·","ä¸æ¨","ä¸æ¨","åªå","å¨é¸","Pause","æ¥æ¾","æ¿æçº","æ¿æ","é»è²¼","é¸æå§å®¹ä¸¦é»è²¼","æºç¢¼","ç²é«","æé«","é¡è²","éæ¥","æ¤é·","éå","è¡¨æ ¼","åç","æ©¡ç®æ¦","æ®µè½","å­è","å½±ç","å­é«","éæ¼","æå°","ç¬¦è","ä¸åç·","ä¸åºç¾","å¢å ç¸®é²","æ¸å°ç¸®é²","å¨å±","æ¶ç¸®","è¤è£½æ ¼å¼","åå²ç·","ç¡åºåè¡¨","é åºåè¡¨","åªå","å¨é¸","åµå¥ä»£ç¢¼","æééæ¥","ç·¨è¼¯éæ¥","No follow","Unlink","æ´æ°","éç­","åé¡§","URL",null,"æ°´å¹³å°é½","ç¯©é¸","ä¿®æ¹æéæåº","åç¨±æåº","å¤§å°æåº","æ°å»ºæä»¶å¤¾","éç½®","ä¿å­","ä¿å­çº","èª¿æ´å¤§å°","Crop","å¯¬","é«","ä¿å­é·å¯¬æ¯","æ¯","ä¸","ç§»é¤","é¸æ","é¸æ: %s","åç´å°é½","æå","åä½µ","æ·»å å","æ·»å è¡",null,"åªé¤","åç´æå","æ°´å¹³æå","éæ¡","ä½ é»è²¼çææ¬æ¯ä¸æ®µhtmlä»£ç¢¼ï¼æ¯å¦ä¿çæºæ ¼å¼","htmlé»è²¼","ä¿çæºæ ¼å¼","æhtmlä»£ç¢¼è¦çºæ®éææ¬","åªä¿çææ¬","å¦³åªè½ç·¨è¼¯å¦³èªå·±çåçãDownload this image on the host?","åçä¸å³æå","èª¿è²æ¿","æ­¤ç®éä¸­æ²ææä»¶ã","éå½å","è¼¸å¥æ°åç¨±","é è¦½","ä¸è¼","à¸§à¸²à¸à¸à¸²à¸à¸à¸¥à¸´à¸à¸à¸­à¸£à¹à¸","à¸à¸­à¸à¹à¸à¸£à¸²à¸§à¹à¹à¸à¸­à¸£à¹à¹à¸¡à¹à¸ªà¸à¸±à¸à¸ªà¸à¸¸à¸à¹à¸à¸¢à¸à¸£à¸à¹à¸à¹à¸²à¹à¸à¸¢à¸±à¸à¸à¸¥à¸´à¸à¸à¸­à¸£à¹à¸","à¸à¸±à¸à¸¥à¸­à¸à¸ªà¹à¸§à¸à¸à¸µà¹à¹à¸¥à¸·à¸­à¸","à¸à¸±à¸à¸¥à¸­à¸","à¹à¸ªà¹à¸à¸à¸­à¸à¸£à¸±à¸¨à¸¡à¸µ"]

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(98);


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var constants_namespaceObject = {};
__webpack_require__.r(constants_namespaceObject);
__webpack_require__.d(constants_namespaceObject, "INVISIBLE_SPACE", function() { return INVISIBLE_SPACE; });
__webpack_require__.d(constants_namespaceObject, "INVISIBLE_SPACE_REG_EXP", function() { return INVISIBLE_SPACE_REG_EXP; });
__webpack_require__.d(constants_namespaceObject, "INVISIBLE_SPACE_REG_EXP_END", function() { return INVISIBLE_SPACE_REG_EXP_END; });
__webpack_require__.d(constants_namespaceObject, "INVISIBLE_SPACE_REG_EXP_START", function() { return INVISIBLE_SPACE_REG_EXP_START; });
__webpack_require__.d(constants_namespaceObject, "SPACE_REG_EXP", function() { return SPACE_REG_EXP; });
__webpack_require__.d(constants_namespaceObject, "SPACE_REG_EXP_START", function() { return SPACE_REG_EXP_START; });
__webpack_require__.d(constants_namespaceObject, "SPACE_REG_EXP_END", function() { return SPACE_REG_EXP_END; });
__webpack_require__.d(constants_namespaceObject, "IS_BLOCK", function() { return IS_BLOCK; });
__webpack_require__.d(constants_namespaceObject, "IS_INLINE", function() { return IS_INLINE; });
__webpack_require__.d(constants_namespaceObject, "MAY_BE_REMOVED_WITH_KEY", function() { return MAY_BE_REMOVED_WITH_KEY; });
__webpack_require__.d(constants_namespaceObject, "KEY_BACKSPACE", function() { return KEY_BACKSPACE; });
__webpack_require__.d(constants_namespaceObject, "KEY_TAB", function() { return KEY_TAB; });
__webpack_require__.d(constants_namespaceObject, "KEY_ENTER", function() { return KEY_ENTER; });
__webpack_require__.d(constants_namespaceObject, "KEY_ESC", function() { return KEY_ESC; });
__webpack_require__.d(constants_namespaceObject, "KEY_LEFT", function() { return KEY_LEFT; });
__webpack_require__.d(constants_namespaceObject, "KEY_UP", function() { return KEY_UP; });
__webpack_require__.d(constants_namespaceObject, "KEY_RIGHT", function() { return KEY_RIGHT; });
__webpack_require__.d(constants_namespaceObject, "KEY_DOWN", function() { return KEY_DOWN; });
__webpack_require__.d(constants_namespaceObject, "KEY_DELETE", function() { return KEY_DELETE; });
__webpack_require__.d(constants_namespaceObject, "KEY_F", function() { return KEY_F; });
__webpack_require__.d(constants_namespaceObject, "KEY_R", function() { return KEY_R; });
__webpack_require__.d(constants_namespaceObject, "KEY_H", function() { return KEY_H; });
__webpack_require__.d(constants_namespaceObject, "KEY_Y", function() { return KEY_Y; });
__webpack_require__.d(constants_namespaceObject, "KEY_V", function() { return KEY_V; });
__webpack_require__.d(constants_namespaceObject, "KEY_Z", function() { return KEY_Z; });
__webpack_require__.d(constants_namespaceObject, "KEY_F3", function() { return KEY_F3; });
__webpack_require__.d(constants_namespaceObject, "NEARBY", function() { return NEARBY; });
__webpack_require__.d(constants_namespaceObject, "ACCURACY", function() { return ACCURACY; });
__webpack_require__.d(constants_namespaceObject, "COMMAND_KEYS", function() { return COMMAND_KEYS; });
__webpack_require__.d(constants_namespaceObject, "BR", function() { return BR; });
__webpack_require__.d(constants_namespaceObject, "PARAGRAPH", function() { return PARAGRAPH; });
__webpack_require__.d(constants_namespaceObject, "MODE_WYSIWYG", function() { return MODE_WYSIWYG; });
__webpack_require__.d(constants_namespaceObject, "MODE_SOURCE", function() { return MODE_SOURCE; });
__webpack_require__.d(constants_namespaceObject, "MODE_SPLIT", function() { return MODE_SPLIT; });
__webpack_require__.d(constants_namespaceObject, "IS_IE", function() { return IS_IE; });
__webpack_require__.d(constants_namespaceObject, "URL_LIST", function() { return URL_LIST; });
__webpack_require__.d(constants_namespaceObject, "TEXT_PLAIN", function() { return TEXT_PLAIN; });
__webpack_require__.d(constants_namespaceObject, "TEXT_HTML", function() { return TEXT_HTML; });
__webpack_require__.d(constants_namespaceObject, "MARKER_CLASS", function() { return MARKER_CLASS; });
__webpack_require__.d(constants_namespaceObject, "EMULATE_DBLCLICK_TIMEOUT", function() { return EMULATE_DBLCLICK_TIMEOUT; });
__webpack_require__.d(constants_namespaceObject, "JODIT_SELECTED_CELL_MARKER", function() { return JODIT_SELECTED_CELL_MARKER; });
__webpack_require__.d(constants_namespaceObject, "INSERT_AS_HTML", function() { return INSERT_AS_HTML; });
__webpack_require__.d(constants_namespaceObject, "INSERT_CLEAR_HTML", function() { return INSERT_CLEAR_HTML; });
__webpack_require__.d(constants_namespaceObject, "INSERT_AS_TEXT", function() { return INSERT_AS_TEXT; });
__webpack_require__.d(constants_namespaceObject, "INSERT_ONLY_TEXT", function() { return INSERT_ONLY_TEXT; });
__webpack_require__.d(constants_namespaceObject, "IS_MAC", function() { return IS_MAC; });
__webpack_require__.d(constants_namespaceObject, "KEY_ALIASES", function() { return KEY_ALIASES; });
__webpack_require__.d(constants_namespaceObject, "BASE_PATH", function() { return BASE_PATH; });
var helpers_namespaceObject = {};
__webpack_require__.r(helpers_namespaceObject);
__webpack_require__.d(helpers_namespaceObject, "asArray", function() { return asArray; });
__webpack_require__.d(helpers_namespaceObject, "inArray", function() { return inArray; });
__webpack_require__.d(helpers_namespaceObject, "splitArray", function() { return splitArray; });
__webpack_require__.d(helpers_namespaceObject, "debounce", function() { return debounce; });
__webpack_require__.d(helpers_namespaceObject, "setTimeout", function() { return setTimeout_setTimeout; });
__webpack_require__.d(helpers_namespaceObject, "clearTimeout", function() { return setTimeout_clearTimeout; });
__webpack_require__.d(helpers_namespaceObject, "throttle", function() { return throttle; });
__webpack_require__.d(helpers_namespaceObject, "extend", function() { return extend; });
__webpack_require__.d(helpers_namespaceObject, "hasBrowserColorPicker", function() { return hasBrowserColorPicker; });
__webpack_require__.d(helpers_namespaceObject, "isFunction", function() { return isFunction; });
__webpack_require__.d(helpers_namespaceObject, "isHTML", function() { return isHTML; });
__webpack_require__.d(helpers_namespaceObject, "isHTMLFromWord", function() { return isHTMLFromWord; });
__webpack_require__.d(helpers_namespaceObject, "isInitable", function() { return isInitable; });
__webpack_require__.d(helpers_namespaceObject, "isDestructable", function() { return isDestructable; });
__webpack_require__.d(helpers_namespaceObject, "isInt", function() { return isInt; });
__webpack_require__.d(helpers_namespaceObject, "isJoditObject", function() { return isJoditObject; });
__webpack_require__.d(helpers_namespaceObject, "isLicense", function() { return isLicense; });
__webpack_require__.d(helpers_namespaceObject, "isNumeric", function() { return isNumeric; });
__webpack_require__.d(helpers_namespaceObject, "isPlainObject", function() { return isPlainObject; });
__webpack_require__.d(helpers_namespaceObject, "isString", function() { return isString; });
__webpack_require__.d(helpers_namespaceObject, "isURL", function() { return isURL; });
__webpack_require__.d(helpers_namespaceObject, "isValidName", function() { return isValidName; });
__webpack_require__.d(helpers_namespaceObject, "isWindow", function() { return isWindow; });
__webpack_require__.d(helpers_namespaceObject, "isPromise", function() { return isPromise; });
__webpack_require__.d(helpers_namespaceObject, "hexToRgb", function() { return hexToRgb; });
__webpack_require__.d(helpers_namespaceObject, "colorToHex", function() { return colorToHex; });
__webpack_require__.d(helpers_namespaceObject, "applyStyles", function() { return applyStyles; });
__webpack_require__.d(helpers_namespaceObject, "cleanFromWord", function() { return cleanFromWord; });
__webpack_require__.d(helpers_namespaceObject, "clear", function() { return clear_clear; });
__webpack_require__.d(helpers_namespaceObject, "htmlspecialchars", function() { return htmlspecialchars; });
__webpack_require__.d(helpers_namespaceObject, "stripTags", function() { return stripTags; });
__webpack_require__.d(helpers_namespaceObject, "normalizeKeyAliases", function() { return normalizeKeyAliases; });
__webpack_require__.d(helpers_namespaceObject, "normalizeLicense", function() { return normalizeLicense; });
__webpack_require__.d(helpers_namespaceObject, "normalizeNode", function() { return normalizeNode; });
__webpack_require__.d(helpers_namespaceObject, "normalizePath", function() { return normalizePath; });
__webpack_require__.d(helpers_namespaceObject, "normalizeRelativePath", function() { return normalizeRelativePath; });
__webpack_require__.d(helpers_namespaceObject, "normalizeSize", function() { return normalizeSize; });
__webpack_require__.d(helpers_namespaceObject, "normalizeURL", function() { return normalizeURL; });
__webpack_require__.d(helpers_namespaceObject, "normilizeCSSValue", function() { return normilizeCSSValue; });
__webpack_require__.d(helpers_namespaceObject, "normalizeColor", function() { return normalizeColor; });
__webpack_require__.d(helpers_namespaceObject, "getContentWidth", function() { return getContentWidth; });
__webpack_require__.d(helpers_namespaceObject, "innerWidth", function() { return innerWidth_innerWidth; });
__webpack_require__.d(helpers_namespaceObject, "offset", function() { return offset; });
__webpack_require__.d(helpers_namespaceObject, "camelCase", function() { return camelCase; });
__webpack_require__.d(helpers_namespaceObject, "fromCamelCase", function() { return fromCamelCase; });
__webpack_require__.d(helpers_namespaceObject, "trim", function() { return trim; });
__webpack_require__.d(helpers_namespaceObject, "ucfirst", function() { return ucfirst; });
__webpack_require__.d(helpers_namespaceObject, "sprintf", function() { return sprintf; });
__webpack_require__.d(helpers_namespaceObject, "i18n", function() { return i18n_i18n; });
__webpack_require__.d(helpers_namespaceObject, "appendScript", function() { return appendScript; });
__webpack_require__.d(helpers_namespaceObject, "appendScriptAsync", function() { return appendScriptAsync; });
__webpack_require__.d(helpers_namespaceObject, "appendStyleAsync", function() { return appendStyleAsync; });
__webpack_require__.d(helpers_namespaceObject, "loadNext", function() { return loadNext; });
__webpack_require__.d(helpers_namespaceObject, "browser", function() { return browser; });
__webpack_require__.d(helpers_namespaceObject, "convertMediaURLToVideoEmbed", function() { return convertMediaURLToVideoEmbed; });
__webpack_require__.d(helpers_namespaceObject, "css", function() { return css_css; });
__webpack_require__.d(helpers_namespaceObject, "clearCenterAlign", function() { return clearCenterAlign; });
__webpack_require__.d(helpers_namespaceObject, "ctrlKey", function() { return ctrlKey; });
__webpack_require__.d(helpers_namespaceObject, "dataBind", function() { return dataBind; });
__webpack_require__.d(helpers_namespaceObject, "defaultLanguage", function() { return defaultLanguage_defaultLanguage; });
__webpack_require__.d(helpers_namespaceObject, "each", function() { return each; });
__webpack_require__.d(helpers_namespaceObject, "completeUrl", function() { return completeUrl; });
__webpack_require__.d(helpers_namespaceObject, "humanSizeToBytes", function() { return humanSizeToBytes; });
__webpack_require__.d(helpers_namespaceObject, "JoditArray", function() { return JoditArray_JoditArray; });
__webpack_require__.d(helpers_namespaceObject, "JoditObject", function() { return JoditObject_JoditObject; });
__webpack_require__.d(helpers_namespaceObject, "parseQuery", function() { return parseQuery; });
__webpack_require__.d(helpers_namespaceObject, "buildQuery", function() { return buildQuery; });
__webpack_require__.d(helpers_namespaceObject, "inView", function() { return inView; });
__webpack_require__.d(helpers_namespaceObject, "scrollIntoView", function() { return scrollIntoView; });
__webpack_require__.d(helpers_namespaceObject, "$$", function() { return $$; });
__webpack_require__.d(helpers_namespaceObject, "getXPathByElement", function() { return getXPathByElement; });
__webpack_require__.d(helpers_namespaceObject, "refs", function() { return refs; });
__webpack_require__.d(helpers_namespaceObject, "hasOwn", function() { return hasOwn; });
__webpack_require__.d(helpers_namespaceObject, "type", function() { return type_type; });
__webpack_require__.d(helpers_namespaceObject, "error", function() { return type_error; });
__webpack_require__.d(helpers_namespaceObject, "val", function() { return val_val; });
var plugins_namespaceObject = {};
__webpack_require__.r(plugins_namespaceObject);
__webpack_require__.d(plugins_namespaceObject, "addNewLine", function() { return addNewLine; });
__webpack_require__.d(plugins_namespaceObject, "autofocus", function() { return autofocus; });
__webpack_require__.d(plugins_namespaceObject, "backspace", function() { return backspace; });
__webpack_require__.d(plugins_namespaceObject, "bold", function() { return bold; });
__webpack_require__.d(plugins_namespaceObject, "cleanHtml", function() { return cleanHtml; });
__webpack_require__.d(plugins_namespaceObject, "clipboard", function() { return cut_clipboard; });
__webpack_require__.d(plugins_namespaceObject, "paste", function() { return paste; });
__webpack_require__.d(plugins_namespaceObject, "pasteStorage", function() { return paste_storage_pasteStorage; });
__webpack_require__.d(plugins_namespaceObject, "color", function() { return color_color; });
__webpack_require__.d(plugins_namespaceObject, "DragAndDrop", function() { return drag_and_drop_DragAndDrop; });
__webpack_require__.d(plugins_namespaceObject, "DragAndDropElement", function() { return drag_and_drop_element_DragAndDropElement; });
__webpack_require__.d(plugins_namespaceObject, "enter", function() { return enter_enter; });
__webpack_require__.d(plugins_namespaceObject, "errorMessages", function() { return errorMessages; });
__webpack_require__.d(plugins_namespaceObject, "font", function() { return font_font; });
__webpack_require__.d(plugins_namespaceObject, "formatBlock", function() { return formatBlock; });
__webpack_require__.d(plugins_namespaceObject, "fullsize", function() { return fullsize; });
__webpack_require__.d(plugins_namespaceObject, "hotkeys", function() { return hotkeys_hotkeys; });
__webpack_require__.d(plugins_namespaceObject, "iframe", function() { return iframe_iframe; });
__webpack_require__.d(plugins_namespaceObject, "imageProcessor", function() { return imageProcessor; });
__webpack_require__.d(plugins_namespaceObject, "imageProperties", function() { return imageProperties; });
__webpack_require__.d(plugins_namespaceObject, "indent", function() { return indent; });
__webpack_require__.d(plugins_namespaceObject, "inlinePopup", function() { return inline_popup_inlinePopup; });
__webpack_require__.d(plugins_namespaceObject, "justify", function() { return justify; });
__webpack_require__.d(plugins_namespaceObject, "limit", function() { return limit; });
__webpack_require__.d(plugins_namespaceObject, "link", function() { return link_link; });
__webpack_require__.d(plugins_namespaceObject, "media", function() { return media; });
__webpack_require__.d(plugins_namespaceObject, "mobile", function() { return mobile; });
__webpack_require__.d(plugins_namespaceObject, "orderedlist", function() { return orderedlist; });
__webpack_require__.d(plugins_namespaceObject, "placeholder", function() { return placeholder_placeholder; });
__webpack_require__.d(plugins_namespaceObject, "redoundo", function() { return redoundo_redoundo; });
__webpack_require__.d(plugins_namespaceObject, "resizer", function() { return resizer; });
__webpack_require__.d(plugins_namespaceObject, "search", function() { return search_search; });
__webpack_require__.d(plugins_namespaceObject, "size", function() { return size_size; });
__webpack_require__.d(plugins_namespaceObject, "source", function() { return source_source; });
__webpack_require__.d(plugins_namespaceObject, "stat", function() { return stat_stat; });
__webpack_require__.d(plugins_namespaceObject, "sticky", function() { return sticky_sticky; });
__webpack_require__.d(plugins_namespaceObject, "symbols", function() { return symbols_symbols; });
__webpack_require__.d(plugins_namespaceObject, "tableKeyboardNavigation", function() { return tableKeyboardNavigation; });
__webpack_require__.d(plugins_namespaceObject, "table", function() { return table_TableProcessor; });
__webpack_require__.d(plugins_namespaceObject, "tooltip", function() { return tooltip_tooltip; });
__webpack_require__.d(plugins_namespaceObject, "xpath", function() { return xpath_xpath; });
var modules_namespaceObject = {};
__webpack_require__.r(modules_namespaceObject);
__webpack_require__.d(modules_namespaceObject, "Ajax", function() { return Ajax_Ajax; });
__webpack_require__.d(modules_namespaceObject, "EventsNative", function() { return eventsNative_EventsNative; });
__webpack_require__.d(modules_namespaceObject, "Component", function() { return Component_Component; });
__webpack_require__.d(modules_namespaceObject, "ContextMenu", function() { return ContextMenu_ContextMenu; });
__webpack_require__.d(modules_namespaceObject, "Alert", function() { return Alert; });
__webpack_require__.d(modules_namespaceObject, "Confirm", function() { return Confirm; });
__webpack_require__.d(modules_namespaceObject, "Promt", function() { return Promt; });
__webpack_require__.d(modules_namespaceObject, "Dialog", function() { return dialog_Dialog; });
__webpack_require__.d(modules_namespaceObject, "Dom", function() { return Dom_Dom; });
__webpack_require__.d(modules_namespaceObject, "Plugin", function() { return Plugin_Plugin; });
__webpack_require__.d(modules_namespaceObject, "Create", function() { return Create_Create; });
__webpack_require__.d(modules_namespaceObject, "FileBrowser", function() { return fileBrowser_FileBrowser; });
__webpack_require__.d(modules_namespaceObject, "Helpers", function() { return helpers_namespaceObject; });
__webpack_require__.d(modules_namespaceObject, "ImageEditor", function() { return ImageEditor_ImageEditor; });
__webpack_require__.d(modules_namespaceObject, "Observer", function() { return observer_Observer; });
__webpack_require__.d(modules_namespaceObject, "ProgressBar", function() { return ProgressBar_ProgressBar; });
__webpack_require__.d(modules_namespaceObject, "Select", function() { return Selection_Select; });
__webpack_require__.d(modules_namespaceObject, "Storage", function() { return storage_Storage; });
__webpack_require__.d(modules_namespaceObject, "Snapshot", function() { return Snapshot_Snapshot; });
__webpack_require__.d(modules_namespaceObject, "Table", function() { return Table_Table; });
__webpack_require__.d(modules_namespaceObject, "ToolbarIcon", function() { return ToolbarIcon; });
__webpack_require__.d(modules_namespaceObject, "JoditToolbarCollection", function() { return joditToolbarCollection_JoditToolbarCollection; });
__webpack_require__.d(modules_namespaceObject, "ToolbarCollection", function() { return collection_ToolbarCollection; });
__webpack_require__.d(modules_namespaceObject, "ToolbarButton", function() { return button_ToolbarButton; });
__webpack_require__.d(modules_namespaceObject, "Stack", function() { return Stack; });
__webpack_require__.d(modules_namespaceObject, "Widget", function() { return Widget_Widget; });
__webpack_require__.d(modules_namespaceObject, "Uploader", function() { return Uploader_Uploader; });
__webpack_require__.d(modules_namespaceObject, "PluginSystem", function() { return PluginSystem_PluginSystem; });
var icons_namespaceObject = {};
__webpack_require__.r(icons_namespaceObject);
__webpack_require__.d(icons_namespaceObject, "about", function() { return about; });
__webpack_require__.d(icons_namespaceObject, "addcolumn", function() { return addcolumn; });
__webpack_require__.d(icons_namespaceObject, "addrow", function() { return addrow; });
__webpack_require__.d(icons_namespaceObject, "angle_down", function() { return angle_down; });
__webpack_require__.d(icons_namespaceObject, "angle_left", function() { return angle_left; });
__webpack_require__.d(icons_namespaceObject, "angle_right", function() { return angle_right; });
__webpack_require__.d(icons_namespaceObject, "angle_up", function() { return angle_up; });
__webpack_require__.d(icons_namespaceObject, "arrows_alt", function() { return arrows_alt; });
__webpack_require__.d(icons_namespaceObject, "arrows_h", function() { return arrows_h; });
__webpack_require__.d(icons_namespaceObject, "attachment", function() { return attachment; });
__webpack_require__.d(icons_namespaceObject, "bin", function() { return bin; });
__webpack_require__.d(icons_namespaceObject, "bold", function() { return icons_bold; });
__webpack_require__.d(icons_namespaceObject, "brush", function() { return brush; });
__webpack_require__.d(icons_namespaceObject, "cancel", function() { return icons_cancel; });
__webpack_require__.d(icons_namespaceObject, "center", function() { return center; });
__webpack_require__.d(icons_namespaceObject, "chain_broken", function() { return chain_broken; });
__webpack_require__.d(icons_namespaceObject, "check", function() { return check; });
__webpack_require__.d(icons_namespaceObject, "check_square", function() { return check_square; });
__webpack_require__.d(icons_namespaceObject, "copyformat", function() { return copyformat; });
__webpack_require__.d(icons_namespaceObject, "copy", function() { return icons_copy; });
__webpack_require__.d(icons_namespaceObject, "crop", function() { return crop; });
__webpack_require__.d(icons_namespaceObject, "cut", function() { return cut; });
__webpack_require__.d(icons_namespaceObject, "dedent", function() { return dedent; });
__webpack_require__.d(icons_namespaceObject, "dots", function() { return dots; });
__webpack_require__.d(icons_namespaceObject, "dropdown_arrow", function() { return dropdown_arrow; });
__webpack_require__.d(icons_namespaceObject, "enter", function() { return icons_enter; });
__webpack_require__.d(icons_namespaceObject, "eraser", function() { return eraser; });
__webpack_require__.d(icons_namespaceObject, "eye", function() { return eye; });
__webpack_require__.d(icons_namespaceObject, "file", function() { return icons_file; });
__webpack_require__.d(icons_namespaceObject, "folder", function() { return icons_folder; });
__webpack_require__.d(icons_namespaceObject, "font", function() { return icons_font; });
__webpack_require__.d(icons_namespaceObject, "fontsize", function() { return fontsize; });
__webpack_require__.d(icons_namespaceObject, "fullsize", function() { return icons_fullsize; });
__webpack_require__.d(icons_namespaceObject, "hr", function() { return icons_hr; });
__webpack_require__.d(icons_namespaceObject, "image", function() { return icons_image; });
__webpack_require__.d(icons_namespaceObject, "indent", function() { return icons_indent; });
__webpack_require__.d(icons_namespaceObject, "info_circle", function() { return info_circle; });
__webpack_require__.d(icons_namespaceObject, "italic", function() { return italic; });
__webpack_require__.d(icons_namespaceObject, "justify", function() { return icons_justify; });
__webpack_require__.d(icons_namespaceObject, "left", function() { return icons_left; });
__webpack_require__.d(icons_namespaceObject, "link", function() { return icons_link; });
__webpack_require__.d(icons_namespaceObject, "lock", function() { return lock; });
__webpack_require__.d(icons_namespaceObject, "menu", function() { return menu; });
__webpack_require__.d(icons_namespaceObject, "merge", function() { return merge; });
__webpack_require__.d(icons_namespaceObject, "ol", function() { return ol; });
__webpack_require__.d(icons_namespaceObject, "omega", function() { return omega; });
__webpack_require__.d(icons_namespaceObject, "outdent", function() { return outdent; });
__webpack_require__.d(icons_namespaceObject, "palette", function() { return palette; });
__webpack_require__.d(icons_namespaceObject, "paragraph", function() { return paragraph; });
__webpack_require__.d(icons_namespaceObject, "paste", function() { return icons_paste; });
__webpack_require__.d(icons_namespaceObject, "pencil", function() { return pencil; });
__webpack_require__.d(icons_namespaceObject, "plus", function() { return plus; });
__webpack_require__.d(icons_namespaceObject, "print", function() { return print; });
__webpack_require__.d(icons_namespaceObject, "redo", function() { return redo; });
__webpack_require__.d(icons_namespaceObject, "resize", function() { return icons_resize; });
__webpack_require__.d(icons_namespaceObject, "resizer", function() { return icons_resizer; });
__webpack_require__.d(icons_namespaceObject, "right", function() { return icons_right; });
__webpack_require__.d(icons_namespaceObject, "save", function() { return icons_save; });
__webpack_require__.d(icons_namespaceObject, "select_all", function() { return select_all; });
__webpack_require__.d(icons_namespaceObject, "shrink", function() { return shrink; });
__webpack_require__.d(icons_namespaceObject, "source", function() { return icons_source; });
__webpack_require__.d(icons_namespaceObject, "splitg", function() { return splitg; });
__webpack_require__.d(icons_namespaceObject, "splitv", function() { return splitv; });
__webpack_require__.d(icons_namespaceObject, "strikethrough", function() { return strikethrough; });
__webpack_require__.d(icons_namespaceObject, "subscript", function() { return subscript; });
__webpack_require__.d(icons_namespaceObject, "superscript", function() { return superscript; });
__webpack_require__.d(icons_namespaceObject, "table", function() { return icons_table; });
__webpack_require__.d(icons_namespaceObject, "th", function() { return th; });
__webpack_require__.d(icons_namespaceObject, "th_list", function() { return th_list; });
__webpack_require__.d(icons_namespaceObject, "ul", function() { return icons_ul; });
__webpack_require__.d(icons_namespaceObject, "underline", function() { return underline; });
__webpack_require__.d(icons_namespaceObject, "undo", function() { return undo; });
__webpack_require__.d(icons_namespaceObject, "unlink", function() { return icons_unlink; });
__webpack_require__.d(icons_namespaceObject, "unlock", function() { return unlock; });
__webpack_require__.d(icons_namespaceObject, "update", function() { return icons_update; });
__webpack_require__.d(icons_namespaceObject, "upload", function() { return upload; });
__webpack_require__.d(icons_namespaceObject, "valign", function() { return valign; });
__webpack_require__.d(icons_namespaceObject, "video", function() { return video; });

// EXTERNAL MODULE: ./src/styles/bundle.less
var bundle = __webpack_require__(97);

// CONCATENATED MODULE: ./src/constants.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const INVISIBLE_SPACE = '\uFEFF';
const INVISIBLE_SPACE_REG_EXP = /[\uFEFF]/g;
const INVISIBLE_SPACE_REG_EXP_END = /[\uFEFF]+$/g;
const INVISIBLE_SPACE_REG_EXP_START = /^[\uFEFF]+/g;
const SPACE_REG_EXP = /[\s\n\t\r\uFEFF\u200b]+/g;
const SPACE_REG_EXP_START = /^[\s\n\t\r\uFEFF\u200b]+/g;
const SPACE_REG_EXP_END = /[\s\n\t\r\uFEFF\u200b]+$/g;
const IS_BLOCK = /^(PRE|DIV|P|LI|H[1-6]|BLOCKQUOTE|TD|TH|TABLE|BODY|HTML|FIGCAPTION|FIGURE|DT|DD)$/i;
const IS_INLINE = /^(STRONG|SPAN|I|EM|B|SUP|SUB)$/;
const MAY_BE_REMOVED_WITH_KEY = /^(IMG|BR|IFRAME|SCRIPT|INPUT|TEXTAREA|HR|JODIT|JODIT-MEDIA)$/;
const KEY_BACKSPACE = 8;
const KEY_TAB = 9;
const KEY_ENTER = 13;
const KEY_ESC = 27;
const KEY_LEFT = 37;
const KEY_UP = 38;
const KEY_RIGHT = 39;
const KEY_DOWN = 40;
const KEY_DELETE = 46;
const KEY_F = 70;
const KEY_R = 82;
const KEY_H = 72;
const KEY_Y = 89;
const KEY_V = 86;
const KEY_Z = 90;
const KEY_F3 = 114;
const NEARBY = 5;
const ACCURACY = 10;
const COMMAND_KEYS = [
    KEY_BACKSPACE,
    KEY_DELETE,
    KEY_UP,
    KEY_DOWN,
    KEY_RIGHT,
    KEY_LEFT,
    KEY_ENTER,
    KEY_ESC,
    KEY_F3,
    KEY_TAB
];
const BR = 'br';
const PARAGRAPH = 'p';
const MODE_WYSIWYG = 1;
const MODE_SOURCE = 2;
const MODE_SPLIT = 3;
const IS_IE = typeof navigator !== 'undefined' &&
    (navigator.userAgent.indexOf('MSIE') !== -1 ||
        /rv:11.0/i.test(navigator.userAgent));
const URL_LIST = IS_IE ? 'url' : 'text/uri-list';
const TEXT_PLAIN = IS_IE ? 'text' : 'text/plain';
const TEXT_HTML = IS_IE ? 'text' : 'text/html';
const MARKER_CLASS = 'jodit_selection_marker';
const EMULATE_DBLCLICK_TIMEOUT = 300;
const JODIT_SELECTED_CELL_MARKER = 'data-jodit-selected-cell';
const INSERT_AS_HTML = 'insert_as_html';
const INSERT_CLEAR_HTML = 'insert_clear_html';
const INSERT_AS_TEXT = 'insert_as_text';
const INSERT_ONLY_TEXT = 'insert_only_text';
const IS_MAC = typeof window !== 'undefined' &&
    /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
const KEY_ALIASES = {
    add: '+',
    break: 'pause',
    cmd: 'meta',
    command: 'meta',
    ctl: 'control',
    ctrl: 'control',
    del: 'delete',
    down: 'arrowdown',
    esc: 'escape',
    ins: 'insert',
    left: 'arrowleft',
    mod: IS_MAC ? 'meta' : 'control',
    opt: 'alt',
    option: 'alt',
    return: 'enter',
    right: 'arrowright',
    space: ' ',
    spacebar: ' ',
    up: 'arrowup',
    win: 'meta',
    windows: 'meta'
};
const BASE_PATH = (() => {
    if (typeof document === 'undefined') {
        return '';
    }
    const script = document.currentScript, removeScriptName = (s) => s.replace(/\/[^\/]+.js$/, '/');
    if (script) {
        return removeScriptName(script.src);
    }
    const scripts = document.querySelectorAll('script[src]');
    if (scripts && scripts.length) {
        return removeScriptName(scripts[scripts.length - 1].src);
    }
    return window.location.href;
})();

// CONCATENATED MODULE: ./src/modules/helpers/array/asArray.ts
const asArray = (a) => (Array.isArray(a) ? a : [a]);

// CONCATENATED MODULE: ./src/modules/helpers/array/inArray.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const inArray = (needle, haystack) => haystack.indexOf(needle) !== -1;

// CONCATENATED MODULE: ./src/modules/helpers/array/splitArray.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const splitArray = (a) => typeof a === 'string' ? a.split(/[,\s]+/) : a;

// CONCATENATED MODULE: ./src/modules/helpers/array/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




// CONCATENATED MODULE: ./src/modules/helpers/async/setTimeout.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
function setTimeout_setTimeout(callback, timeout, ...args) {
    if (!timeout) {
        callback.call(null, ...args);
    }
    else {
        return window.setTimeout(callback, timeout, ...args);
    }
    return 0;
}
function setTimeout_clearTimeout(timer) {
    window.clearTimeout(timer);
}

// CONCATENATED MODULE: ./src/modules/helpers/async/debounce.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const debounce = function (fn, timeout, invokeAsap, ctx) {
    if (arguments.length === 3 && typeof invokeAsap !== 'boolean') {
        ctx = invokeAsap;
        invokeAsap = false;
    }
    let timer = 0;
    return function () {
        const args = arguments;
        const context = ctx || this;
        if ((invokeAsap && !timer) || !timeout) {
            fn.apply(context, args);
        }
        if (timeout) {
            setTimeout_clearTimeout(timer);
            timer = setTimeout_setTimeout(() => {
                if (!invokeAsap) {
                    fn.apply(context, args);
                }
                timer = 0;
            }, timeout);
        }
    };
};

// CONCATENATED MODULE: ./src/modules/helpers/async/throttle.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const throttle = (fn, timeout, ctx) => {
    let timer = null, args, needInvoke, callee;
    return function () {
        args = arguments;
        needInvoke = true;
        const context = ctx || this;
        if (!timeout) {
            fn.apply(context, args);
            return;
        }
        if (!timer) {
            callee = () => {
                if (needInvoke) {
                    fn.apply(context, args);
                    needInvoke = false;
                    timer = setTimeout_setTimeout(callee, timeout);
                }
                else {
                    timer = null;
                }
            };
            callee();
        }
    };
};

// CONCATENATED MODULE: ./src/modules/helpers/async/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




// CONCATENATED MODULE: ./src/modules/helpers/JoditObject.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

class JoditObject_JoditObject {
    constructor(data) {
        extend(true, this, data);
    }
}

// CONCATENATED MODULE: ./src/modules/helpers/JoditArray.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

class JoditArray_JoditArray {
    constructor(data) {
        this.length = 0;
        extend(true, this, data);
        this.length = data.length;
        const proto = Array.prototype;
        [
            'map',
            'forEach',
            'reduce',
            'push',
            'pop',
            'shift',
            'unshift',
            'slice',
            'splice'
        ].forEach((method) => {
            this[method] = proto[method];
        });
    }
    toString() {
        const out = [];
        for (let i = 0; i < this.length; i += 1) {
            out[i] = this[i];
        }
        return out.toString();
    }
}

// CONCATENATED MODULE: ./src/modules/helpers/type.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const class2type = {};
const type_toString = class2type.toString;
const hasOwn = class2type.hasOwnProperty;
[
    'Boolean',
    'Number',
    'String',
    'Function',
    'Array',
    'Date',
    'RegExp',
    'Object',
    'Error',
    'Symbol',
    'HTMLDocument',
    'Window',
    'HTMLElement',
    'HTMLBodyElement',
    'Text',
    'DocumentFragment',
    'DOMStringList',
    'HTMLCollection'
].forEach(name => {
    class2type['[object ' + name + ']'] = name.toLowerCase();
});
const type_type = (obj) => {
    if (obj === null) {
        return 'null';
    }
    return typeof obj === 'object' || typeof obj === 'function'
        ? class2type[type_toString.call(obj)] || 'object'
        : typeof obj;
};
function type_error(message) {
    return new TypeError(message);
}

// CONCATENATED MODULE: ./src/modules/helpers/checker/isWindow.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isWindow = (obj) => {
    return obj !== null && obj === obj.window;
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isPlainObject.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const isPlainObject = (obj) => {
    if (typeof obj !== 'object' || obj.nodeType || isWindow(obj)) {
        return false;
    }
    return !(obj.constructor &&
        !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'));
};

// CONCATENATED MODULE: ./src/modules/helpers/extend.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




function extend(...args) {
    const length = args.length;
    let options, name, src, copy, copyIsArray, clone, target = args[0] || {}, i = 1, j, keys, deep = false;
    if (typeof target === 'boolean') {
        deep = target;
        target = args[i] || {};
        i += 1;
    }
    if (typeof target !== 'object' && type_type(target) === 'function') {
        target = {};
    }
    if (i === length) {
        target = this;
        i += 1;
    }
    for (i; i < length; i += 1) {
        options = args[i];
        if (options !== null && options !== undefined) {
            keys = Object.keys(options);
            for (j = 0; j < keys.length; j += 1) {
                name = keys[j];
                src = target[name];
                copy = options[name];
                if (target === copy) {
                    continue;
                }
                if (deep &&
                    copy &&
                    ((isPlainObject(copy) && !(copy instanceof JoditObject_JoditObject)) ||
                        (Array.isArray(copy) && !(copy instanceof JoditArray_JoditArray)))) {
                    copyIsArray = Array.isArray(copy);
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else {
                        clone = src && isPlainObject(src) ? src : {};
                    }
                    target[name] = extend(deep, clone, copy);
                }
                else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }
    return target;
}

// CONCATENATED MODULE: ./src/modules/helpers/checker/hasBrowserColorPicker.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const hasBrowserColorPicker = () => {
    let supportsColor = true;
    try {
        const a = document.createElement("input");
        a.type = "color";
        supportsColor = a.type === "color" && typeof a.selectionStart !== "number";
    }
    catch (e) {
        supportsColor = false;
    }
    return supportsColor;
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isFunction.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isFunction = (value) => {
    return typeof value === 'function';
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isHTML.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isHTML = (str) => /<([A-Za-z][A-Za-z0-9]*)\b[^>]*>(.*?)<\/\1>/m.test(str);

// CONCATENATED MODULE: ./src/modules/helpers/checker/isHTMLFromWord.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isHTMLFromWord = (data) => {
    return (data.search(/<meta.*?Microsoft Excel\s[\d].*?>/) !== -1 ||
        data.search(/<meta.*?Microsoft Word\s[\d].*?>/) !== -1 ||
        (data.search(/style="[^"]*mso-/) !== -1 && data.search(/<font/) !== -1));
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isInitable.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const isInitable = (value) => {
    return value && isFunction(value.init);
};
const isDestructable = (value) => {
    return value && isFunction(value.destruct);
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isNumeric.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isNumeric = (value) => {
    if (typeof value === 'string') {
        if (!value.match(/^([+\-])?[0-9]+(\.?)([0-9]+)?(e[0-9]+)?$/)) {
            return false;
        }
        value = parseFloat(value);
    }
    return !isNaN(value) && isFinite(value);
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isInt.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const isInt = (value) => {
    if (typeof value === 'string' && isNumeric(value)) {
        value = parseFloat(value);
    }
    return typeof value === 'number' && Number.isFinite(value) && !(value % 1);
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isJoditObject.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isJoditObject = (jodit) => {
    if (jodit &&
        jodit instanceof Object &&
        typeof jodit.constructor === 'function' &&
        (jodit instanceof Jodit_Jodit || jodit.isJodit)) {
        return true;
    }
    return false;
};


// CONCATENATED MODULE: ./src/modules/helpers/checker/isLicense.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isLicense = (license) => typeof license === 'string' &&
    license.length === 32 &&
    /^[a-z0-9]+$/.test(license);

// CONCATENATED MODULE: ./src/modules/helpers/checker/isString.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isString = (value) => {
    return typeof value === 'string';
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isURL.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isURL = (str) => {
    const pattern = new RegExp('^(https?:\\/\\/)' +
        '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.?)+[a-z]{2,}|' +
        '((\\d{1,3}\\.){3}\\d{1,3}))' +
        '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' +
        '(\\?[;&a-z\\d%_.~+=-]*)?' +
        '(\\#[-a-z\\d_]*)?$', 'i');
    return pattern.test(str);
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isValidName.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const isValidName = (name) => {
    if (!name.length) {
        return false;
    }
    if (/[^0-9A-Za-zÐ°-ÑÐ-Ð¯ÐÑ\w\-_\.]/.test(name)) {
        return false;
    }
    return true;
};

// CONCATENATED MODULE: ./src/modules/helpers/checker/isPromise.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
function isPromise(val) {
    return val && typeof val.then === 'function';
}

// CONCATENATED MODULE: ./src/modules/helpers/checker/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
















// CONCATENATED MODULE: ./src/modules/helpers/color/hexToRgb.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const hexToRgb = (hex) => {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => {
        return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
        }
        : null;
};

// CONCATENATED MODULE: ./src/modules/helpers/color/colorToHex.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const colorToHex = (color) => {
    if (color === 'rgba(0, 0, 0, 0)' || color === '') {
        return false;
    }
    if (!color) {
        return '#000000';
    }
    if (color.substr(0, 1) === '#') {
        return color;
    }
    const digits = /([\s\n\t\r]*?)rgb\((\d+), (\d+), (\d+)\)/.exec(color) ||
        /([\s\n\t\r]*?)rgba\((\d+), (\d+), (\d+), ([\d.]+)\)/.exec(color);
    let hex, red, green, blue, rgb;
    if (!digits) {
        return '#000000';
    }
    red = parseInt(digits[2], 10);
    green = parseInt(digits[3], 10);
    blue = parseInt(digits[4], 10);
    rgb = blue | (green << 8) | (red << 16);
    hex = rgb.toString(16).toUpperCase();
    while (hex.length < 6) {
        hex = '0' + hex;
    }
    return digits[1] + '#' + hex;
};

// CONCATENATED MODULE: ./src/modules/helpers/color/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



// CONCATENATED MODULE: ./src/modules/helpers/selector.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


let temp = 1;
const $$temp = () => {
    temp++;
    return temp;
};
const $$ = (selector, root) => {
    let result;
    if (/:scope/.test(selector) &&
        IS_IE &&
        !(root && root.nodeType === Node.DOCUMENT_NODE)) {
        const id = root.id, temp_id = id ||
            '_selector_id_' + ('' + Math.random()).slice(2) + $$temp();
        selector = selector.replace(/:scope/g, '#' + temp_id);
        !id && root.setAttribute('id', temp_id);
        result = root.parentNode.querySelectorAll(selector);
        if (!id) {
            root.removeAttribute('id');
        }
    }
    else {
        result = root.querySelectorAll(selector);
    }
    return [].slice.call(result);
};
const getXPathByElement = (element, root) => {
    if (!element || element.nodeType !== 1) {
        return '';
    }
    if (!element.parentNode || root === element) {
        return '';
    }
    if (element.id) {
        return "//*[@id='" + element.id + "']";
    }
    const sames = [].filter.call(element.parentNode.childNodes, (x) => x.nodeName === element.nodeName);
    return (getXPathByElement(element.parentNode, root) +
        '/' +
        element.nodeName.toLowerCase() +
        (sames.length > 1
            ? '[' + (Array.from(sames).indexOf(element) + 1) + ']'
            : ''));
};
const refs = (root) => {
    return $$('[ref]', root).reduce((def, child) => {
        const key = child.getAttribute('ref');
        if (key && isString(key)) {
            def[key] = child;
        }
        return def;
    }, {});
};

// CONCATENATED MODULE: ./src/modules/helpers/string/camelCase.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const camelCase = (key) => {
    return key.replace(/([-_])(.)/g, (m, code, letter) => {
        return letter.toUpperCase();
    });
};

// CONCATENATED MODULE: ./src/modules/helpers/string/fromCamelCase.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const fromCamelCase = (key) => {
    return key.replace(/([A-Z]+)/g, (m, letter) => {
        return '-' + letter.toLowerCase();
    });
};

// CONCATENATED MODULE: ./src/modules/helpers/string/trim.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const trim = (value) => {
    return value
        .replace(SPACE_REG_EXP_START, '')
        .replace(SPACE_REG_EXP_END, '');
};

// CONCATENATED MODULE: ./src/modules/helpers/string/ucfirst.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const ucfirst = (value) => {
    if (!value.length) {
        return '';
    }
    return value[0].toUpperCase() + value.substr(1);
};

// CONCATENATED MODULE: ./src/modules/helpers/defaultLanguage.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const defaultLanguage_defaultLanguage = (language, defaultLanguage = 'en') => {
    if (language !== 'auto' && typeof language === 'string') {
        return language;
    }
    if (document.documentElement && document.documentElement.lang) {
        return document.documentElement.lang;
    }
    if (navigator.language) {
        return navigator.language.substr(0, 2);
    }
    return defaultLanguage;
};

// CONCATENATED MODULE: ./src/modules/helpers/string/i18n.ts



const sprintf = (str, args) => {
    if (!args || !args.length) {
        return str;
    }
    const reg = /%([sd])/g;
    let fnd = reg.exec(str);
    let res = str, i = 0;
    while (fnd && args[i] !== undefined) {
        res = res.replace(fnd[0], args[i].toString());
        i += 1;
        fnd = reg.exec(str);
    }
    return res;
};
const i18n_i18n = (key, params, options, safe = "production" === 'production') => {
    var _a, _b;
    const debug = Boolean(options !== undefined && options.debugLanguage);
    let store;
    const parse = (value) => (params && params.length) ? sprintf(value, params) : value, defaultLanguage = defaultLanguage_defaultLanguage(Config_Config.defaultOptions.language, Config_Config.defaultOptions.language), language = defaultLanguage_defaultLanguage((_a = options) === null || _a === void 0 ? void 0 : _a.language, defaultLanguage), tryGet = (store) => {
        if (!store) {
            return;
        }
        if (isString(store[key])) {
            return parse(store[key]);
        }
        const lcKey = key.toLowerCase();
        if (isString(store[lcKey])) {
            return parse(store[lcKey]);
        }
        const ucfKey = ucfirst(key);
        if (isString(store[ucfKey])) {
            return parse(store[ucfKey]);
        }
        return;
    };
    if (Jodit_Jodit.lang[language] !== undefined) {
        store = Jodit_Jodit.lang[language];
    }
    else {
        if (Jodit_Jodit.lang[defaultLanguage] !== undefined) {
            store = Jodit_Jodit.lang[defaultLanguage];
        }
        else {
            store = Jodit_Jodit.lang.en;
        }
    }
    const i18nOvr = (_b = options) === null || _b === void 0 ? void 0 : _b.i18n;
    if (i18nOvr && i18nOvr[language]) {
        const result = tryGet(i18nOvr[language]);
        if (result) {
            return result;
        }
    }
    const result = tryGet(store);
    if (result) {
        return result;
    }
    if (Jodit_Jodit.lang.en && typeof Jodit_Jodit.lang.en[key] === 'string' && Jodit_Jodit.lang.en[key]) {
        return parse(Jodit_Jodit.lang.en[key]);
    }
    if (debug) {
        return '{' + key + '}';
    }
    if (!safe && language !== 'en') {
        throw new TypeError(`i18n need "${key}" in "${language}"`);
    }
    return parse(key);
};


// CONCATENATED MODULE: ./src/modules/helpers/string/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






// CONCATENATED MODULE: ./src/modules/helpers/html/applyStyles.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



function normalizeCSS(s) {
    return s
        .replace(/mso-[a-z\-]+:[\s]*[^;]+;/gi, '')
        .replace(/mso-[a-z\-]+:[\s]*[^";]+$/gi, '')
        .replace(/border[a-z\-]*:[\s]*[^;]+;/gi, '')
        .replace(/([0-9.]+)(pt|cm)/gi, (match, units, metrics) => {
        switch (metrics.toLowerCase()) {
            case 'pt':
                return (parseFloat(units) * 1.328).toFixed(0) + 'px';
            case 'cm':
                return (parseFloat(units) * 0.02645833).toFixed(0) + 'px';
        }
        return match;
    });
}
const applyStyles = (html) => {
    if (html.indexOf('<html ') === -1) {
        return html;
    }
    html = html.substring(html.indexOf('<html '), html.length);
    html = html.substring(0, html.lastIndexOf('</html>') + '</html>'.length);
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    document.body.appendChild(iframe);
    let convertedString = '', collection = [], rules = [];
    try {
        const iframeDoc = iframe.contentDocument ||
            (iframe.contentWindow ? iframe.contentWindow.document : null);
        if (iframeDoc) {
            iframeDoc.open();
            iframeDoc.write(html);
            iframeDoc.close();
            if (iframeDoc.styleSheets.length) {
                rules = iframeDoc.styleSheets[iframeDoc.styleSheets.length - 1].cssRules;
            }
            for (let idx = 0; idx < rules.length; idx += 1) {
                if (rules[idx].selectorText === '') {
                    continue;
                }
                collection = $$(rules[idx].selectorText, iframeDoc.body);
                collection.forEach((elm) => {
                    elm.style.cssText = normalizeCSS(rules[idx].style.cssText + ';' + elm.style.cssText);
                });
            }
            Dom_Dom.each(iframeDoc.body, node => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const elm = node;
                    const css = elm.style.cssText;
                    if (css) {
                        elm.style.cssText = normalizeCSS(css);
                    }
                    if (elm.hasAttribute('lang')) {
                        elm.removeAttribute('lang');
                    }
                }
            });
            convertedString = iframeDoc.firstChild
                ? trim(iframeDoc.body.innerHTML)
                : '';
        }
    }
    catch (_a) {
    }
    finally {
        Dom_Dom.safeRemove(iframe);
    }
    if (convertedString) {
        html = convertedString;
    }
    return trim(html
        .replace(/<(\/)?(html|colgroup|col|o:p)[^>]*>/g, '')
        .replace(/<!--[^>]*>/g, ''));
};

// CONCATENATED MODULE: ./src/modules/helpers/html/cleanFromWord.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const cleanFromWord = (html) => {
    if (html.indexOf('<html ') !== -1) {
        html = html.substring(html.indexOf('<html '), html.length);
        html = html.substring(0, html.lastIndexOf('</html>') + '</html>'.length);
    }
    let convertedString = '';
    try {
        const div = document.createElement('div');
        div.innerHTML = html;
        const marks = [];
        if (div.firstChild) {
            Dom_Dom.all(div, node => {
                if (!node) {
                    return;
                }
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        switch (node.nodeName) {
                            case 'STYLE':
                            case 'LINK':
                            case 'META':
                                marks.push(node);
                                break;
                            case 'W:SDT':
                            case 'W:SDTPR':
                            case 'FONT':
                                Dom_Dom.unwrap(node);
                                break;
                            default:
                                Array.from(node.attributes)
                                    .forEach((attr) => {
                                    if ([
                                        'src',
                                        'href',
                                        'rel',
                                        'content',
                                    ].indexOf(attr.name.toLowerCase()) ===
                                        -1) {
                                        node.removeAttribute(attr.name);
                                    }
                                });
                        }
                        break;
                    case Node.TEXT_NODE:
                        break;
                    default:
                        marks.push(node);
                }
            });
        }
        marks.forEach(Dom_Dom.safeRemove);
        convertedString = div.innerHTML;
    }
    catch (e) { }
    if (convertedString) {
        html = convertedString;
    }
    html = html.split(/(\n)/).filter(trim).join('\n');
    return html
        .replace(/<(\/)?(html|colgroup|col|o:p)[^>]*>/g, '')
        .replace(/<!--[^>]*>/g, '');
};

// CONCATENATED MODULE: ./src/modules/helpers/html/clear.ts
/*!
* Jodit Editor (https://xdsoft.net/jodit/)
* Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
* For GPL see LICENSE-GPL.txt in the project root for license information.
* For MIT see LICENSE-MIT.txt in the project root for license information.
* For commercial licenses see https://xdsoft.net/jodit/commercial/
* Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
*/


const clear_clear = (value, removeEmptyBlocks = false) => {
    value = trim(value)
        .replace(INVISIBLE_SPACE_REG_EXP, '')
        .replace(/[\s]*class=""/g, '');
    if (removeEmptyBlocks) {
        value = value.replace(/<p[^>]*>[\s\n\r\t]*(&nbsp;|<br>|<br\/>)?[\s\n\r\t]*<\/p>[\n\r]*/g, '');
    }
    return value;
};

// CONCATENATED MODULE: ./src/modules/helpers/html/htmlspecialchars.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const htmlspecialchars = (html) => {
    const tmp = document.createElement('div');
    tmp.textContent = html;
    return tmp.innerHTML;
};

// CONCATENATED MODULE: ./src/modules/helpers/html/stripTags.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const stripTags = (html) => {
    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    return tmp.textContent || '';
};

// CONCATENATED MODULE: ./src/modules/helpers/html/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeKeyAliases.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const normalizeKeyAliases = (keys) => {
    const memory = {};
    return keys
        .replace(/\+\+/g, '+add')
        .split(/[\s]*\+[\s]*/)
        .map(key => trim(key.toLowerCase()))
        .map(key => KEY_ALIASES[key] || key)
        .sort()
        .filter(key => !memory[key] && key !== '' && (memory[key] = true))
        .join('+');
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeLicense.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const normalizeLicense = (license, count = 8) => {
    const parts = [];
    while (license.length) {
        parts.push(license.substr(0, count));
        license = license.substr(count);
    }
    parts[1] = parts[1].replace(/./g, '*');
    parts[2] = parts[2].replace(/./g, '*');
    return parts.join('-');
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeNode.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const normalizeNode = (node) => {
    if (!node) {
        return;
    }
    if (node.nodeType === Node.TEXT_NODE &&
        node.nodeValue !== null &&
        node.parentNode) {
        while (node.nextSibling &&
            node.nextSibling.nodeType === Node.TEXT_NODE) {
            if (node.nextSibling.nodeValue !== null) {
                node.nodeValue += node.nextSibling.nodeValue;
            }
            node.nodeValue = node.nodeValue.replace(INVISIBLE_SPACE_REG_EXP, '');
            Dom_Dom.safeRemove(node.nextSibling);
        }
    }
    else {
        normalizeNode(node.firstChild);
    }
    normalizeNode(node.nextSibling);
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizePath.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const normalizePath = (...path) => {
    return path
        .filter(part => trim(part).length)
        .map((part, index) => {
        part = part.replace(/([^:])[\\\/]+/g, '$1/');
        if (index) {
            part = part.replace(/^\//, '');
        }
        if (index !== path.length - 1) {
            part = part.replace(/\/$/, '');
        }
        return part;
    })
        .join('/');
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeRelativePath.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * License GNU General Public License version 2 or later;
 * Copyright 2013-2020 Valeriy Chupurnov https://xdsoft.net
 * @author Patrick Sachs https://github.com/PatrickSachs
 */
const normalizeRelativePath = (path) => {
    const sections = path.split('/'), builder = sections.reduce((builder, section) => {
        switch (section) {
            case '': {
                break;
            }
            case '.': {
                break;
            }
            case '..': {
                builder.pop();
                break;
            }
            default: {
                builder.push(section);
                break;
            }
        }
        return builder;
    }, []);
    return builder.join('/') + (path.endsWith('/') ? '/' : '');
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeSize.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const normalizeSize = (value) => {
    if (/^[0-9]+$/.test(value.toString())) {
        return value + 'px';
    }
    return value.toString();
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeURL.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const normalizeURL = (...urls) => {
    return urls
        .filter(url => url.length)
        .map(url => url.replace(/\/$/, ''))
        .join('/')
        .replace(/([^:])[\\\/]+/g, '$1/');
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normilizeCSSValue.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const normilizeCSSValue = (key, value) => {
    switch (key.toLowerCase()) {
        case 'font-weight':
            switch (value.toString().toLowerCase()) {
                case 'bold':
                    return 700;
                case 'normal':
                    return 400;
                case 'heavy':
                    return 900;
            }
            return isNumeric(value) ? +value : value;
    }
    return value;
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/normalizeColor.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const normalizeColor = (colorInput) => {
    const newcolor = ['#'];
    let color = colorToHex(colorInput);
    if (!color) {
        return false;
    }
    color = trim(color.toUpperCase());
    color = color.substr(1);
    if (color.length === 3) {
        for (let i = 0; i < 3; i += 1) {
            newcolor.push(color[i]);
            newcolor.push(color[i]);
        }
        return newcolor.join('');
    }
    if (color.length > 6) {
        color = color.substr(0, 6);
    }
    return '#' + color;
};

// CONCATENATED MODULE: ./src/modules/helpers/normalize/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */










// CONCATENATED MODULE: ./src/modules/helpers/size/getContentWidth.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const getContentWidth = (element, win) => {
    const pi = (value) => parseInt(value, 10), style = win.getComputedStyle(element), width = element.offsetWidth, paddingLeft = pi(style.getPropertyValue('padding-left') || '0'), paddingRight = pi(style.getPropertyValue('padding-right') || '0');
    return width - paddingLeft - paddingRight;
};

// CONCATENATED MODULE: ./src/modules/helpers/size/innerWidth.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const innerWidth_innerWidth = (element, win) => {
    const computedStyle = win.getComputedStyle(element);
    let elementWidth = element.clientWidth;
    elementWidth -=
        parseFloat(computedStyle.paddingLeft || '0') +
            parseFloat(computedStyle.paddingRight || '0');
    return elementWidth;
};

// CONCATENATED MODULE: ./src/modules/helpers/size/offset.ts
const offset = (elm, jodit, doc, recurse = false) => {
    const rect = elm.getBoundingClientRect(), body = doc.body, docElem = doc.documentElement || {
        clientTop: 0,
        clientLeft: 0,
        scrollTop: 0,
        scrollLeft: 0
    }, win = doc.defaultView || doc.parentWindow, scrollTop = win.pageYOffset || docElem.scrollTop || body.scrollTop, scrollLeft = win.pageXOffset || docElem.scrollLeft || body.scrollLeft, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0;
    let topValue, leftValue;
    const iframe = jodit.iframe;
    if (!recurse &&
        jodit &&
        jodit.options &&
        jodit.options.iframe &&
        iframe) {
        const { top, left } = offset(iframe, jodit, jodit.ownerDocument, true);
        topValue = rect.top + top;
        leftValue = rect.left + left;
    }
    else {
        topValue = rect.top + scrollTop - clientTop;
        leftValue = rect.left + scrollLeft - clientLeft;
    }
    return {
        top: Math.round(topValue),
        left: Math.round(leftValue),
        width: rect.width,
        height: rect.height
    };
};

// CONCATENATED MODULE: ./src/modules/helpers/size/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




// CONCATENATED MODULE: ./src/modules/helpers/completeUrl.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const completeUrl = (url) => {
    if (window.location.protocol === 'file:' && /^\/\//.test(url)) {
        url = 'https:' + url;
    }
    return url;
};

// CONCATENATED MODULE: ./src/modules/helpers/appendScript.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const alreadyLoadedList = new Map();
const cacheLoaders = (loader) => {
    return async (jodit, url) => {
        if (alreadyLoadedList.has(url)) {
            return alreadyLoadedList.get(url);
        }
        const promise = loader(jodit, url);
        alreadyLoadedList.set(url, promise);
        return promise;
    };
};
const appendScript = (jodit, url, callback) => {
    const script = jodit.create.element('script');
    script.type = 'text/javascript';
    if (callback !== undefined) {
        script.addEventListener('load', callback);
    }
    if (!script.src) {
        script.src = completeUrl(url);
    }
    jodit.ownerDocument.body.appendChild(script);
    return {
        callback,
        element: script
    };
};
const appendScriptAsync = cacheLoaders((jodit, url) => {
    return new Promise((resolve, reject) => {
        const { element } = appendScript(jodit, url, resolve);
        element.addEventListener('error', reject);
    });
});
const appendStyleAsync = cacheLoaders((jodit, url) => {
    return new Promise((resolve, reject) => {
        const link = jodit.create.element('link');
        link.rel = 'stylesheet';
        link.media = 'all';
        link.crossOrigin = 'anonymous';
        const callback = () => resolve(link);
        link.addEventListener('load', callback);
        link.addEventListener('error', reject);
        link.href = completeUrl(url);
        jodit.ownerDocument.body.appendChild(link);
    });
});
const loadNext = (jodit, urls, i = 0) => {
    if (!isString(urls[i])) {
        return Promise.resolve();
    }
    return appendScriptAsync(jodit, urls[i]).then(() => loadNext(jodit, urls, i + 1));
};

// CONCATENATED MODULE: ./src/modules/helpers/browser.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const browser = (browser) => {
    const ua = navigator.userAgent.toLowerCase(), match = /(firefox)[\s\/]([\w.]+)/.exec(ua) ||
        /(chrome)[\s\/]([\w.]+)/.exec(ua) ||
        /(webkit)[\s\/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version)[\s\/]([\w.]+)/.exec(ua) ||
        /(msie)[\s]([\w.]+)/.exec(ua) ||
        /(trident)\/([\w.]+)/.exec(ua) ||
        ua.indexOf('compatible') < 0 ||
        [];
    if (browser === 'version') {
        return match[2];
    }
    if (browser === 'webkit') {
        return match[1] === 'chrome' || match[1] === 'webkit';
    }
    if (browser === 'ff') {
        return match[1] === 'firefox';
    }
    if (browser === 'msie') {
        return match[1] === 'trident' || match[1] === 'msie';
    }
    return match[1] === browser;
};

// CONCATENATED MODULE: ./src/modules/helpers/parseQuery.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const parseQuery = (queryString) => {
    const query = {}, a = queryString.substr(1).split('&');
    for (let i = 0; i < a.length; i += 1) {
        const keyValue = a[i].split('=');
        query[decodeURIComponent(keyValue[0])] = decodeURIComponent(keyValue[1] || '');
    }
    return query;
};

// CONCATENATED MODULE: ./src/modules/helpers/convertMediaURLToVideoEmbed.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const convertMediaURLToVideoEmbed = (url, width = 400, height = 345) => {
    if (!isURL(url)) {
        return url;
    }
    const parser = document.createElement('a'), pattern1 = /(?:http?s?:\/\/)?(?:www\.)?(?:vimeo\.com)\/?(.+)/g;
    parser.href = url;
    if (!width) {
        width = 400;
    }
    if (!height) {
        height = 345;
    }
    const protocol = parser.protocol || '';
    switch (parser.hostname) {
        case 'www.vimeo.com':
        case 'vimeo.com':
            return pattern1.test(url)
                ? url.replace(pattern1, '<iframe width="' +
                    width +
                    '" height="' +
                    height +
                    '" src="' +
                    protocol +
                    '//player.vimeo.com/video/$1" frameborder="0" allowfullscreen></iframe>')
                : url;
        case 'youtube.com':
        case 'www.youtube.com':
        case 'youtu.be':
        case 'www.youtu.be':
            const query = parser.search
                ? parseQuery(parser.search)
                : { v: parser.pathname.substr(1) };
            return query.v
                ? '<iframe width="' +
                    width +
                    '" height="' +
                    height +
                    '" src="' +
                    protocol +
                    '//www.youtube.com/embed/' +
                    query.v +
                    '" frameborder="0" allowfullscreen></iframe>'
                : url;
    }
    return url;
};

// CONCATENATED MODULE: ./src/modules/helpers/css.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





const css_css = (element, key, value, onlyStyleMode = false) => {
    const numberFieldsReg = /^left|top|bottom|right|width|min|max|height|margin|padding|font-size/i;
    if (isPlainObject(key) || value !== undefined) {
        const setValue = (elm, _key, _value) => {
            if (_value !== undefined &&
                _value !== null &&
                numberFieldsReg.test(_key) &&
                isNumeric(_value.toString())) {
                _value = parseInt(_value.toString(), 10) + 'px';
            }
            if (_value !== undefined &&
                css_css(elm, _key, undefined, true) !== normilizeCSSValue(_key, _value)) {
                elm.style[_key] = _value;
            }
        };
        if (isPlainObject(key)) {
            const keys = Object.keys(key);
            for (let j = 0; j < keys.length; j += 1) {
                setValue(element, camelCase(keys[j]), key[keys[j]]);
            }
        }
        else {
            setValue(element, camelCase(key), value);
        }
        return '';
    }
    const key2 = fromCamelCase(key), doc = element.ownerDocument || document, win = doc ? doc.defaultView || doc.parentWindow : false;
    const currentValue = element.style[key];
    let result = '';
    if (currentValue !== undefined && currentValue !== '') {
        result = currentValue;
    }
    else if (win && !onlyStyleMode) {
        result = win.getComputedStyle(element).getPropertyValue(key2);
    }
    if (numberFieldsReg.test(key) &&
        /^[\-+]?[0-9.]+px$/.test(result.toString())) {
        result = parseInt(result.toString(), 10);
    }
    return normilizeCSSValue(key, result);
};
const clearCenterAlign = (image) => {
    if (css_css(image, 'display') === 'block') {
        css_css(image, 'display', '');
    }
    if (image.style.marginLeft === 'auto' &&
        image.style.marginRight === 'auto') {
        image.style.marginLeft = '';
        image.style.marginRight = '';
    }
};

// CONCATENATED MODULE: ./src/modules/helpers/ctrlKey.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const ctrlKey = (e) => {
    if (typeof navigator !== 'undefined' &&
        navigator.userAgent.indexOf('Mac OS X') !== -1) {
        if (e.metaKey && !e.altKey) {
            return true;
        }
    }
    else if (e.ctrlKey && !e.altKey) {
        return true;
    }
    return false;
};

// CONCATENATED MODULE: ./src/modules/helpers/dataBind.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const dataBindKey = 'JoditDataBindKey';
const dataBind = (elm, key, value) => {
    let store = elm[dataBindKey];
    if (!store) {
        store = {};
        Object.defineProperty(elm, dataBindKey, {
            enumerable: false,
            configurable: true,
            value: store
        });
    }
    if (value === undefined) {
        return store[key];
    }
    store[key] = value;
};

// CONCATENATED MODULE: ./src/modules/helpers/each.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
function each(obj, callback) {
    let length, keys, i;
    if (Array.isArray(obj)) {
        length = obj.length;
        for (i = 0; i < length; i += 1) {
            if (callback.call(obj[i], i, obj[i]) === false) {
                return false;
            }
        }
    }
    else {
        keys = Object.keys(obj);
        for (i = 0; i < keys.length; i += 1) {
            if (callback.call(obj[keys[i]], keys[i], obj[keys[i]]) === false) {
                return false;
            }
        }
    }
    return true;
}

// CONCATENATED MODULE: ./src/modules/helpers/humanSizeToBytes.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const humanSizeToBytes = (human) => {
    if (/^[0-9.]+$/.test(human.toString())) {
        return parseFloat(human);
    }
    const format = human.substr(-2, 2).toUpperCase(), formats = ['KB', 'MB', 'GB', 'TB'], number = parseFloat(human.substr(0, human.length - 2));
    return formats.indexOf(format) !== -1
        ? number * Math.pow(1024, formats.indexOf(format) + 1)
        : parseInt(human, 10);
};

// CONCATENATED MODULE: ./src/modules/helpers/buildQuery.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const buildQuery = (data, prefix) => {
    const str = [];
    const enc = encodeURIComponent;
    for (const dataKey in data) {
        if (data.hasOwnProperty(dataKey)) {
            const k = prefix ? prefix + '[' + dataKey + ']' : dataKey;
            const v = data[dataKey];
            str.push(isPlainObject(v) ? buildQuery(v, k) : enc(k) + '=' + enc(v));
        }
    }
    return str.join('&');
};

// CONCATENATED MODULE: ./src/modules/helpers/scrollIntoView.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const inView = (elm, root, doc) => {
    let rect = elm.getBoundingClientRect(), el = elm;
    const top = rect.top, height = rect.height;
    do {
        if (el && el.parentNode) {
            el = el.parentNode;
            rect = el.getBoundingClientRect();
            if (!(top <= rect.bottom)) {
                return false;
            }
            if (top + height <= rect.top) {
                return false;
            }
        }
    } while (el && el !== root && el.parentNode);
    return (top <= ((doc.documentElement && doc.documentElement.clientHeight) || 0));
};
const scrollIntoView = (elm, root, doc) => {
    if (!inView(elm, root, doc)) {
        if (root.clientHeight !== root.scrollHeight) {
            root.scrollTop = elm.offsetTop;
        }
        if (!inView(elm, root, doc)) {
            elm.scrollIntoView();
        }
    }
};

// CONCATENATED MODULE: ./src/modules/helpers/val.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const val_val = (elm, selector, value) => {
    const child = elm.querySelector(selector);
    if (!child) {
        return '';
    }
    if (value) {
        child.value = value;
    }
    return child.value;
};

// CONCATENATED MODULE: ./src/modules/helpers/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




























// CONCATENATED MODULE: ./src/modules/Dom.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license;
 * Copyright 2013-2020 Valeriy Chupurnov https://xdsoft.net
 */



class Dom_Dom {
    static detach(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }
    static unwrap(node) {
        const parent = node.parentNode, el = node;
        if (parent) {
            while (el.firstChild) {
                parent.insertBefore(el.firstChild, el);
            }
            Dom_Dom.safeRemove(el);
        }
    }
    static each(elm, callback) {
        let node = elm.firstChild;
        if (node) {
            while (node) {
                if (callback.call(node, node) === false ||
                    !Dom_Dom.each(node, callback)) {
                    return false;
                }
                node = Dom_Dom.next(node, nd => !!nd, elm);
            }
        }
        return true;
    }
    static replace(elm, newTagName, withAttributes = false, notMoveContent = false, create) {
        const tag = typeof newTagName === 'string'
            ? create.element(newTagName)
            : newTagName;
        if (!notMoveContent) {
            while (elm.firstChild) {
                tag.appendChild(elm.firstChild);
            }
        }
        if (withAttributes) {
            Array.from(elm.attributes).forEach(attr => {
                tag.setAttribute(attr.name, attr.value);
            });
        }
        if (elm.parentNode) {
            elm.parentNode.replaceChild(tag, elm);
        }
        return tag;
    }
    static isEmptyTextNode(node) {
        return (node &&
            node.nodeType === Node.TEXT_NODE &&
            (!node.nodeValue ||
                node.nodeValue.replace(INVISIBLE_SPACE_REG_EXP, '')
                    .length === 0));
    }
    static isEmpty(node, condNoEmptyElement = /^(img|svg|canvas|input|textarea|form)$/) {
        if (!node) {
            return true;
        }
        if (node.nodeType === Node.TEXT_NODE) {
            return node.nodeValue === null || trim(node.nodeValue).length === 0;
        }
        return (!node.nodeName.toLowerCase().match(condNoEmptyElement) &&
            Dom_Dom.each(node, (elm) => {
                if ((elm &&
                    elm.nodeType === Node.TEXT_NODE &&
                    elm.nodeValue !== null &&
                    trim(elm.nodeValue).length !== 0) ||
                    (elm &&
                        elm.nodeType === Node.ELEMENT_NODE &&
                        condNoEmptyElement.test(elm.nodeName.toLowerCase()))) {
                    return false;
                }
            }));
    }
    static isNode(object, win) {
        if (typeof win === 'object' &&
            win &&
            (typeof win.Node === 'function' ||
                typeof win.Node === 'object')) {
            return object instanceof win.Node;
        }
        return false;
    }
    static isCell(elm, win) {
        return Dom_Dom.isNode(elm, win) && /^(td|th)$/i.test(elm.nodeName);
    }
    static isImage(elm, win) {
        return (Dom_Dom.isNode(elm, win) &&
            /^(img|svg|picture|canvas)$/i.test(elm.nodeName));
    }
    static isBlock(node, win) {
        return (node &&
            typeof node === 'object' &&
            Dom_Dom.isNode(node, win) &&
            IS_BLOCK.test(node.nodeName));
    }
    static isInlineBlock(node) {
        return (!!node &&
            node.nodeType === Node.ELEMENT_NODE &&
            ['inline', 'inline-block'].indexOf(css_css(node, 'display').toString()) !== -1);
    }
    static canSplitBlock(node, win) {
        return (node &&
            node instanceof win.HTMLElement &&
            this.isBlock(node, win) &&
            !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
            node.style !== undefined &&
            !/^(fixed|absolute)/i.test(node.style.position));
    }
    static prev(node, condition, root, withChild = true) {
        return Dom_Dom.find(node, condition, root, false, 'previousSibling', withChild ? 'lastChild' : false);
    }
    static next(node, condition, root, withChild = true) {
        return Dom_Dom.find(node, condition, root, undefined, undefined, withChild ? 'firstChild' : '');
    }
    static prevWithClass(node, className) {
        return this.prev(node, node => {
            return (node &&
                node.nodeType === Node.ELEMENT_NODE &&
                node.classList.contains(className));
        }, node.parentNode);
    }
    static nextWithClass(node, className) {
        return this.next(node, node => {
            return (node &&
                node.nodeType === Node.ELEMENT_NODE &&
                node.classList.contains(className));
        }, node.parentNode);
    }
    static find(node, condition, root, recurse = false, sibling = 'nextSibling', child = 'firstChild') {
        if (recurse && condition(node)) {
            return node;
        }
        let start = node, next;
        do {
            next = start[sibling];
            if (condition(next)) {
                return next ? next : false;
            }
            if (child && next && next[child]) {
                const nextOne = Dom_Dom.find(next[child], condition, next, true, sibling, child);
                if (nextOne) {
                    return nextOne;
                }
            }
            if (!next) {
                next = start.parentNode;
            }
            start = next;
        } while (start && start !== root);
        return false;
    }
    static findWithCurrent(node, condition, root, sibling = 'nextSibling', child = 'firstChild') {
        let next = node;
        do {
            if (condition(next)) {
                return next ? next : false;
            }
            if (child && next && next[child]) {
                const nextOne = Dom_Dom.findWithCurrent(next[child], condition, next, sibling, child);
                if (nextOne) {
                    return nextOne;
                }
            }
            while (next && !next[sibling] && next !== root) {
                next = next.parentNode;
            }
            if (next && next[sibling] && next !== root) {
                next = next[sibling];
            }
        } while (next && next !== root);
        return false;
    }
    static up(node, condition, root) {
        let start = node;
        if (!node) {
            return false;
        }
        do {
            if (condition(start)) {
                return start;
            }
            if (start === root || !start.parentNode) {
                break;
            }
            start = start.parentNode;
        } while (start && start !== root);
        return false;
    }
    static closest(node, tags, root) {
        let condition;
        if (typeof tags === 'function') {
            condition = tags;
        }
        else if (tags instanceof RegExp) {
            condition = (tag) => tag && tags.test(tag.nodeName);
        }
        else {
            condition = (tag) => tag && new RegExp('^(' + tags + ')$', 'i').test(tag.nodeName);
        }
        return Dom_Dom.up(node, condition, root);
    }
    static appendChildFirst(root, newElement) {
        const child = root.firstChild;
        if (child) {
            root.insertBefore(newElement, child);
        }
        else {
            root.appendChild(newElement);
        }
    }
    static after(elm, newElement) {
        const parentNode = elm.parentNode;
        if (!parentNode) {
            return;
        }
        if (parentNode.lastChild === elm) {
            parentNode.appendChild(newElement);
        }
        else {
            parentNode.insertBefore(newElement, elm.nextSibling);
        }
    }
    static moveContent(from, to, inStart = false) {
        const fragment = (from.ownerDocument || document).createDocumentFragment();
        [].slice.call(from.childNodes).forEach((node) => {
            if (node.nodeType !== Node.TEXT_NODE ||
                node.nodeValue !== INVISIBLE_SPACE) {
                fragment.appendChild(node);
            }
        });
        if (!inStart || !to.firstChild) {
            to.appendChild(fragment);
        }
        else {
            to.insertBefore(fragment, to.firstChild);
        }
    }
    static all(node, condition, prev = false) {
        let nodes = node.childNodes
            ? Array.prototype.slice.call(node.childNodes)
            : [];
        if (condition(node)) {
            return node;
        }
        if (prev) {
            nodes = nodes.reverse();
        }
        nodes.forEach(child => {
            Dom_Dom.all(child, condition, prev);
        });
    }
    static safeRemove(node) {
        node && node.parentNode && node.parentNode.removeChild(node);
    }
    static toggleAttribute(elm, attr, enable) {
        if (enable !== false) {
            elm.setAttribute(attr, enable.toString());
        }
        else {
            elm.removeAttribute(attr);
        }
    }
    static hide(node) {
        if (!node) {
            return;
        }
        dataBind(node, '__old_display', node.style.display);
        node.style.display = 'none';
    }
    static show(node) {
        if (!node) {
            return;
        }
        const display = dataBind(node, '__old_display');
        if (node.style.display === 'none') {
            node.style.display = display || '';
        }
    }
}
Dom_Dom.wrapInline = (current, tag, editor) => {
    let tmp, first = current, last = current;
    const selInfo = editor.selection.save();
    let needFindNext = false;
    do {
        needFindNext = false;
        tmp = first.previousSibling;
        if (tmp && !Dom_Dom.isBlock(tmp, editor.editorWindow)) {
            needFindNext = true;
            first = tmp;
        }
    } while (needFindNext);
    do {
        needFindNext = false;
        tmp = last.nextSibling;
        if (tmp && !Dom_Dom.isBlock(tmp, editor.editorWindow)) {
            needFindNext = true;
            last = tmp;
        }
    } while (needFindNext);
    const wrapper = typeof tag === 'string' ? editor.create.inside.element(tag) : tag;
    if (first.parentNode) {
        first.parentNode.insertBefore(wrapper, first);
    }
    let next = first;
    while (next) {
        next = first.nextSibling;
        wrapper.appendChild(first);
        if (first === last || !next) {
            break;
        }
        first = next;
    }
    editor.selection.restore(selInfo);
    return wrapper;
};
Dom_Dom.wrap = (current, tag, editor) => {
    const selInfo = editor.selection.save();
    const wrapper = typeof tag === 'string' ? editor.create.inside.element(tag) : tag;
    if (!current.parentNode) {
        return null;
    }
    current.parentNode.insertBefore(wrapper, current);
    wrapper.appendChild(current);
    editor.selection.restore(selInfo);
    return wrapper;
};
Dom_Dom.findInline = (node, toLeft, root) => {
    let prevElement = node, nextElement = null;
    do {
        if (prevElement) {
            nextElement = toLeft
                ? prevElement.previousSibling
                : prevElement.nextSibling;
            if (!nextElement &&
                prevElement.parentNode &&
                prevElement.parentNode !== root &&
                Dom_Dom.isInlineBlock(prevElement.parentNode)) {
                prevElement = prevElement.parentNode;
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    } while (!nextElement);
    while (nextElement &&
        Dom_Dom.isInlineBlock(nextElement) &&
        (!toLeft ? nextElement.firstChild : nextElement.lastChild)) {
        nextElement = !toLeft
            ? nextElement.firstChild
            : nextElement.lastChild;
    }
    return nextElement;
};
Dom_Dom.contains = (root, child) => {
    while (child.parentNode) {
        if (child.parentNode === root) {
            return true;
        }
        child = child.parentNode;
    }
    return false;
};
Dom_Dom.isOrContains = (root, child, onlyContains = false) => {
    return (child &&
        root &&
        ((root === child && !onlyContains) || Dom_Dom.contains(root, child)));
};

// CONCATENATED MODULE: ./src/modules/toolbar/icon.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
class ToolbarIcon {
    static get(name) {
        return ToolbarIcon.icons[name] ||
            ToolbarIcon.icons[name.replace(/-/g, '_')] ||
            ToolbarIcon.icons[name.toLowerCase()];
    }
    static exists(name) {
        return this.get(name) !== undefined;
    }
    static getIcon(name, defaultValue = '<span></span>') {
        return this.get(name) || defaultValue;
    }
    static setIcon(name, value) {
        this.icons[name.replace('_', '-')] = value;
    }
}
ToolbarIcon.icons = {};

// CONCATENATED MODULE: ./src/modules/Widget.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



var Widget_Widget;
(function (Widget) {
    Widget.ColorPickerWidget = (editor, callback, coldColor) => {
        const valueHex = normalizeColor(coldColor), form = editor.create.div('jodit_colorpicker'), iconEye = editor.options.textIcons
            ? ''
            : ToolbarIcon.getIcon('eye'), iconEraser = editor.options.textIcons
            ? `<span>${editor.i18n('eraser')}</span>`
            : ToolbarIcon.getIcon('eraser'), iconPalette = editor.options.textIcons
            ? `<span>${editor.i18n('palette')}</span>`
            : ToolbarIcon.getIcon('palette'), setColor = (target, color) => {
            target.innerHTML = ToolbarIcon.getIcon('eye');
            target.classList.add('active');
            const colorRGB = hexToRgb(color);
            if (colorRGB) {
                target.firstChild.style.fill =
                    'rgb(' +
                        (255 - colorRGB.r) +
                        ',' +
                        (255 - colorRGB.g) +
                        ',' +
                        (255 - colorRGB.b) +
                        ')';
            }
        }, eachColor = (colors) => {
            const stack = [];
            if (isPlainObject(colors)) {
                Object.keys(colors).forEach(key => {
                    stack.push('<div class="jodit_colorpicker_group jodit_colorpicker_group-' +
                        key +
                        '">');
                    stack.push(eachColor(colors[key]));
                    stack.push('</div>');
                });
            }
            else if (Array.isArray(colors)) {
                colors.forEach(color => {
                    stack.push('<a ' +
                        (valueHex === color ? ' class="active" ' : '') +
                        ' title="' +
                        color +
                        '" style="background-color:' +
                        color +
                        '" data-color="' +
                        color +
                        '" href="javascript:void(0)">' +
                        (valueHex === color ? iconEye : '') +
                        '</a>');
                });
            }
            return stack.join('');
        };
        form.appendChild(editor.create.fromHTML('<div>' + eachColor(editor.options.colors) + '</div>'));
        form.appendChild(editor.create.fromHTML('<a ' +
            (editor.options.textIcons
                ? 'class="jodit_text_icon"'
                : '') +
            ' data-color="" href="javascript:void(0)">' +
            iconEraser +
            '</a>'));
        if (editor.options.showBrowserColorPicker && hasBrowserColorPicker()) {
            form.appendChild(editor.create.fromHTML('<span>' +
                '<em ' +
                (editor.options.textIcons
                    ? 'class="jodit_text_icon"'
                    : '') +
                '>' +
                iconPalette +
                '</em>' +
                '<input type="color" value=""/>' +
                '</span>'));
            editor.events.on(form, 'change', (e) => {
                e.stopPropagation();
                let target = e.target;
                if (!target ||
                    !target.tagName ||
                    target.tagName.toUpperCase() !== 'INPUT') {
                    return;
                }
                const color = target.value || '';
                if (color) {
                    setColor(target, color);
                }
                if (callback && typeof callback === 'function') {
                    callback(color);
                }
                e.preventDefault();
            });
        }
        editor.events.on(form, 'mousedown touchend', (e) => {
            e.stopPropagation();
            let target = e.target;
            if ((!target ||
                !target.tagName ||
                target.tagName.toUpperCase() === 'SVG' ||
                target.tagName.toUpperCase() === 'PATH') &&
                target.parentNode) {
                target = Dom_Dom.closest(target.parentNode, 'A', editor.editor);
            }
            if (target.tagName.toUpperCase() !== 'A') {
                return;
            }
            const active = form.querySelector('a.active');
            if (active) {
                active.classList.remove('active');
                active.innerHTML = '';
            }
            const color = target.getAttribute('data-color') || '';
            if (color) {
                setColor(target, color);
            }
            if (callback && typeof callback === 'function') {
                callback(color);
            }
            e.preventDefault();
        });
        return form;
    };
    Widget.TabsWidget = (editor, tabs, state) => {
        const box = editor.create.div('jodit_tabs'), tabBox = editor.create.div('jodit_tabs_wrapper'), buttons = editor.create.div('jodit_tabs_buttons'), nameToTab = {};
        let firstTab = '', tabcount = 0;
        box.appendChild(buttons);
        box.appendChild(tabBox);
        each(tabs, (name, tabOptions) => {
            const tab = editor.create.div('jodit_tab'), button = editor.create.element('a', {
                href: 'javascript:void(0);'
            });
            if (!firstTab) {
                firstTab = name.toString();
            }
            button.innerHTML = /<svg/.test(name.toString())
                ? name
                : editor.i18n(name.toString());
            buttons.appendChild(button);
            if (typeof tabOptions !== 'function') {
                tab.appendChild(tabOptions);
            }
            else {
                tab.appendChild(editor.create.div('jodit_tab_empty'));
            }
            tabBox.appendChild(tab);
            editor.events.on(button, 'mousedown touchend', (e) => {
                $$('a', buttons).forEach(a => {
                    a.classList.remove('active');
                });
                $$('.jodit_tab', tabBox).forEach(a => {
                    a.classList.remove('active');
                });
                button.classList.add('active');
                tab.classList.add('active');
                if (typeof tabOptions === 'function') {
                    tabOptions.call(editor);
                }
                e.stopPropagation();
                if (state) {
                    state.__activeTab = name.toString();
                }
                return false;
            });
            nameToTab[name] = {
                button,
                tab
            };
            tabcount += 1;
        });
        if (!tabcount) {
            return box;
        }
        $$('a', buttons).forEach(a => {
            a.style.width = (100 / tabcount).toFixed(10) + '%';
        });
        if (!state || !state.__activeTab || !nameToTab[state.__activeTab]) {
            nameToTab[firstTab].button.classList.add('active');
            nameToTab[firstTab].tab.classList.add('active');
        }
        else {
            nameToTab[state.__activeTab].button.classList.add('active');
            nameToTab[state.__activeTab].tab.classList.add('active');
        }
        return box;
    };
    Widget.FileSelectorWidget = (editor, callbacks, elm, close, isImage = true) => {
        let currentImage;
        const tabs = {};
        if (callbacks.upload &&
            editor.options.uploader &&
            (editor.options.uploader.url ||
                editor.options.uploader.insertImageAsBase64URI)) {
            const dragbox = editor.create.fromHTML('<div class="jodit_draganddrop_file_box">' +
                `<strong>${editor.i18n(isImage ? 'Drop image' : 'Drop file')}</strong>` +
                `<span><br>${editor.i18n('or click')}</span>` +
                `<input type="file" accept="${isImage ? 'image/*' : '*'}" tabindex="-1" dir="auto" multiple=""/>` +
                '</div>');
            editor.getInstance('Uploader').bind(dragbox, (resp) => {
                let handler = isFunction(callbacks.upload) ? callbacks.upload : editor.options.uploader.defaultHandlerSuccess;
                if (typeof handler === 'function') {
                    handler.call(editor, resp);
                }
            }, (error) => {
                editor.events.fire('errorMessage', error.message);
            });
            const icon = editor.options.textIcons
                ? ''
                : ToolbarIcon.getIcon('upload');
            tabs[icon + editor.i18n('Upload')] = dragbox;
        }
        if (callbacks.filebrowser) {
            if (editor.options.filebrowser.ajax.url ||
                editor.options.filebrowser.items.url) {
                const icon = editor.options.textIcons
                    ? ''
                    : ToolbarIcon.getIcon('folder');
                tabs[icon + editor.i18n('Browse')] = () => {
                    close && close();
                    if (callbacks.filebrowser) {
                        editor.getInstance('FileBrowser').open(callbacks.filebrowser, isImage);
                    }
                };
            }
        }
        if (callbacks.url) {
            const form = editor.create.fromHTML(`<form onsubmit="return false;" class="jodit_form">
						<div class="jodit_form_group">
							<input class="jodit_input" type="text" required name="url" placeholder="http://"/>
						</div>
						<div class="jodit_form_group">
							<input class="jodit_input" type="text" name="text" placeholder="${editor.i18n('Alternative text')}"/>
						</div>
						<div style="text-align: right"><button class="jodit_button">${editor.i18n('Insert')}</button></div>
					</form>`), button = form.querySelector('button'), url = form.querySelector('input[name=url]');
            currentImage = null;
            if (elm &&
                elm.nodeType !== Node.TEXT_NODE &&
                (elm.tagName === 'IMG' || $$('img', elm).length)) {
                currentImage = elm.tagName === 'IMG' ? elm : $$('img', elm)[0];
                val_val(form, 'input[name=url]', currentImage.getAttribute('src'));
                val_val(form, 'input[name=text]', currentImage.getAttribute('alt'));
                button.textContent = editor.i18n('Update');
            }
            if (elm &&
                elm.nodeType !== Node.TEXT_NODE &&
                elm.nodeName === 'A') {
                val_val(form, 'input[name=url]', elm.getAttribute('href') || '');
                val_val(form, 'input[name=text]', elm.getAttribute('title') || '');
                button.textContent = editor.i18n('Update');
            }
            form.addEventListener('submit', (event) => {
                event.preventDefault();
                event.stopPropagation();
                if (!val_val(form, 'input[name=url]')) {
                    url.focus();
                    url.classList.add('jodit_error');
                    return false;
                }
                if (typeof callbacks.url === 'function') {
                    callbacks.url.call(editor, val_val(form, 'input[name=url]'), val_val(form, 'input[name=text]'));
                }
                return false;
            }, false);
            const icon = editor.options.textIcons
                ? ''
                : ToolbarIcon.getIcon('link');
            tabs[icon + ' URL'] = form;
        }
        return Widget.TabsWidget(editor, tabs);
    };
})(Widget_Widget || (Widget_Widget = {}));

// CONCATENATED MODULE: ./src/Config.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


var TabsWidget = Widget_Widget.TabsWidget;
var FileSelectorWidget = Widget_Widget.FileSelectorWidget;




class Config_Config {
    constructor() {
        this.iframe = false;
        this.license = '';
        this.preset = 'custom';
        this.presets = {
            inline: {
                inline: true,
                toolbar: false,
                toolbarInline: true,
                popup: {
                    selection: [
                        'bold',
                        'underline',
                        'italic',
                        'ul',
                        'ol',
                        'outdent',
                        'indent',
                        '\n',
                        'fontsize',
                        'brush',
                        'paragraph',
                        'link',
                        'align',
                        'cut',
                        'dots'
                    ]
                },
                showXPathInStatusbar: false,
                showCharsCounter: false,
                showWordsCounter: false,
                showPlaceholder: false
            }
        };
        this.ownerDocument = (typeof document !== 'undefined'
            ? document
            : null);
        this.ownerWindow = (typeof window !== 'undefined'
            ? window
            : null);
        this.zIndex = 0;
        this.readonly = false;
        this.disabled = false;
        this.activeButtonsInReadOnly = [
            'source',
            'fullsize',
            'print',
            'about',
            'dots',
            'selectall'
        ];
        this.toolbarButtonSize = 'middle';
        this.allowTabNavigation = false;
        this.inline = false;
        this.theme = 'default';
        this.saveModeInStorage = false;
        this.saveHeightInStorage = false;
        this.spellcheck = true;
        this.editorCssClass = false;
        this.style = false;
        this.triggerChangeEvent = true;
        this.width = 'auto';
        this.minWidth = '200px';
        this.maxWidth = '100%';
        this.height = 'auto';
        this.minHeight = 200;
        this.direction = '';
        this.language = 'auto';
        this.debugLanguage = false;
        this.i18n = false;
        this.tabIndex = -1;
        this.toolbar = true;
        this.showTooltip = true;
        this.showTooltipDelay = 300;
        this.useNativeTooltip = false;
        this.enter = PARAGRAPH;
        this.enterBlock = PARAGRAPH;
        this.defaultMode = MODE_WYSIWYG;
        this.useSplitMode = false;
        this.colors = {
            greyscale: [
                '#000000',
                '#434343',
                '#666666',
                '#999999',
                '#B7B7B7',
                '#CCCCCC',
                '#D9D9D9',
                '#EFEFEF',
                '#F3F3F3',
                '#FFFFFF'
            ],
            palette: [
                '#980000',
                '#FF0000',
                '#FF9900',
                '#FFFF00',
                '#00F0F0',
                '#00FFFF',
                '#4A86E8',
                '#0000FF',
                '#9900FF',
                '#FF00FF'
            ],
            full: [
                '#E6B8AF',
                '#F4CCCC',
                '#FCE5CD',
                '#FFF2CC',
                '#D9EAD3',
                '#D0E0E3',
                '#C9DAF8',
                '#CFE2F3',
                '#D9D2E9',
                '#EAD1DC',
                '#DD7E6B',
                '#EA9999',
                '#F9CB9C',
                '#FFE599',
                '#B6D7A8',
                '#A2C4C9',
                '#A4C2F4',
                '#9FC5E8',
                '#B4A7D6',
                '#D5A6BD',
                '#CC4125',
                '#E06666',
                '#F6B26B',
                '#FFD966',
                '#93C47D',
                '#76A5AF',
                '#6D9EEB',
                '#6FA8DC',
                '#8E7CC3',
                '#C27BA0',
                '#A61C00',
                '#CC0000',
                '#E69138',
                '#F1C232',
                '#6AA84F',
                '#45818E',
                '#3C78D8',
                '#3D85C6',
                '#674EA7',
                '#A64D79',
                '#85200C',
                '#990000',
                '#B45F06',
                '#BF9000',
                '#38761D',
                '#134F5C',
                '#1155CC',
                '#0B5394',
                '#351C75',
                '#733554',
                '#5B0F00',
                '#660000',
                '#783F04',
                '#7F6000',
                '#274E13',
                '#0C343D',
                '#1C4587',
                '#073763',
                '#20124D',
                '#4C1130'
            ]
        };
        this.colorPickerDefaultTab = 'background';
        this.imageDefaultWidth = 300;
        this.removeButtons = [];
        this.disablePlugins = [];
        this.extraPlugins = [];
        this.extraButtons = [];
        this.createAttributes = {};
        this.sizeLG = 900;
        this.sizeMD = 700;
        this.sizeSM = 400;
        this.buttons = [
            'source',
            '|',
            'bold',
            'strikethrough',
            'underline',
            'italic',
            '|',
            'superscript',
            'subscript',
            '|',
            'ul',
            'ol',
            '|',
            'outdent',
            'indent',
            '|',
            'font',
            'fontsize',
            'brush',
            'paragraph',
            '|',
            'image',
            'file',
            'video',
            'table',
            'link',
            '|',
            'align',
            'undo',
            'redo',
            '\n',
            'selectall',
            'cut',
            'copy',
            'paste',
            'eraser',
            'copyformat',
            '|',
            'hr',
            'symbol',
            'fullsize',
            'print',
            'about'
        ];
        this.buttonsMD = [
            'source',
            '|',
            'bold',
            'italic',
            '|',
            'ul',
            'ol',
            '|',
            'font',
            'fontsize',
            'brush',
            'paragraph',
            '|',
            'image',
            'table',
            'link',
            '|',
            'align',
            '|',
            'undo',
            'redo',
            '|',
            'hr',
            'eraser',
            'copyformat',
            'fullsize',
            'dots'
        ];
        this.buttonsSM = [
            'source',
            '|',
            'bold',
            'italic',
            '|',
            'ul',
            'ol',
            '|',
            'fontsize',
            'brush',
            'paragraph',
            '|',
            'image',
            'table',
            'link',
            '|',
            'align',
            '|',
            'undo',
            'redo',
            '|',
            'eraser',
            'copyformat',
            'fullsize',
            'dots'
        ];
        this.buttonsXS = [
            'bold',
            'image',
            '|',
            'brush',
            'paragraph',
            '|',
            'align',
            '|',
            'undo',
            'redo',
            '|',
            'eraser',
            'dots'
        ];
        this.events = {};
        this.textIcons = false;
        this.showBrowserColorPicker = false;
    }
    static get defaultOptions() {
        if (!Config_Config.__defaultOptions) {
            Config_Config.__defaultOptions = new Config_Config();
        }
        return Config_Config.__defaultOptions;
    }
}
const OptionsDefault = function (options, def = Config_Config.defaultOptions) {
    const self = this;
    self.plainOptions = options;
    if (options !== undefined && typeof options === 'object') {
        const extendKey = (opt, key) => {
            if (key === 'preset') {
                if (def.presets[opt.preset] !== undefined) {
                    const preset = def.presets[opt.preset];
                    Object.keys(preset).forEach(extendKey.bind(this, preset));
                }
            }
            const defValue = def[key], isObject = typeof defValue === 'object' && defValue !== null;
            if (isObject &&
                !['ownerWindow', 'ownerDocument'].includes(key) &&
                !Array.isArray(defValue)) {
                self[key] = extend(true, {}, defValue, opt[key]);
            }
            else {
                self[key] = opt[key];
            }
        };
        Object.keys(options).forEach(extendKey.bind(this, options));
    }
};
Config_Config.prototype.controls = {
    print: {
        exec: (editor) => {
            const mywindow = window.open('', 'PRINT');
            if (mywindow) {
                if (editor.options.iframe) {
                    editor.events.fire('generateDocumentStructure.iframe', mywindow.document, editor);
                    mywindow.document.body.innerHTML = editor.value;
                }
                else {
                    mywindow.document.write('<!doctype html><html lang="' +
                        defaultLanguage_defaultLanguage(editor.options.language) +
                        '"><head><title></title></head>' +
                        '<body>' +
                        editor.value +
                        '</body></html>');
                    mywindow.document.close();
                }
                mywindow.focus();
                mywindow.print();
                mywindow.close();
            }
        },
        mode: MODE_SOURCE + MODE_WYSIWYG,
        tooltip: 'Print'
    },
    about: {
        exec: (editor) => {
            const dialog = editor.getInstance('Dialog');
            dialog.setTitle(editor.i18n('About Jodit'));
            dialog.setContent('<div class="jodit_about">\
										<div>' +
                editor.i18n('Jodit Editor') +
                ' v.' +
                editor.getVersion() +
                ' ' +
                '</div>' +
                '<div>' +
                editor.i18n('License: %s', !isLicense(editor.options.license)
                    ? editor.i18n('GNU General Public License, version 2 or later')
                    : normalizeLicense(editor.options.license)) +
                '</div>' +
                '<div>' +
                '<a href="https://xdsoft.net/jodit/" target="_blank">http://xdsoft.net/jodit/</a>' +
                '</div>' +
                '<div>' +
                '<a href="https://xdsoft.net/jodit/doc/" target="_blank">' +
                editor.i18n("Jodit User's Guide") +
                '</a> ' +
                editor.i18n('contains detailed help for using') +
                '</div>' +
                '<div>' +
                editor.i18n('Copyright Â© XDSoft.net - Chupurnov Valeriy. All rights reserved.') +
                '</div>' +
                '</div>');
            dialog.open();
        },
        tooltip: 'About Jodit',
        mode: MODE_SOURCE + MODE_WYSIWYG
    },
    hr: {
        command: 'insertHorizontalRule',
        tags: ['hr'],
        tooltip: 'Insert Horizontal Line'
    },
    image: {
        popup: (editor, current, self, close) => {
            let sourceImage = null;
            if (current &&
                current.nodeType !== Node.TEXT_NODE &&
                (current.tagName === 'IMG' || $$('img', current).length)) {
                sourceImage =
                    current.tagName === 'IMG'
                        ? current
                        : $$('img', current)[0];
            }
            const selInfo = editor.selection.save();
            return FileSelectorWidget(editor, {
                filebrowser: async (data) => {
                    editor.selection.restore(selInfo);
                    if (data.files && data.files.length) {
                        for (let i = 0; i < data.files.length; i += 1) {
                            await editor.selection.insertImage(data.baseurl + data.files[i], null, editor.options.imageDefaultWidth);
                        }
                    }
                    close();
                },
                upload: true,
                url: async (url, text) => {
                    editor.selection.restore(selInfo);
                    const image = sourceImage || editor.create.inside.element('img');
                    image.setAttribute('src', url);
                    image.setAttribute('alt', text);
                    if (!sourceImage) {
                        await editor.selection.insertImage(image, null, editor.options.imageDefaultWidth);
                    }
                    close();
                }
            }, sourceImage, close);
        },
        tags: ['img'],
        tooltip: 'Insert Image'
    },
    file: {
        popup: (editor, current, self, close) => {
            const insert = (url, title = '') => {
                editor.selection.insertNode(editor.create.inside.fromHTML('<a href="' +
                    url +
                    '" title="' +
                    title +
                    '">' +
                    (title || url) +
                    '</a>'));
            };
            let sourceAnchor = null;
            if (current &&
                (current.nodeName === 'A' ||
                    Dom_Dom.closest(current, 'A', editor.editor))) {
                sourceAnchor =
                    current.nodeName === 'A'
                        ? current
                        : Dom_Dom.closest(current, 'A', editor.editor);
            }
            return FileSelectorWidget(editor, {
                filebrowser: (data) => {
                    if (data.files && data.files.length) {
                        let i;
                        for (i = 0; i < data.files.length; i += 1) {
                            insert(data.baseurl + data.files[i]);
                        }
                    }
                    close();
                },
                upload: true,
                url: (url, text) => {
                    if (sourceAnchor) {
                        sourceAnchor.setAttribute('href', url);
                        sourceAnchor.setAttribute('title', text);
                    }
                    else {
                        insert(url, text);
                    }
                    close();
                }
            }, sourceAnchor, close, false);
        },
        tags: ['a'],
        tooltip: 'Insert file'
    },
    video: {
        popup: (editor, current, control, close) => {
            const bylink = editor.create.fromHTML(`<form class="jodit_form">
					<div class="jodit jodit_form_group">
						<input class="jodit_input" required name="code" placeholder="http://" type="url"/>
						<button class="jodit_button" type="submit">${editor.i18n('Insert')}</button>
					</div>
				</form>`), bycode = editor.create.fromHTML(`<form class="jodit_form">
									<div class="jodit_form_group">
										<textarea class="jodit_textarea" required name="code" placeholder="${editor.i18n('Embed code')}"></textarea>
										<button class="jodit_button" type="submit">${editor.i18n('Insert')}</button>
									</div>
								</form>`), tab = {}, selinfo = editor.selection.save(), insertCode = (code) => {
                editor.selection.restore(selinfo);
                editor.selection.insertHTML(code);
                close();
            };
            if (editor.options.textIcons) {
                tab[editor.i18n('Link')] = bylink;
                tab[editor.i18n('Code')] = bycode;
            }
            else {
                tab[ToolbarIcon.getIcon('link') + '&nbsp;' + editor.i18n('Link')] = bylink;
                tab[ToolbarIcon.getIcon('source') +
                    '&nbsp;' +
                    editor.i18n('Code')] = bycode;
            }
            bycode.addEventListener('submit', event => {
                event.preventDefault();
                if (!trim(val_val(bycode, 'textarea[name=code]'))) {
                    bycode.querySelector('textarea[name=code]').focus();
                    bycode.querySelector('textarea[name=code]').classList.add('jodit_error');
                    return false;
                }
                insertCode(val_val(bycode, 'textarea[name=code]'));
                return false;
            });
            bylink.addEventListener('submit', event => {
                event.preventDefault();
                if (!isURL(val_val(bylink, 'input[name=code]'))) {
                    bylink.querySelector('input[name=code]').focus();
                    bylink.querySelector('input[name=code]').classList.add('jodit_error');
                    return false;
                }
                insertCode(convertMediaURLToVideoEmbed(val_val(bylink, 'input[name=code]')));
                return false;
            });
            return TabsWidget(editor, tab);
        },
        tags: ['iframe'],
        tooltip: 'Insert youtube/vimeo video'
    }
};

// CONCATENATED MODULE: ./src/modules/Component.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const STATUSES = {
    beforeInit: 0,
    ready: 1,
    beforeDestruct: 2,
    destructed: 3
};
class Component_Component {
    constructor(jodit) {
        this.__componentStatus = STATUSES.beforeInit;
        if (jodit && jodit instanceof Component_Component) {
            this.jodit = jodit;
            if (isJoditObject(jodit)) {
                jodit.components.add(this);
            }
        }
    }
    get componentStatus() {
        return this.__componentStatus;
    }
    set componentStatus(componentStatus) {
        this.__componentStatus = componentStatus;
    }
    setStatus(componentStatus) {
        this.__componentStatus = componentStatus;
    }
    get isReady() {
        return this.componentStatus === STATUSES.ready;
    }
    get isDestructed() {
        return this.componentStatus === STATUSES.destructed;
    }
    get isInDestruct() {
        return [STATUSES.beforeDestruct, STATUSES.destructed].includes(this.componentStatus);
    }
    destruct() {
        this.setStatus(STATUSES.beforeDestruct);
        if (isJoditObject(this.jodit)) {
            this.jodit.components.delete(this);
        }
        if (this.jodit) {
            this.jodit = undefined;
        }
        this.setStatus(STATUSES.destructed);
    }
}

// CONCATENATED MODULE: ./src/modules/Snapshot.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


class Snapshot_Snapshot extends Component_Component {
    constructor() {
        super(...arguments);
        this.isBlocked = false;
    }
    static equal(first, second) {
        return (first.html === second.html &&
            JSON.stringify(first.range) === JSON.stringify(second.range));
    }
    static countNodesBeforeInParent(elm) {
        if (!elm.parentNode) {
            return 0;
        }
        const elms = elm.parentNode.childNodes;
        let count = 0, last = null, j;
        for (j = 0; j < elms.length; j += 1) {
            if (last &&
                (!(elms[j].nodeType === Node.TEXT_NODE &&
                    elms[j].textContent === '') &&
                    !(last.nodeType === Node.TEXT_NODE &&
                        elms[j].nodeType === Node.TEXT_NODE))) {
                count += 1;
            }
            if (elms[j] === elm) {
                return count;
            }
            last = elms[j];
        }
        return 0;
    }
    static strokeOffset(elm, offset) {
        while (elm && elm.nodeType === Node.TEXT_NODE) {
            elm = elm.previousSibling;
            if (elm &&
                elm.nodeType === Node.TEXT_NODE &&
                elm.textContent !== null) {
                offset += elm.textContent.length;
            }
        }
        return offset;
    }
    calcHierarchyLadder(elm) {
        const counts = [];
        if (!elm ||
            !elm.parentNode ||
            !Dom_Dom.isOrContains(this.jodit.editor, elm)) {
            return [];
        }
        while (elm && elm !== this.jodit.editor) {
            if (elm) {
                counts.push(Snapshot_Snapshot.countNodesBeforeInParent(elm));
            }
            elm = elm.parentNode;
        }
        return counts.reverse();
    }
    getElementByLadder(ladder) {
        let n = this.jodit.editor, i;
        for (i = 0; n && i < ladder.length; i += 1) {
            n = n.childNodes[ladder[i]];
        }
        return n;
    }
    make() {
        const snapshot = {
            html: '',
            range: {
                startContainer: [],
                startOffset: 0,
                endContainer: [],
                endOffset: 0
            }
        };
        snapshot.html = this.jodit.getNativeEditorValue();
        const sel = this.jodit.selection.sel;
        if (sel && sel.rangeCount) {
            const range = sel.getRangeAt(0), startContainer = this.calcHierarchyLadder(range.startContainer), endContainer = this.calcHierarchyLadder(range.endContainer);
            let startOffset = Snapshot_Snapshot.strokeOffset(range.startContainer, range.startOffset), endOffset = Snapshot_Snapshot.strokeOffset(range.endContainer, range.endOffset);
            if (!startContainer.length &&
                range.startContainer !== this.jodit.editor) {
                startOffset = 0;
            }
            if (!endContainer.length &&
                range.endContainer !== this.jodit.editor) {
                endOffset = 0;
            }
            snapshot.range = {
                startContainer,
                startOffset,
                endContainer,
                endOffset
            };
        }
        return snapshot;
    }
    restore(snapshot) {
        this.isBlocked = true;
        this.jodit.setEditorValue(snapshot.html);
        try {
            if (snapshot.range) {
                const range = this.jodit.editorDocument.createRange();
                range.setStart(this.getElementByLadder(snapshot.range.startContainer), snapshot.range.startOffset);
                range.setEnd(this.getElementByLadder(snapshot.range.endContainer), snapshot.range.endOffset);
                this.jodit.selection.selectRange(range);
            }
        }
        catch (__ignore) {
            this.jodit.editor.lastChild && this.jodit.selection.setCursorAfter(this.jodit.editor.lastChild);
            if (false) {}
        }
        this.isBlocked = false;
    }
    destruct() {
        this.isBlocked = false;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/Stack.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
class Stack {
    constructor() {
        this.commands = [];
        this.stackPosition = -1;
    }
    clearRedo() {
        this.commands.length = this.stackPosition + 1;
    }
    clear() {
        this.commands.length = 0;
        this.stackPosition = -1;
    }
    push(command) {
        this.clearRedo();
        this.commands.push(command);
        this.stackPosition += 1;
    }
    undo() {
        if (this.canUndo()) {
            if (this.commands[this.stackPosition]) {
                this.commands[this.stackPosition].undo();
            }
            this.stackPosition -= 1;
            return true;
        }
        return false;
    }
    redo() {
        if (this.canRedo()) {
            this.stackPosition += 1;
            if (this.commands[this.stackPosition]) {
                this.commands[this.stackPosition].redo();
            }
            return true;
        }
        return false;
    }
    canUndo() {
        return this.stackPosition >= 0;
    }
    canRedo() {
        return this.stackPosition < this.commands.length - 1;
    }
}

// CONCATENATED MODULE: ./src/modules/observer/command.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
class Command {
    constructor(oldValue, newValue, observer) {
        this.observer = observer;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }
    undo() {
        this.observer.snapshot.restore(this.oldValue);
    }
    redo() {
        this.observer.snapshot.restore(this.newValue);
    }
}

// CONCATENATED MODULE: ./src/modules/observer/observer.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






Config_Config.prototype.observer = {
    timeout: 100
};
class observer_Observer extends Component_Component {
    constructor(editor) {
        super(editor);
        this.onChangeStack = () => {
            const newValue = this.snapshot.make();
            if (!Snapshot_Snapshot.equal(newValue, this.startValue)) {
                this.stack.push(new Command(this.startValue, newValue, this));
                this.startValue = newValue;
                this.changeStack();
            }
        };
        this.stack = new Stack();
        this.snapshot = new Snapshot_Snapshot(editor);
        const onChangeStack = debounce(this.onChangeStack, editor.defaultTimeout);
        editor.events.on('afterAddPlace.observer', () => {
            if (this.isInDestruct) {
                return;
            }
            this.startValue = this.snapshot.make();
            editor.events
                .on(editor.editor, [
                'changeSelection.observer',
                'selectionstart.observer',
                'selectionchange.observer',
                'mousedown.observer',
                'mouseup.observer',
                'keydown.observer',
                'keyup.observer'
            ].join(' '), () => {
                if (this.startValue.html ===
                    this.jodit.getNativeEditorValue()) {
                    this.startValue = this.snapshot.make();
                }
            })
                .on(this, 'change.observer', () => {
                if (!this.snapshot.isBlocked) {
                    onChangeStack();
                }
            });
        });
    }
    redo() {
        if (this.stack.redo()) {
            this.startValue = this.snapshot.make();
            this.changeStack();
        }
    }
    undo() {
        if (this.stack.undo()) {
            this.startValue = this.snapshot.make();
            this.changeStack();
        }
    }
    clear() {
        this.startValue = this.snapshot.make();
        this.stack.clear();
        this.changeStack();
    }
    changeStack() {
        var _a;
        this.jodit &&
            !this.jodit.isInDestruct && ((_a = this.jodit.events) === null || _a === void 0 ? void 0 : _a.fire('changeStack'));
    }
    destruct() {
        if (this.jodit.events) {
            this.jodit.events.off('.observer');
        }
        this.snapshot.destruct();
        delete this.snapshot;
        delete this.stack;
        delete this.startValue;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/Selection.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */










class Selection_Select {
    constructor(jodit) {
        this.jodit = jodit;
        this.isMarker = (elm) => Dom_Dom.isNode(elm, this.win) &&
            elm.nodeType === Node.ELEMENT_NODE &&
            elm.nodeName === 'SPAN' &&
            elm.hasAttribute('data-' + MARKER_CLASS);
        this.focus = () => {
            var _a, _b;
            if (!this.isFocused()) {
                if (this.jodit.iframe) {
                    if (this.doc.readyState == 'complete') {
                        this.jodit.iframe.focus();
                    }
                }
                this.win.focus();
                this.area.focus();
                const sel = this.sel, range = this.createRange();
                if (sel && (!sel.rangeCount || !this.current())) {
                    range.setStart(this.area, 0);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
                if (!this.jodit.editorIsActive) {
                    (_b = (_a = this.jodit) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.fire('focus');
                }
                return true;
            }
            return false;
        };
        this.eachSelection = (callback) => {
            const sel = this.sel;
            if (sel && sel.rangeCount) {
                const range = sel.getRangeAt(0);
                const nodes = [], startOffset = range.startOffset, length = this.area.childNodes.length, elementOffset = startOffset < length ? startOffset : length - 1, start = range.startContainer === this.area
                    ? this.area.childNodes[elementOffset]
                    : range.startContainer, end = range.endContainer === this.area
                    ? this.area.childNodes[range.endOffset - 1]
                    : range.endContainer;
                Dom_Dom.find(start, (node) => {
                    if (node &&
                        node !== this.area &&
                        !Dom_Dom.isEmptyTextNode(node) &&
                        !this.isMarker(node)) {
                        nodes.push(node);
                    }
                    return node === end || (node && node.contains(end));
                }, this.area, true, 'nextSibling', false);
                const forEvery = (current) => {
                    if (current.nodeName.match(/^(UL|OL)$/)) {
                        return Array.from(current.childNodes).forEach(forEvery);
                    }
                    if (current.nodeName === 'LI') {
                        if (current.firstChild) {
                            current = current.firstChild;
                        }
                        else {
                            const currentB = this.jodit.create.inside.text(INVISIBLE_SPACE);
                            current.appendChild(currentB);
                            current = currentB;
                        }
                    }
                    callback(current);
                };
                if (nodes.length === 0 && Dom_Dom.isEmptyTextNode(start)) {
                    nodes.push(start);
                }
                nodes.forEach(forEvery);
            }
        };
        jodit.events.on('removeMarkers', () => {
            this.removeMarkers();
        });
    }
    errorNode(node) {
        if (!Dom_Dom.isNode(node, this.win)) {
            throw type_error('Parameter node must be instance of Node');
        }
    }
    get area() {
        return this.jodit.editor;
    }
    get win() {
        return this.jodit.editorWindow;
    }
    get doc() {
        return this.jodit.editorDocument;
    }
    get sel() {
        return this.win.getSelection();
    }
    get range() {
        const sel = this.sel;
        return sel && sel.rangeCount ? sel.getRangeAt(0) : this.createRange();
    }
    createRange() {
        return this.doc.createRange();
    }
    remove() {
        const sel = this.sel, current = this.current();
        if (sel && current) {
            for (let i = 0; i < sel.rangeCount; i += 1) {
                sel.getRangeAt(i).deleteContents();
                sel.getRangeAt(i).collapse(true);
            }
        }
    }
    removeNode(node) {
        if (!Dom_Dom.isOrContains(this.jodit.editor, node, true)) {
            throw type_error("Selection.removeNode can remove only editor's children");
        }
        Dom_Dom.safeRemove(node);
        this.jodit.events.fire('afterRemoveNode', node);
    }
    insertCursorAtPoint(x, y) {
        this.removeMarkers();
        try {
            let rng = this.createRange();
            if (this.doc.caretPositionFromPoint) {
                const caret = this
                    .doc.caretPositionFromPoint(x, y);
                rng.setStart(caret.offsetNode, caret.offset);
            }
            else if (this.doc.caretRangeFromPoint) {
                const caret = this.doc.caretRangeFromPoint(x, y);
                rng.setStart(caret.startContainer, caret.startOffset);
            }
            if (rng) {
                rng.collapse(true);
                const sel = this.sel;
                if (sel) {
                    sel.removeAllRanges();
                    sel.addRange(rng);
                }
            }
            else if (typeof this.doc.body.createTextRange !== 'undefined') {
                const range = this.doc.body.createTextRange();
                range.moveToPoint(x, y);
                const endRange = range.duplicate();
                endRange.moveToPoint(x, y);
                range.setEndPoint('EndToEnd', endRange);
                range.select();
            }
            return true;
        }
        catch (_a) { }
        return false;
    }
    removeMarkers() {
        $$('span[data-' + MARKER_CLASS + ']', this.area).forEach(Dom_Dom.safeRemove);
    }
    marker(atStart = false, range) {
        let newRange = null;
        if (range) {
            newRange = range.cloneRange();
            newRange.collapse(atStart);
        }
        const marker = this.jodit.create.inside.span();
        marker.id =
            MARKER_CLASS +
                '_' +
                +new Date() +
                '_' +
                ('' + Math.random()).slice(2);
        marker.style.lineHeight = '0';
        marker.style.display = 'none';
        marker.setAttribute('data-' + MARKER_CLASS, atStart ? 'start' : 'end');
        marker.appendChild(this.jodit.create.inside.text(INVISIBLE_SPACE));
        if (newRange) {
            if (Dom_Dom.isOrContains(this.area, atStart ? newRange.startContainer : newRange.endContainer)) {
                newRange.insertNode(marker);
            }
        }
        return marker;
    }
    restore(selectionInfo = []) {
        if (Array.isArray(selectionInfo)) {
            const sel = this.sel;
            sel && sel.removeAllRanges();
            selectionInfo.forEach((selection) => {
                const range = this.createRange(), end = this.area.querySelector('#' + selection.endId), start = this.area.querySelector('#' + selection.startId);
                if (!start) {
                    return;
                }
                if (selection.collapsed || !end) {
                    const previousNode = start.previousSibling;
                    if (previousNode &&
                        previousNode.nodeType === Node.TEXT_NODE) {
                        range.setStart(previousNode, previousNode.nodeValue
                            ? previousNode.nodeValue.length
                            : 0);
                    }
                    else {
                        range.setStartBefore(start);
                    }
                    Dom_Dom.safeRemove(start);
                    range.collapse(true);
                }
                else {
                    range.setStartAfter(start);
                    Dom_Dom.safeRemove(start);
                    range.setEndBefore(end);
                    Dom_Dom.safeRemove(end);
                }
                sel && sel.addRange(range);
            });
        }
    }
    save() {
        const sel = this.sel;
        if (!sel || !sel.rangeCount) {
            return [];
        }
        const info = [], length = sel.rangeCount, ranges = [];
        let i, start, end;
        for (i = 0; i < length; i += 1) {
            ranges[i] = sel.getRangeAt(i);
            if (ranges[i].collapsed) {
                start = this.marker(true, ranges[i]);
                info[i] = {
                    startId: start.id,
                    collapsed: true,
                    startMarker: start.outerHTML
                };
            }
            else {
                start = this.marker(true, ranges[i]);
                end = this.marker(false, ranges[i]);
                info[i] = {
                    startId: start.id,
                    endId: end.id,
                    collapsed: false,
                    startMarker: start.outerHTML,
                    endMarker: end.outerHTML
                };
            }
        }
        sel.removeAllRanges();
        for (i = length - 1; i >= 0; --i) {
            const startElm = this.doc.getElementById(info[i].startId);
            if (startElm) {
                if (info[i].collapsed) {
                    ranges[i].setStartAfter(startElm);
                    ranges[i].collapse(true);
                }
                else {
                    ranges[i].setStartBefore(startElm);
                    if (info[i].endId) {
                        const endElm = this.doc.getElementById(info[i].endId);
                        if (endElm) {
                            ranges[i].setEndAfter(endElm);
                        }
                    }
                }
            }
            try {
                sel.addRange(ranges[i].cloneRange());
            }
            catch (_a) { }
        }
        return info;
    }
    isCollapsed() {
        const sel = this.sel;
        for (let r = 0; sel && r < sel.rangeCount; r += 1) {
            if (!sel.getRangeAt(r).collapsed) {
                return false;
            }
        }
        return true;
    }
    isFocused() {
        return (this.doc.hasFocus &&
            this.doc.hasFocus() &&
            this.area === this.doc.activeElement);
    }
    current(checkChild = true) {
        if (this.jodit.getRealMode() === MODE_WYSIWYG) {
            const sel = this.sel;
            if (sel && sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                let node = range.startContainer, rightMode = false;
                const child = (nd) => rightMode ? nd.lastChild : nd.firstChild;
                if (node.nodeType !== Node.TEXT_NODE) {
                    node = range.startContainer.childNodes[range.startOffset];
                    if (!node) {
                        node =
                            range.startContainer.childNodes[range.startOffset - 1];
                        rightMode = true;
                    }
                    if (node &&
                        sel.isCollapsed &&
                        node.nodeType !== Node.TEXT_NODE) {
                        if (!rightMode &&
                            node.previousSibling &&
                            node.previousSibling.nodeType === Node.TEXT_NODE) {
                            node = node.previousSibling;
                        }
                        else if (checkChild) {
                            let current = child(node);
                            while (current) {
                                if (current &&
                                    current.nodeType === Node.TEXT_NODE) {
                                    node = current;
                                    break;
                                }
                                current = child(current);
                            }
                        }
                    }
                    if (node &&
                        !sel.isCollapsed &&
                        node.nodeType !== Node.TEXT_NODE) {
                        let leftChild = node, rightChild = node;
                        do {
                            leftChild = leftChild.firstChild;
                            rightChild = rightChild.lastChild;
                        } while (leftChild &&
                            rightChild &&
                            leftChild.nodeType !== Node.TEXT_NODE);
                        if (leftChild === rightChild &&
                            leftChild &&
                            leftChild.nodeType === Node.TEXT_NODE) {
                            node = leftChild;
                        }
                    }
                }
                if (node && Dom_Dom.isOrContains(this.area, node)) {
                    return node;
                }
            }
        }
        return false;
    }
    insertNode(node, insertCursorAfter = true, fireChange = true) {
        this.errorNode(node);
        this.focus();
        const sel = this.sel;
        if (!this.isCollapsed()) {
            this.jodit.execCommand('Delete');
        }
        if (sel && sel.rangeCount) {
            const range = sel.getRangeAt(0);
            if (Dom_Dom.isOrContains(this.area, range.commonAncestorContainer)) {
                range.deleteContents();
                range.insertNode(node);
            }
            else {
                this.area.appendChild(node);
            }
        }
        else {
            this.area.appendChild(node);
        }
        if (insertCursorAfter) {
            this.setCursorAfter(node);
        }
        if (fireChange && this.jodit.events) {
            this.jodit.events.fire('synchro');
        }
        if (this.jodit.events) {
            this.jodit.events.fire('afterInsertNode', node);
        }
    }
    insertHTML(html) {
        if (html === '') {
            return;
        }
        const node = this.jodit.create.inside.div(), fragment = this.jodit.create.inside.fragment();
        let lastChild, lastEditorElement;
        if (!this.isFocused() && this.jodit.isEditorMode()) {
            this.focus();
        }
        if (!Dom_Dom.isNode(html, this.win)) {
            node.innerHTML = html.toString();
        }
        else {
            node.appendChild(html);
        }
        if (!this.jodit.isEditorMode() &&
            this.jodit.events.fire('insertHTML', node.innerHTML) === false) {
            return;
        }
        lastChild = node.lastChild;
        if (!lastChild) {
            return;
        }
        while (node.firstChild) {
            lastChild = node.firstChild;
            fragment.appendChild(node.firstChild);
        }
        this.insertNode(fragment, false);
        if (lastChild) {
            this.setCursorAfter(lastChild);
        }
        else {
            this.setCursorIn(fragment);
        }
        lastEditorElement = this.area.lastChild;
        while (lastEditorElement &&
            lastEditorElement.nodeType === Node.TEXT_NODE &&
            lastEditorElement.previousSibling &&
            lastEditorElement.nodeValue &&
            /^\s*$/.test(lastEditorElement.nodeValue)) {
            lastEditorElement = lastEditorElement.previousSibling;
        }
        if (lastChild) {
            if (lastEditorElement &&
                lastChild === lastEditorElement &&
                lastChild.nodeType === Node.ELEMENT_NODE) {
                this.area.appendChild(this.jodit.create.inside.element('br'));
            }
            this.setCursorAfter(lastChild);
        }
    }
    insertImage(url, styles, defaultWidth) {
        const image = typeof url === 'string'
            ? this.jodit.create.inside.element('img')
            : url;
        if (typeof url === 'string') {
            image.setAttribute('src', url);
        }
        if (defaultWidth !== null) {
            let dw = defaultWidth.toString();
            if (dw &&
                'auto' !== dw &&
                String(dw).indexOf('px') < 0 &&
                String(dw).indexOf('%') < 0) {
                dw += 'px';
            }
            css_css(image, 'width', dw);
        }
        if (styles && typeof styles === 'object') {
            css_css(image, styles);
        }
        const onload = () => {
            if (image.naturalHeight < image.offsetHeight ||
                image.naturalWidth < image.offsetWidth) {
                image.style.width = '';
                image.style.height = '';
            }
            image.removeEventListener('load', onload);
        };
        image.addEventListener('load', onload);
        if (image.complete) {
            onload();
        }
        const result = this.insertNode(image);
        this.jodit.events.fire('afterInsertImage', image);
        return result;
    }
    setCursorAfter(node) {
        this.errorNode(node);
        if (!Dom_Dom.up(node, (elm) => elm === this.area || (elm && elm.parentNode === this.area), this.area)) {
            throw type_error('Node element must be in editor');
        }
        const range = this.createRange();
        let fakeNode = false;
        if (node.nodeType !== Node.TEXT_NODE) {
            fakeNode = this.doc.createTextNode(INVISIBLE_SPACE);
            range.setStartAfter(node);
            range.insertNode(fakeNode);
            range.selectNode(fakeNode);
        }
        else {
            range.setEnd(node, node.nodeValue !== null ? node.nodeValue.length : 0);
        }
        range.collapse(false);
        this.selectRange(range);
        return fakeNode;
    }
    cursorInTheEdge(start, parentBlock) {
        const sel = this.sel, range = sel && sel.rangeCount ? sel.getRangeAt(0) : null;
        if (!range) {
            return null;
        }
        const container = start ? range.startContainer : range.endContainer, sibling = (node) => {
            return start
                ? Dom_Dom.prev(node, elm => !!elm, parentBlock)
                : Dom_Dom.next(node, elm => !!elm, parentBlock);
        }, checkSiblings = (next) => {
            while (next) {
                next = sibling(next);
                if (next &&
                    !Dom_Dom.isEmptyTextNode(next) &&
                    next.nodeName !== 'BR') {
                    return false;
                }
            }
        };
        if (container.nodeType === Node.TEXT_NODE) {
            const value = container.nodeValue || '';
            if (start &&
                range.startOffset >
                    value.length -
                        value.replace(INVISIBLE_SPACE_REG_EXP_START, '').length) {
                return false;
            }
            if (!start &&
                range.startOffset <
                    value.replace(INVISIBLE_SPACE_REG_EXP_END, '').length) {
                return false;
            }
            if (checkSiblings(container) === false) {
                return false;
            }
        }
        const current = this.current(false);
        if (!current || !Dom_Dom.isOrContains(parentBlock, current, true)) {
            return null;
        }
        if (!start && range.startContainer.childNodes[range.startOffset]) {
            if (current && !Dom_Dom.isEmptyTextNode(current)) {
                return false;
            }
        }
        return checkSiblings(current) !== false;
    }
    setCursorBefore(node) {
        this.errorNode(node);
        if (!Dom_Dom.up(node, (elm) => elm === this.area || (elm && elm.parentNode === this.area), this.area)) {
            throw type_error('Node element must be in editor');
        }
        const range = this.createRange();
        let fakeNode = false;
        if (node.nodeType !== Node.TEXT_NODE) {
            fakeNode = this.doc.createTextNode(INVISIBLE_SPACE);
            range.setStartBefore(node);
            range.collapse(true);
            range.insertNode(fakeNode);
            range.selectNode(fakeNode);
        }
        else {
            range.setStart(node, node.nodeValue !== null ? node.nodeValue.length : 0);
        }
        range.collapse(true);
        this.selectRange(range);
        return fakeNode;
    }
    setCursorIn(node, inStart = false) {
        this.errorNode(node);
        if (!Dom_Dom.up(node, (elm) => elm === this.area || (elm && elm.parentNode === this.area), this.area)) {
            throw type_error('Node element must be in editor');
        }
        const range = this.createRange();
        let start = node, last = node;
        do {
            if (start.nodeType === Node.TEXT_NODE) {
                break;
            }
            last = start;
            start = inStart ? start.firstChild : start.lastChild;
        } while (start);
        if (!start) {
            const fakeNode = this.doc.createTextNode(INVISIBLE_SPACE);
            if (!/^(img|br|input)$/i.test(last.nodeName)) {
                last.appendChild(fakeNode);
                last = fakeNode;
            }
            else {
                start = last;
            }
        }
        range.selectNodeContents(start || last);
        range.collapse(inStart);
        this.selectRange(range);
        return last;
    }
    selectRange(range) {
        const sel = this.sel;
        if (sel) {
            sel.removeAllRanges();
            sel.addRange(range);
        }
        this.jodit.events.fire('changeSelection');
    }
    select(node, inward = false) {
        this.errorNode(node);
        if (!Dom_Dom.up(node, (elm) => elm === this.area || (elm && elm.parentNode === this.area), this.area)) {
            throw type_error('Node element must be in editor');
        }
        const range = this.createRange();
        range[inward ? 'selectNodeContents' : 'selectNode'](node);
        this.selectRange(range);
    }
    getHTML() {
        const sel = this.sel;
        if (sel && sel.rangeCount > 0) {
            const range = sel.getRangeAt(0);
            const clonedSelection = range.cloneContents();
            const div = this.jodit.create.inside.div();
            div.appendChild(clonedSelection);
            return div.innerHTML;
        }
        return '';
    }
    applyCSS(cssRules, nodeName = 'span', options) {
        const WRAP = 1, UNWRAP = 0, defaultTag = 'SPAN', FONT = 'FONT';
        let mode;
        const findNextCondition = (elm) => elm !== null &&
            !Dom_Dom.isEmptyTextNode(elm) &&
            !this.isMarker(elm);
        const checkCssRulesFor = (elm) => {
            return (elm.nodeName !== FONT &&
                elm.nodeType === Node.ELEMENT_NODE &&
                ((isPlainObject(options) &&
                    each(options, (cssPropertyKey, cssPropertyValues) => {
                        const value = css_css(elm, cssPropertyKey, undefined, true);
                        return (value !== null &&
                            value !== '' &&
                            cssPropertyValues.indexOf(value.toString().toLowerCase()) !== -1);
                    })) ||
                    (typeof options === 'function' && options(this.jodit, elm))));
        };
        const isSuitElement = (elm) => {
            if (!elm) {
                return false;
            }
            const reg = new RegExp('^' + elm.nodeName + '$', 'i');
            return ((reg.test(nodeName) ||
                !!(options && checkCssRulesFor(elm))) &&
                findNextCondition(elm));
        };
        const toggleStyles = (elm) => {
            if (isSuitElement(elm)) {
                if (elm.nodeName === defaultTag && cssRules) {
                    Object.keys(cssRules).forEach((rule) => {
                        if (mode === UNWRAP ||
                            css_css(elm, rule) ===
                                normilizeCSSValue(rule, cssRules[rule])) {
                            css_css(elm, rule, '');
                            if (mode === undefined) {
                                mode = UNWRAP;
                            }
                        }
                        else {
                            css_css(elm, rule, cssRules[rule]);
                            if (mode === undefined) {
                                mode = WRAP;
                            }
                        }
                    });
                }
                if (!Dom_Dom.isBlock(elm, this.win) &&
                    (!elm.getAttribute('style') || elm.nodeName !== defaultTag)) {
                    Dom_Dom.unwrap(elm);
                    if (mode === undefined) {
                        mode = UNWRAP;
                    }
                }
            }
        };
        if (!this.isCollapsed()) {
            const selInfo = this.save();
            normalizeNode(this.area.firstChild);
            $$('*[style*=font-size]', this.area).forEach((elm) => {
                elm.style &&
                    elm.style.fontSize &&
                    elm.setAttribute('data-font-size', elm.style.fontSize.toString());
            });
            this.doc.execCommand('fontsize', false, '7');
            $$('*[data-font-size]', this.area).forEach((elm) => {
                const fontSize = elm.getAttribute('data-font-size');
                if (elm.style && fontSize) {
                    elm.style.fontSize = fontSize;
                    elm.removeAttribute('data-font-size');
                }
            });
            $$('font[size="7"]', this.area).forEach((font) => {
                if (!Dom_Dom.next(font, findNextCondition, font.parentNode) &&
                    !Dom_Dom.prev(font, findNextCondition, font.parentNode) &&
                    isSuitElement(font.parentNode) &&
                    font.parentNode !== this.area &&
                    (!Dom_Dom.isBlock(font.parentNode, this.win) ||
                        IS_BLOCK.test(nodeName))) {
                    toggleStyles(font.parentNode);
                }
                else if (font.firstChild &&
                    !Dom_Dom.next(font.firstChild, findNextCondition, font) &&
                    !Dom_Dom.prev(font.firstChild, findNextCondition, font) &&
                    isSuitElement(font.firstChild)) {
                    toggleStyles(font.firstChild);
                }
                else if (Dom_Dom.closest(font, isSuitElement, this.area)) {
                    const leftRange = this.createRange(), wrapper = Dom_Dom.closest(font, isSuitElement, this.area);
                    leftRange.setStartBefore(wrapper);
                    leftRange.setEndBefore(font);
                    const leftFragment = leftRange.extractContents();
                    if ((!leftFragment.textContent ||
                        !trim(leftFragment.textContent).length) &&
                        leftFragment.firstChild) {
                        Dom_Dom.unwrap(leftFragment.firstChild);
                    }
                    if (wrapper.parentNode) {
                        wrapper.parentNode.insertBefore(leftFragment, wrapper);
                    }
                    leftRange.setStartAfter(font);
                    leftRange.setEndAfter(wrapper);
                    const rightFragment = leftRange.extractContents();
                    if ((!rightFragment.textContent ||
                        !trim(rightFragment.textContent).length) &&
                        rightFragment.firstChild) {
                        Dom_Dom.unwrap(rightFragment.firstChild);
                    }
                    Dom_Dom.after(wrapper, rightFragment);
                    toggleStyles(wrapper);
                }
                else {
                    const needUnwrap = [];
                    let firstElementSuit;
                    if (font.firstChild) {
                        Dom_Dom.find(font.firstChild, (elm) => {
                            if (elm && isSuitElement(elm)) {
                                if (firstElementSuit === undefined) {
                                    firstElementSuit = true;
                                }
                                needUnwrap.push(elm);
                            }
                            else {
                                if (firstElementSuit === undefined) {
                                    firstElementSuit = false;
                                }
                            }
                            return false;
                        }, font, true);
                    }
                    needUnwrap.forEach(Dom_Dom.unwrap);
                    if (!firstElementSuit) {
                        if (mode === undefined) {
                            mode = WRAP;
                        }
                        if (mode === WRAP) {
                            css_css(Dom_Dom.replace(font, nodeName, false, false, this.jodit.create.inside), cssRules &&
                                nodeName.toUpperCase() === defaultTag
                                ? cssRules
                                : {});
                        }
                    }
                }
                if (font.parentNode) {
                    Dom_Dom.unwrap(font);
                }
            });
            this.restore(selInfo);
        }
        else {
            let clearStyle = false;
            if (this.current() &&
                Dom_Dom.closest(this.current(), nodeName, this.area)) {
                clearStyle = true;
                const closest = Dom_Dom.closest(this.current(), nodeName, this.area);
                if (closest) {
                    this.setCursorAfter(closest);
                }
            }
            if (nodeName.toUpperCase() === defaultTag || !clearStyle) {
                const node = this.jodit.create.inside.element(nodeName);
                node.appendChild(this.jodit.create.inside.text(INVISIBLE_SPACE));
                this.insertNode(node, false, false);
                if (nodeName.toUpperCase() === defaultTag && cssRules) {
                    css_css(node, cssRules);
                }
                this.setCursorIn(node);
            }
        }
    }
}

// CONCATENATED MODULE: ./src/modules/StatusBar.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


class StatusBar_StatusBar extends Component_Component {
    constructor(jodit, target) {
        super(jodit);
        this.target = target;
        this.container = jodit.create.div('jodit_statusbar');
        target.appendChild(this.container);
        this.hide();
    }
    hide() {
        this.container && this.container.classList.add('jodit_hidden');
    }
    show() {
        this.container && this.container.classList.remove('jodit_hidden');
    }
    getHeight() {
        return this.container.offsetHeight;
    }
    findEmpty(inTheRight = false) {
        const items = this.container.querySelectorAll('.jodit_statusbar_item' + (inTheRight ? '.jodit_statusbar_item-right' : ''));
        for (let i = 0; i < items.length; i += 1) {
            if (!items[i].innerHTML.trim().length) {
                return items[i];
            }
        }
    }
    append(child, inTheRight = false) {
        const wrapper = this.findEmpty(inTheRight) || this.jodit.create.div('jodit_statusbar_item');
        if (inTheRight) {
            wrapper.classList.add('jodit_statusbar_item-right');
        }
        wrapper.appendChild(child);
        this.container.appendChild(wrapper);
        this.show();
        this.jodit.events.fire('resize');
    }
    destruct() {
        this.setStatus(STATUSES.beforeDestruct);
        Dom_Dom.safeRemove(this.container);
        delete this.container;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/storage/localStorageProvider.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const canUsePersistentStorage = (() => {
    const canUse = () => {
        const tmpKey = '___Jodit___' + Math.random().toString();
        try {
            localStorage.setItem(tmpKey, '1');
            const result = localStorage.getItem(tmpKey) === '1';
            localStorage.removeItem(tmpKey);
            return result;
        }
        catch (_a) { }
        return false;
    };
    let result;
    return () => {
        if (result === undefined) {
            result = canUse();
        }
        return result;
    };
})();
class LocalStorageProvider {
    constructor(rootKey) {
        this.rootKey = rootKey;
    }
    set(key, value) {
        try {
            const buffer = localStorage.getItem(this.rootKey);
            const json = buffer ? JSON.parse(buffer) : {};
            json[key] = value;
            localStorage.setItem(this.rootKey, JSON.stringify(json));
        }
        catch (_a) { }
    }
    get(key) {
        try {
            const buffer = localStorage.getItem(this.rootKey);
            const json = buffer ? JSON.parse(buffer) : {};
            return json[key] !== undefined ? json[key] : null;
        }
        catch (_a) { }
    }
    exists(key) {
        return this.get(key) !== null;
    }
    clear() {
        try {
            localStorage.removeItem(this.rootKey);
        }
        catch (_a) { }
    }
}

// CONCATENATED MODULE: ./src/modules/storage/memoryStorageProvider.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
class MemoryStorageProvider {
    constructor() {
        this.data = new Map();
    }
    set(key, value) {
        this.data.set(key, value);
    }
    get(key) {
        return this.data.get(key);
    }
    exists(key) {
        return this.data.has(key);
    }
    clear() {
        this.data.clear();
    }
}

// CONCATENATED MODULE: ./src/modules/storage/storage.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



const StorageKey = 'Jodit_';
class storage_Storage {
    constructor(provider, suffix) {
        this.provider = provider;
        this.prefix = StorageKey;
        if (suffix) {
            this.prefix += suffix;
        }
    }
    set(key, value) {
        this.provider.set(camelCase(this.prefix + key), value);
    }
    get(key) {
        return this.provider.get(camelCase(this.prefix + key));
    }
    exists(key) {
        return this.provider.exists(camelCase(this.prefix + key));
    }
    clear() {
        return this.provider.clear();
    }
    static makeStorage(persistent = false, suffix) {
        let provider;
        if (persistent && canUsePersistentStorage()) {
            provider = new LocalStorageProvider(StorageKey + suffix);
        }
        if (!provider) {
            provider = new MemoryStorageProvider();
        }
        return new storage_Storage(provider, suffix);
    }
}

// CONCATENATED MODULE: ./src/modules/events/store.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const defaultNameSpace = 'JoditEventDefaultNamespace';
class EventHandlersStore {
    constructor() {
        this.__store = {};
    }
    get(event, namespace) {
        if (this.__store[namespace] !== undefined) {
            return this.__store[namespace][event];
        }
    }
    indexOf(event, namespace, originalCallback) {
        const blocks = this.get(event, namespace);
        if (blocks) {
            for (let i = 0; i < blocks.length; i += 1) {
                if (blocks[i].originalCallback === originalCallback) {
                    return i;
                }
            }
        }
        return false;
    }
    namespaces(withoutDefault = false) {
        const nss = Object.keys(this.__store);
        return withoutDefault ? nss.filter(ns => ns !== defaultNameSpace) : nss;
    }
    events(namespace) {
        return this.__store[namespace]
            ? Object.keys(this.__store[namespace])
            : [];
    }
    set(event, namespace, data, onTop = false) {
        if (this.__store[namespace] === undefined) {
            this.__store[namespace] = {};
        }
        if (this.__store[namespace][event] === undefined) {
            this.__store[namespace][event] = [];
        }
        if (!onTop) {
            this.__store[namespace][event].push(data);
        }
        else {
            this.__store[namespace][event].unshift(data);
        }
    }
    clear() {
        delete this.__store;
        this.__store = {};
    }
}

// CONCATENATED MODULE: ./src/modules/events/eventsNative.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * License GNU General License version 2 or later;
 * Copyright 2013-2020 Valeriy Chupurnov https://xdsoft.net
 */


class eventsNative_EventsNative {
    constructor(doc) {
        this.__key = '__JoditEventsNativeNamespaces';
        this.doc = document;
        this.__stopped = [];
        this.prepareEvent = (event) => {
            if (event.cancelBubble) {
                return;
            }
            if (event.type.match(/^touch/) &&
                event.changedTouches &&
                event.changedTouches.length) {
                ['clientX', 'clientY', 'pageX', 'pageY'].forEach((key) => {
                    Object.defineProperty(event, key, {
                        value: event.changedTouches[0][key],
                        configurable: true,
                        enumerable: true
                    });
                });
            }
            if (!event.originalEvent) {
                event.originalEvent = event;
            }
            if (event.type === 'paste' &&
                event.clipboardData === undefined &&
                this.doc.defaultView.clipboardData) {
                Object.defineProperty(event, 'clipboardData', {
                    get: () => {
                        return this.doc.defaultView.clipboardData;
                    },
                    configurable: true,
                    enumerable: true
                });
            }
        };
        this.current = [];
        this.isDestructed = false;
        if (doc) {
            this.doc = doc;
        }
        this.__key += new Date().getTime();
    }
    eachEvent(events, callback) {
        const eventParts = events.split(/[\s,]+/);
        eventParts.forEach((eventNameSpace) => {
            const eventAndNameSpace = eventNameSpace.split('.');
            const namespace = eventAndNameSpace[1] || defaultNameSpace;
            callback.call(this, eventAndNameSpace[0], namespace);
        });
    }
    getStore(subject) {
        if (!subject) {
            throw type_error('Need subject');
        }
        if (subject[this.__key] === undefined) {
            const store = new EventHandlersStore();
            Object.defineProperty(subject, this.__key, {
                enumerable: false,
                configurable: true,
                value: store
            });
        }
        return subject[this.__key];
    }
    clearStore(subject) {
        if (subject[this.__key] !== undefined) {
            delete subject[this.__key];
        }
    }
    triggerNativeEvent(element, event) {
        const evt = this.doc.createEvent('HTMLEvents');
        if (typeof event === 'string') {
            evt.initEvent(event, true, true);
        }
        else {
            evt.initEvent(event.type, event.bubbles, event.cancelable);
            [
                'screenX',
                'screenY',
                'clientX',
                'clientY',
                'target',
                'srcElement',
                'currentTarget',
                'timeStamp',
                'which',
                'keyCode'
            ].forEach(property => {
                Object.defineProperty(evt, property, {
                    value: event[property],
                    enumerable: true
                });
            });
            Object.defineProperty(evt, 'originalEvent', {
                value: event,
                enumerable: true
            });
        }
        element.dispatchEvent(evt);
    }
    removeStop(currentBlocks) {
        if (currentBlocks) {
            const index = this.__stopped.indexOf(currentBlocks);
            index !== -1 && this.__stopped.splice(index, 1);
        }
    }
    isStopped(currentBlocks) {
        return (currentBlocks !== undefined &&
            this.__stopped.indexOf(currentBlocks) !== -1);
    }
    on(subjectOrEvents, eventsOrCallback, handlerOrSelector, selector, onTop = false) {
        const subject = typeof subjectOrEvents === 'string' ? this : subjectOrEvents;
        const events = typeof eventsOrCallback === 'string'
            ? eventsOrCallback
            : subjectOrEvents;
        let callback = handlerOrSelector;
        if (callback === undefined && typeof eventsOrCallback === 'function') {
            callback = eventsOrCallback;
        }
        const store = this.getStore(subject);
        if (typeof events !== 'string' || events === '') {
            throw type_error('Need events names');
        }
        if (typeof callback !== 'function') {
            throw type_error('Need event handler');
        }
        if (Array.isArray(subject)) {
            subject.forEach((subj) => {
                this.on(subj, events, callback, selector);
            });
            return this;
        }
        const isDOMElement = typeof subject.addEventListener === 'function', self = this;
        let syntheticCallback = function (event) {
            return callback && callback.apply(this, arguments);
        };
        if (isDOMElement) {
            syntheticCallback = function (event) {
                self.prepareEvent(event);
                if (callback && callback.call(this, event) === false) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                    return false;
                }
                return;
            };
            if (selector) {
                syntheticCallback = function (event) {
                    self.prepareEvent(event);
                    let node = event.target;
                    while (node && node !== this) {
                        if (node.matches(selector)) {
                            Object.defineProperty(event, 'target', {
                                value: node,
                                configurable: true,
                                enumerable: true
                            });
                            if (callback &&
                                callback.call(node, event) === false) {
                                event.preventDefault();
                                return false;
                            }
                            return;
                        }
                        node = node.parentNode;
                    }
                };
            }
        }
        this.eachEvent(events, (event, namespace) => {
            if (event === '') {
                throw type_error('Need event name');
            }
            if (store.indexOf(event, namespace, callback) === false) {
                const block = {
                    event,
                    originalCallback: callback,
                    syntheticCallback
                };
                store.set(event, namespace, block, onTop);
                if (isDOMElement) {
                    subject.addEventListener(event, syntheticCallback, false);
                }
            }
        });
        return this;
    }
    off(subjectOrEvents, eventsOrCallback, handler) {
        const subject = typeof subjectOrEvents === 'string' ? this : subjectOrEvents;
        const events = typeof eventsOrCallback === 'string'
            ? eventsOrCallback
            : subjectOrEvents;
        const store = this.getStore(subject);
        let callback = handler;
        if (typeof events !== 'string' || !events) {
            store.namespaces().forEach((namespace) => {
                this.off(subject, '.' + namespace);
            });
            this.clearStore(subject);
            return this;
        }
        if (callback === undefined && typeof eventsOrCallback === 'function') {
            callback = eventsOrCallback;
        }
        const isDOMElement = typeof subject.removeEventListener === 'function', removeEventListener = (block) => {
            if (isDOMElement) {
                subject.removeEventListener(block.event, block.syntheticCallback, false);
            }
        }, removeCallbackFromNameSpace = (event, namespace) => {
            if (event !== '') {
                const blocks = store.get(event, namespace);
                if (blocks && blocks.length) {
                    if (typeof callback !== 'function') {
                        blocks.forEach(removeEventListener);
                        blocks.length = 0;
                    }
                    else {
                        const index = store.indexOf(event, namespace, callback);
                        if (index !== false) {
                            removeEventListener(blocks[index]);
                            blocks.splice(index, 1);
                        }
                    }
                }
            }
            else {
                store.events(namespace).forEach((eventName) => {
                    if (eventName !== '') {
                        removeCallbackFromNameSpace(eventName, namespace);
                    }
                });
            }
        };
        this.eachEvent(events, (event, namespace) => {
            if (namespace === defaultNameSpace) {
                store.namespaces().forEach((name) => {
                    removeCallbackFromNameSpace(event, name);
                });
            }
            else {
                removeCallbackFromNameSpace(event, namespace);
            }
        });
        return this;
    }
    stopPropagation(subjectOrEvents, eventsList) {
        const subject = typeof subjectOrEvents === 'string' ? this : subjectOrEvents;
        const events = typeof subjectOrEvents === 'string'
            ? subjectOrEvents
            : eventsList;
        if (typeof events !== 'string') {
            throw type_error('Need event names');
        }
        const store = this.getStore(subject);
        this.eachEvent(events, (event, namespace) => {
            const blocks = store.get(event, namespace);
            if (blocks) {
                this.__stopped.push(blocks);
            }
            if (namespace === defaultNameSpace) {
                store
                    .namespaces(true)
                    .forEach(ns => this.stopPropagation(subject, event + '.' + ns));
            }
        });
    }
    fire(subjectOrEvents, eventsList, ...args) {
        let result = undefined, result_value;
        const subject = typeof subjectOrEvents === 'string' ? this : subjectOrEvents;
        const events = typeof subjectOrEvents === 'string'
            ? subjectOrEvents
            : eventsList;
        const argumentsList = typeof subjectOrEvents === 'string' ? [eventsList, ...args] : args;
        const isDOMElement = typeof subject.dispatchEvent === 'function';
        if (!isDOMElement && typeof events !== 'string') {
            throw type_error('Need events names');
        }
        const store = this.getStore(subject);
        if (typeof events !== 'string' && isDOMElement) {
            this.triggerNativeEvent(subject, eventsList);
        }
        else {
            this.eachEvent(events, (event, namespace) => {
                if (isDOMElement) {
                    this.triggerNativeEvent(subject, event);
                }
                else {
                    const blocks = store.get(event, namespace);
                    if (blocks) {
                        try {
                            blocks.every((block) => {
                                if (this.isStopped(blocks)) {
                                    return false;
                                }
                                this.current.push(event);
                                result_value = block.syntheticCallback.apply(subject, argumentsList);
                                this.current.pop();
                                if (result_value !== undefined) {
                                    result = result_value;
                                }
                                return true;
                            });
                        }
                        finally {
                            this.removeStop(blocks);
                        }
                    }
                    if (namespace === defaultNameSpace && !isDOMElement) {
                        store
                            .namespaces()
                            .filter(ns => ns !== namespace)
                            .forEach((ns) => {
                            const result_second = this.fire.apply(this, [
                                subject,
                                event + '.' + ns,
                                ...argumentsList
                            ]);
                            if (result_second !== undefined) {
                                result = result_second;
                            }
                        });
                    }
                }
            });
        }
        return result;
    }
    destruct() {
        if (!this.isDestructed) {
            return;
        }
        this.isDestructed = true;
        this.off(this);
        this.getStore(this).clear();
        delete this[this.__key];
    }
}

// CONCATENATED MODULE: ./src/modules/Create.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





class Create_Create {
    constructor(jodit, insideCreator = false) {
        this.jodit = jodit;
        this.insideCreator = insideCreator;
        this.applyAttributes = (elm, attrs) => {
            each(attrs, (key, value) => {
                if (isPlainObject(value) && key === 'style') {
                    css_css(elm, value);
                }
                else {
                    elm.setAttribute(key, value.toString());
                }
            });
        };
        if (!insideCreator) {
            this.inside = new Create_Create(jodit, true);
        }
    }
    get doc() {
        return this.insideCreator && isJoditObject(this.jodit)
            ? this.jodit.editorDocument
            : this.jodit.ownerDocument;
    }
    element(tagName, childrenOrAttributes, children) {
        const elm = this.doc.createElement(tagName.toLowerCase());
        if (this.insideCreator) {
            const ca = this.jodit.options.createAttributes;
            if (ca && ca[tagName.toLowerCase()]) {
                const attrs = ca[tagName.toLowerCase()];
                if (isFunction(attrs)) {
                    attrs(elm);
                }
                else if (isPlainObject(attrs)) {
                    this.applyAttributes(elm, attrs);
                }
            }
        }
        if (childrenOrAttributes) {
            if (isPlainObject(childrenOrAttributes)) {
                this.applyAttributes(elm, childrenOrAttributes);
            }
            else {
                children = childrenOrAttributes;
            }
        }
        if (children) {
            asArray(children).forEach((child) => elm.appendChild(typeof child === 'string' ? this.fromHTML(child) : child));
        }
        return elm;
    }
    div(className, childrenOrAttributes, children) {
        const div = this.element('div', childrenOrAttributes, children);
        if (className) {
            div.className = className;
        }
        return div;
    }
    span(className, childrenOrAttributes, children) {
        const span = this.element('span', childrenOrAttributes, children);
        if (className) {
            span.className = className;
        }
        return span;
    }
    a(className, childrenOrAttributes, children) {
        const a = this.element('a', childrenOrAttributes, children);
        if (className) {
            a.className = className;
        }
        return a;
    }
    text(value) {
        return this.doc.createTextNode(value);
    }
    fragment() {
        return this.doc.createDocumentFragment();
    }
    fromHTML(html, refsToggleElement) {
        const div = this.div();
        div.innerHTML = html.toString();
        const child = div.firstChild !== div.lastChild || !div.firstChild
            ? div
            : div.firstChild;
        Dom_Dom.safeRemove(child);
        if (refsToggleElement) {
            const refElements = refs(child);
            Object.keys(refsToggleElement).forEach(key => {
                const elm = refElements[key];
                if (elm && refsToggleElement[key] === false) {
                    Dom_Dom.hide(elm);
                }
            });
        }
        return child;
    }
}

// CONCATENATED MODULE: ./src/modules/view/panel.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class panel_Panel extends Component_Component {
    constructor(jodit, options) {
        super(jodit);
        this.__whoLocked = '';
        this.__isFullSize = false;
        this.isLocked = () => this.__whoLocked !== '';
        this.isLockedNotBy = (name) => this.isLocked() && this.__whoLocked !== name;
        this.isFullSize = () => this.__isFullSize;
        this.initOptions(options);
        this.initOwners();
        if (jodit && jodit.ownerDocument) {
            this.ownerDocument = jodit.ownerDocument;
            this.ownerWindow = jodit.ownerWindow;
        }
        this.create = new Create_Create(this);
        this.container = this.create.div();
    }
    initOptions(options) {
        this.options = { ...(this.options || {}), ...options };
    }
    initOwners() {
        this.ownerDocument = window.document;
        this.ownerWindow = window;
    }
    resolveElement(element) {
        let resolved = element;
        if (typeof element === 'string') {
            try {
                resolved = this.ownerDocument.querySelector(element);
            }
            catch (_a) {
                throw type_error('String "' + element + '" should be valid HTML selector');
            }
        }
        if (!resolved ||
            typeof resolved !== 'object' ||
            resolved.nodeType !== Node.ELEMENT_NODE ||
            !resolved.cloneNode) {
            throw type_error('Element "' +
                element +
                '" should be string or HTMLElement instance');
        }
        return resolved;
    }
    lock(name = 'any') {
        if (!this.isLocked()) {
            this.__whoLocked = name;
            return true;
        }
        return false;
    }
    unlock() {
        if (this.isLocked()) {
            this.__whoLocked = '';
            return true;
        }
        return false;
    }
    toggleFullSize(isFullSize) {
        if (isFullSize === undefined) {
            isFullSize = !this.__isFullSize;
        }
        if (isFullSize === this.__isFullSize) {
            return;
        }
        this.__isFullSize = isFullSize;
    }
    destruct() {
        if (!this.isDestructed) {
            return;
        }
        Dom_Dom.safeRemove(this.container);
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/storage/index.ts




// CONCATENATED MODULE: ./src/modules/Async.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

class Async_Async {
    constructor() {
        this.timers = new Map();
        this.promisesRejections = new Set();
    }
    setTimeout(callback, timeout, ...args) {
        let options = {};
        if (typeof timeout !== 'number') {
            options = timeout;
            timeout = options.timeout || 0;
        }
        if (options.label && this.timers.has(options.label)) {
            this.clearTimeout(this.timers.get(options.label));
            this.timers.delete(options.label);
        }
        const timer = setTimeout_setTimeout(callback, timeout, ...args), key = options.label || timer;
        this.timers.set(key, timer);
        return timer;
    }
    clearTimeout(timer) {
        setTimeout_clearTimeout(timer);
        this.timers.delete(timer);
    }
    promise(executor) {
        let rejectCallback = () => { };
        const promise = new Promise((resolve, reject) => {
            this.promisesRejections.add(reject);
            rejectCallback = reject;
            return executor(resolve, reject);
        });
        promise.finally(() => {
            this.promisesRejections.delete(rejectCallback);
        });
        return promise;
    }
    promiseState(p) {
        if (p.status) {
            return p.status;
        }
        if (!Promise.race) {
            return new Promise((resolve) => {
                p.then((v) => {
                    resolve('fulfilled');
                    return v;
                }, (e) => {
                    resolve('rejected');
                    throw e;
                });
                this.setTimeout(() => {
                    resolve('pending');
                }, 100);
            });
        }
        const t = {};
        return Promise.race([p, t]).then(v => (v === t ? 'pending' : 'fulfilled'), () => 'rejected');
    }
    clear() {
        this.timers.forEach(key => {
            this.clearTimeout(this.timers.get(key));
        });
        this.timers.clear();
        this.promisesRejections.forEach(reject => {
            reject();
        });
        this.promisesRejections.clear();
    }
    destruct() {
        this.clear();
    }
}

// CONCATENATED MODULE: ./src/modules/ProgressBar.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


class ProgressBar_ProgressBar extends Component_Component {
    constructor() {
        super(...arguments);
        this.progressBar = this.jodit.create.div('jodit_progressbar', this.jodit.create.div());
    }
    show() {
        this.jodit.workplace.appendChild(this.progressBar);
        return this;
    }
    hide() {
        Dom_Dom.safeRemove(this.progressBar);
        return this;
    }
    progress(percentage) {
        this.progressBar.style.width = percentage.toFixed(2) + '%';
        return this;
    }
    destruct() {
        this.hide();
        return super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/view/view.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class view_View extends panel_Panel {
    constructor(jodit, options) {
        var _a, _b, _c;
        super(jodit, options);
        this.components = new Set();
        this.version = "3.3.17";
        this.__modulesInstances = {};
        this.buffer = storage_Storage.makeStorage();
        this.progressbar = new ProgressBar_ProgressBar(this);
        this.async = new Async_Async();
        this.getVersion = () => {
            return this.version;
        };
        this.id = ((_a = jodit) === null || _a === void 0 ? void 0 : _a.id) || new Date().getTime().toString();
        this.jodit = jodit || this;
        this.events = ((_b = jodit) === null || _b === void 0 ? void 0 : _b.events) || new eventsNative_EventsNative(this.ownerDocument);
        this.buffer = ((_c = jodit) === null || _c === void 0 ? void 0 : _c.buffer) || storage_Storage.makeStorage();
    }
    markOwner(elm) {
        elm.setAttribute('data-editor_id', this.id);
    }
    get basePath() {
        if (this.options.basePath) {
            return this.options.basePath;
        }
        return BASE_PATH;
    }
    get defaultTimeout() {
        return 100;
    }
    i18n(text, ...params) {
        var _a, _b, _c;
        return i18n_i18n(text, params, ((_b = (_a = this) === null || _a === void 0 ? void 0 : _a.jodit) === null || _b === void 0 ? void 0 : _b.options) || ((_c = this) === null || _c === void 0 ? void 0 : _c.options));
    }
    toggleFullSize(isFullSize) {
        super.toggleFullSize(isFullSize);
        if (this.events) {
            this.events.fire('toggleFullSize', isFullSize);
        }
    }
    getInstance(moduleName, options) {
        if (typeof Jodit_Jodit.modules[moduleName] !== 'function') {
            throw type_error('Need real module name');
        }
        if (this.__modulesInstances[moduleName] === undefined) {
            this.__modulesInstances[moduleName] = new Jodit_Jodit.modules[moduleName](this.jodit || this, options);
        }
        return this.__modulesInstances[moduleName];
    }
    initOptions(options) {
        super.initOptions({
            extraButtons: [],
            textIcons: false,
            removeButtons: [],
            zIndex: 100002,
            fullsize: false,
            showTooltip: true,
            useNativeTooltip: false,
            buttons: [],
            globalFullsize: true,
            ...options
        });
    }
    destruct() {
        if (this.isDestructed) {
            return;
        }
        if (this.async) {
            this.async.destruct();
            delete this.async;
        }
        if (this.events) {
            this.events.destruct();
            delete this.events;
        }
        super.destruct();
    }
}





// CONCATENATED MODULE: ./src/modules/toolbar/element.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





class element_ToolbarElement extends Component_Component {
    constructor(parentToolbarOrView, containerTag = 'li', containerClass = 'jodit_toolbar_btn') {
        if (parentToolbarOrView instanceof collection_ToolbarCollection) {
            super(parentToolbarOrView.jodit);
            this.parentToolbar = parentToolbarOrView;
        }
        else {
            super(parentToolbarOrView);
        }
        this.container = this.jodit.create.element(containerTag);
        this.container.classList.add(containerClass);
    }
    focus() {
        this.container.focus();
    }
    destruct() {
        if (this.isInDestruct) {
            return;
        }
        this.setStatus(STATUSES.beforeDestruct);
        Dom_Dom.safeRemove(this.container);
        this.parentToolbar = undefined;
        super.destruct();
    }
    createIcon(clearName, control) {
        const icon = control ? control.icon || control.name : clearName;
        if (!this.jodit.options.textIcons) {
            let iconSVG = this.jodit.events.fire('getIcon', icon, control, clearName);
            let iconElement;
            if (control && control.iconURL && iconSVG === undefined) {
                iconElement = this.jodit.create.element('i');
                iconElement.style.backgroundImage =
                    'url(' +
                        control.iconURL.replace('{basePath}', this.jodit.basePath) +
                        ')';
            }
            else {
                if (iconSVG === undefined) {
                    if (ToolbarIcon.exists(icon)) {
                        iconSVG = ToolbarIcon.getIcon(icon);
                    }
                    else {
                        iconSVG = ToolbarIcon.getIcon('empty');
                    }
                }
                iconElement =
                    typeof iconSVG === 'string'
                        ? this.jodit.create.fromHTML(trim(iconSVG))
                        : iconSVG;
            }
            iconElement.classList.add('jodit_icon', 'jodit_icon_' + clearName);
            return iconElement;
        }
        return this.jodit.create.fromHTML(`<span class="jodit_icon">${this.jodit.i18n(control ? control.name : clearName)}</span>`);
    }
}

// CONCATENATED MODULE: ./src/modules/toolbar/break.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

class break_ToolbarBreak extends element_ToolbarElement {
    constructor(jodit) {
        super(jodit);
        this.container.classList.add('jodit_toolbar_btn-break');
    }
}

// CONCATENATED MODULE: ./src/modules/popup/popup.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license;
 * Copyright 2013-2020 Valeriy Chupurnov https://xdsoft.net
 */




class popup_Popup extends Component_Component {
    constructor(jodit, target, current, className = 'jodit_toolbar_popup') {
        super(jodit);
        this.target = target;
        this.current = current;
        this.className = className;
        this.throttleCalcPosition = throttle(this.calcPosition, this.jodit.defaultTimeout);
        this.isOpened = false;
        this.close = (current) => {
            if (!this.isOpened && !this.isDestructed) {
                return;
            }
            if (!current ||
                !Dom_Dom.isOrContains(this.container, current instanceof popup_Popup ? current.target : current)) {
                this.isOpened = false;
                this.jodit.events.off('closeAllPopups', this.close);
                this.doClose();
                Dom_Dom.safeRemove(this.container);
                this.jodit.events.fire('removeMarkers');
                this.jodit.events.fire(this, 'afterClose');
            }
        };
        this.container = this.jodit.create.div(className);
        this.jodit.events
            .on(this.container, 'mousedown touchstart touchend', (e) => {
            e.stopPropagation();
        })
            .on([this.jodit.ownerWindow, this.jodit.events], 'resize', this.throttleCalcPosition)
            .on('afterInsertNode, afterInsertImage', this.close);
    }
    calcPosition() {
        if (!this.isOpened || this.isInDestruct) {
            return;
        }
        const popup = this.container;
        const offsetContainer = offset(this.jodit.container, this.jodit, this.jodit.ownerDocument, true);
        const offsetPopup = offset(popup, this.jodit, this.jodit.ownerDocument, true);
        const marginLeft = css_css(popup, 'marginLeft') || 0;
        offsetPopup.left -= marginLeft;
        let diffLeft = marginLeft;
        let width = 'auto';
        if (offsetPopup.left < offsetContainer.left) {
            diffLeft = offsetContainer.left - offsetPopup.left;
        }
        else if (offsetPopup.left + offsetPopup.width >=
            offsetContainer.left + offsetContainer.width) {
            diffLeft = -(offsetPopup.left +
                offsetPopup.width -
                (offsetContainer.left + offsetContainer.width));
        }
        else {
            diffLeft = 0;
        }
        if (offsetPopup.width >= offsetContainer.width) {
            diffLeft = offsetContainer.left - offsetPopup.left;
            width = offsetContainer.width;
        }
        if (diffLeft !== marginLeft) {
            try {
                popup.style.setProperty('margin-left', diffLeft + 'px', 'important');
            }
            catch (_a) {
                popup.style.marginLeft = diffLeft + 'px';
            }
        }
        const triangle = popup.querySelector('.jodit_popup_triangle');
        if (triangle) {
            triangle.style.marginLeft = -diffLeft + 'px';
        }
        css_css(popup, 'width', width);
    }
    doOpen(content) {
        if (!content) {
            return;
        }
        Dom_Dom.detach(this.container);
        this.container.innerHTML = '<span class="jodit_popup_triangle"></span>';
        this.container.appendChild(Dom_Dom.isNode(content, this.jodit.ownerWindow)
            ? content
            : this.jodit.create.fromHTML(content.toString()));
        this.container.style.display = 'block';
        this.container.style.removeProperty('marginLeft');
    }
    doClose() {
    }
    open(content, rightAlign, noStandardActions = false) {
        Jodit_Jodit.fireEach('beforeOpenPopup closeAllPopups', this, content);
        noStandardActions || this.jodit.events.on('closeAllPopups', this.close);
        this.jodit.markOwner(this.container);
        this.container.classList.add(this.className + '-open');
        this.doOpen(content);
        this.target.appendChild(this.container);
        if (this.jodit.options.textIcons) {
            this.firstInFocus();
        }
        if (rightAlign !== undefined) {
            this.container.classList.toggle('jodit_right', rightAlign);
        }
        if (!noStandardActions && this.container.parentNode) {
            this.jodit.events.fire(this.container.parentNode, 'afterOpenPopup', this.container);
        }
        this.isOpened = true;
        !noStandardActions && this.calcPosition();
    }
    firstInFocus() { }
    destruct() {
        if (this.isDestructed) {
            return;
        }
        this.setStatus(STATUSES.beforeDestruct);
        this.jodit.events.off([this.jodit.ownerWindow, this.jodit.events], 'resize', this.throttleCalcPosition);
        Dom_Dom.safeRemove(this.container);
        delete this.container;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/popup/list.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class list_PopupList extends popup_Popup {
    constructor(jodit, target, current, className = 'jodit_toolbar_list') {
        super(jodit, target, current, className);
        this.target = target;
        this.current = current;
        this.className = className;
        this.defaultControl = {
            template: (editor, key, value) => this.jodit.i18n(value)
        };
    }
    doClose() {
        if (this.toolbar) {
            this.toolbar.destruct();
            delete this.toolbar;
        }
    }
    doOpen(control) {
        this.toolbar = joditToolbarCollection_JoditToolbarCollection.makeCollection(this.jodit);
        const list = typeof control.list === 'string'
            ? control.list.split(/[\s,]+/)
            : control.list;
        each(list, (key, value) => {
            let button, controls = this.jodit.options.controls, getControl = (key) => controls && controls[key];
            if (typeof value === 'string' && getControl(value)) {
                button = new button_ToolbarButton(this.toolbar, {
                    name: value.toString(),
                    ...getControl(value)
                }, this.current);
            }
            else if (typeof key === 'string' &&
                getControl(key) &&
                typeof value === 'object') {
                button = new button_ToolbarButton(this.toolbar, {
                    name: key.toString(),
                    ...getControl(key),
                    ...value
                }, this.current);
            }
            else {
                button = new button_ToolbarButton(this.toolbar, {
                    name: key.toString(),
                    exec: control.exec,
                    command: control.command,
                    isActive: control.isActiveChild,
                    isDisable: control.isDisableChild,
                    mode: control.mode,
                    args: [
                        (control.args && control.args[0]) || key,
                        (control.args && control.args[1]) || value
                    ]
                }, this.current);
                const template = control.template || this.defaultControl.template;
                button.textBox.innerHTML = template(this.jodit, key.toString(), value.toString());
            }
            this.toolbar.appendChild(button);
        });
        this.container.appendChild(this.toolbar.container);
        this.container.style.removeProperty('marginLeft');
        this.toolbar.checkActiveButtons();
    }
    firstInFocus() {
        this.toolbar.firstButton.focus();
    }
    destruct() {
        if (this.isDestructed) {
            return;
        }
        this.doClose();
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/toolbar/button.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */








class button_ToolbarButton extends element_ToolbarElement {
    constructor(parentToolbarOrView, control, target) {
        super(parentToolbarOrView);
        this.__disabled = false;
        this.__actived = false;
        this.onMouseDown = (originalEvent) => {
            var _a, _b;
            if (originalEvent.type === 'keydown' &&
                originalEvent.which !== KEY_ENTER) {
                return;
            }
            originalEvent.stopImmediatePropagation();
            originalEvent.preventDefault();
            if (this.disable) {
                return false;
            }
            const control = this.control, getTarget = () => (this.parentToolbar && this.parentToolbar.getTarget(this)) ||
                this.target ||
                false;
            if (control.list) {
                const list = new list_PopupList(this.jodit, this.container, this.target);
                list.open(control);
                this.jodit.events.fire('closeAllPopups', list.container);
                this.anchor.setAttribute('aria-expanded', 'true');
                this.jodit.events.on(list, 'afterClose', () => {
                    this.anchor.setAttribute('aria-expanded', 'false');
                });
            }
            else if (control.exec !== undefined &&
                typeof control.exec === 'function') {
                control.exec(this.jodit, getTarget(), control, originalEvent, this
                    .container);
                (_a = this.jodit) === null || _a === void 0 ? void 0 : _a.events.fire('synchro');
                if (this.parentToolbar) {
                    this.parentToolbar.immediateCheckActiveButtons();
                }
                (_b = this.jodit) === null || _b === void 0 ? void 0 : _b.events.fire('closeAllPopups afterExec');
            }
            else if (control.popup !== undefined &&
                typeof control.popup === 'function') {
                const popup = new popup_Popup(this.jodit, this.container, this.target);
                if (this.jodit.events.fire(camelCase(`before-${control.name}-OpenPopup`), getTarget(), control, popup) !== false) {
                    const popupElm = control.popup(this.jodit, getTarget(), control, popup.close, this);
                    if (popupElm) {
                        popup.open(popupElm);
                    }
                }
                this.jodit.events.fire(camelCase(`after-${control.name}-OpenPopup`) +
                    ' closeAllPopups', popup.container);
            }
            else {
                if (control.command || control.name) {
                    if (isJoditObject(this.jodit)) {
                        this.jodit.execCommand(control.command || control.name, (control.args && control.args[0]) || false, (control.args && control.args[1]) || null);
                    }
                    else {
                        this.jodit.ownerDocument.execCommand(control.command || control.name, (control.args && control.args[0]) || false, (control.args && control.args[1]) || null);
                    }
                    this.jodit.events.fire('closeAllPopups');
                }
            }
        };
        this.control = control;
        this.target = target;
        this.anchor = this.jodit.create.element('a', {
            role: 'button',
            href: 'javascript:void(0)'
        });
        let tabIndex = '-1';
        if (this.jodit.options.allowTabNavigation) {
            tabIndex = '0';
        }
        this.anchor.setAttribute('tabindex', tabIndex);
        this.container.appendChild(this.anchor);
        if (this.jodit.options.showTooltip && control.tooltip) {
            if (!this.jodit.options.useNativeTooltip) {
                const to = this.jodit.options.showTooltipDelay ||
                    this.jodit.defaultTimeout;
                let timeout = 0;
                this.jodit.events
                    .on(this.anchor, 'mouseenter', () => {
                    timeout = this.jodit.async.setTimeout(() => {
                        var _a;
                        return !this.isDisable() && ((_a = this.jodit) === null || _a === void 0 ? void 0 : _a.events.fire('showTooltip', this.anchor, this.tooltipText));
                    }, {
                        timeout: to,
                        label: 'tooltip'
                    });
                })
                    .on(this.anchor, 'mouseleave', () => {
                    this.jodit.async.clearTimeout(timeout);
                    this.jodit.events.fire('hideTooltip');
                });
            }
            else {
                this.anchor.setAttribute('title', this.tooltipText);
            }
            this.anchor.setAttribute('aria-label', this.tooltipText);
        }
        this.textBox = this.jodit.create.span();
        this.anchor.appendChild(this.textBox);
        const clearName = control.name.replace(/[^a-zA-Z0-9]/g, '_');
        if (control.getContent && typeof control.getContent === 'function') {
            Dom_Dom.detach(this.container);
            const content = control.getContent(this.jodit, control, this);
            this.container.appendChild(typeof content === 'string'
                ? this.jodit.create.fromHTML(content)
                : content);
        }
        else {
            if (control.list && this.anchor) {
                const trigger = this.jodit.create.fromHTML(ToolbarIcon.getIcon('dropdown-arrow'));
                trigger.classList.add('jodit_with_dropdownlist-trigger');
                this.container.classList.add('jodit_with_dropdownlist');
                this.anchor.appendChild(trigger);
            }
            this.textBox.appendChild(this.createIcon(clearName, control));
        }
        this.container.classList.add('jodit_toolbar_btn-' + clearName);
        if (this.jodit.options.direction) {
            const direction = this.jodit.options.direction.toLowerCase();
            this.container.style.direction =
                direction === 'rtl' ? 'rtl' : 'ltr';
        }
        if (control.isInput) {
            this.container.classList.add('jodit_toolbar-input');
        }
        else {
            this.jodit.events
                .on(this.container, 'mousedown touchend keydown', this.onMouseDown)
                .on(`click-${clearName}-btn`, this.onMouseDown);
        }
    }
    set disable(disable) {
        this.__disabled = disable;
        this.container.classList.toggle('jodit_disabled', disable);
        if (!disable) {
            if (this.container.hasAttribute('disabled')) {
                this.container.removeAttribute('disabled');
            }
        }
        else {
            if (!this.container.hasAttribute('disabled')) {
                this.container.setAttribute('disabled', 'disabled');
            }
        }
    }
    get disable() {
        return this.__disabled;
    }
    set active(enable) {
        this.__actived = enable;
        this.container.classList.toggle('jodit_active', enable);
    }
    get active() {
        return this.__actived;
    }
    isDisable() {
        return Boolean(this.parentToolbar && this.parentToolbar.buttonIsDisabled(this));
    }
    isActive() {
        return Boolean(this.parentToolbar && this.parentToolbar.buttonIsActive(this));
    }
    get tooltipText() {
        if (!this.control.tooltip) {
            return '';
        }
        return (this.jodit.i18n(this.control.tooltip) +
            (this.control.hotkeys
                ? '<br>' + asArray(this.control.hotkeys).join(' ')
                : ''));
    }
    focus() {
        this.anchor.focus();
    }
    destruct() {
        if (this.isDestructed) {
            return;
        }
        this.jodit &&
            this.jodit.events &&
            this.jodit.events.off(this.anchor) &&
            this.jodit.events.off(this.container);
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/toolbar/separator.ts

class separator_ToolbarSeparator extends element_ToolbarElement {
    constructor(jodit) {
        super(jodit);
        this.container.classList.add('jodit_toolbar_btn-separator');
    }
}

// CONCATENATED MODULE: ./src/modules/toolbar/collection.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */








class collection_ToolbarCollection extends Component_Component {
    constructor(jodit) {
        super(jodit);
        this.__buttons = [];
        this.__getControlType = (button) => {
            let buttonControl;
            const controls = this.jodit.options.controls || Config_Config.defaultOptions.controls;
            if (typeof button !== 'string') {
                buttonControl = { name: 'empty', ...button };
                if (controls[buttonControl.name] !== undefined) {
                    buttonControl = {
                        ...controls[buttonControl.name],
                        ...buttonControl
                    };
                }
            }
            else {
                const list = button.split(/\./);
                let store = controls;
                if (list.length > 1) {
                    if (controls[list[0]] !== undefined) {
                        store = controls[list[0]];
                        button = list[1];
                    }
                }
                if (store[button] !== undefined) {
                    buttonControl = { name: button, ...store[button] };
                }
                else {
                    buttonControl = {
                        name: button,
                        command: button,
                        tooltip: button
                    };
                }
            }
            return buttonControl;
        };
        this.closeAll = () => {
            this.jodit &&
                this.jodit.events &&
                this.jodit.events.fire('closeAllPopups');
        };
        this.initEvents = () => {
            this.jodit.events
                .on(this.jodit.ownerWindow, 'mousedown touchend', this.closeAll)
                .on(this.listenEvents, this.checkActiveButtons)
                .on('afterSetMode focus', this.immediateCheckActiveButtons);
        };
        this.listenEvents = 'changeStack mousedown mouseup keydown change afterInit readonly afterResize ' +
            'selectionchange changeSelection focus afterSetMode touchstart focus blur';
        this.immediateCheckActiveButtons = () => {
            if (this.isDestructed || this.jodit.isLocked()) {
                return;
            }
            this.__buttons.filter((button) => button instanceof button_ToolbarButton).forEach((button) => {
                button.disable = button.isDisable();
                if (!button.disable) {
                    button.active = button.isActive();
                }
                if (typeof button.control.getLabel === 'function') {
                    button.control.getLabel(this.jodit, button.control, button);
                }
            });
            this.jodit.events && this.jodit.events.fire('updateToolbar');
        };
        this.checkActiveButtons = debounce(this.immediateCheckActiveButtons, this.jodit.defaultTimeout);
        this.container = this.jodit.create.element('ul');
        this.container.classList.add('jodit_toolbar');
        this.initEvents();
    }
    getButtonsList() {
        return this.__buttons
            .map((a) => a instanceof button_ToolbarButton ? a.control.name : '')
            .filter(a => a !== '');
    }
    getParentContainer() {
        return this.__parentContainer;
    }
    appendChild(button) {
        this.__buttons.push(button);
        this.container.appendChild(button.container);
    }
    get firstButton() {
        return this.__buttons[0];
    }
    removeChild(button) {
        const index = this.__buttons.indexOf(button);
        if (index !== -1) {
            this.__buttons.splice(index, 1);
            if (button.container.parentNode === this.container) {
                Dom_Dom.safeRemove(button.container);
            }
        }
    }
    applyContainerOptions() {
        this.container.classList.add('jodit_' + (this.jodit.options.theme || 'default') + '_theme');
        this.jodit.container.classList.toggle('jodit_text_icons', this.jodit.options.textIcons);
        this.container.classList.toggle('jodit_text_icons', this.jodit.options.textIcons);
        if (this.jodit.options.zIndex) {
            this.container.style.zIndex = parseInt(this.jodit.options.zIndex.toString(), 10).toString();
        }
        const bs = (this.jodit.options.toolbarButtonSize || 'middle').toLowerCase();
        this.container.classList.add('jodit_toolbar_size-' +
            (['middle', 'large', 'small'].indexOf(bs) !== -1
                ? bs
                : 'middle'));
    }
    build(buttons, parentContainer, target) {
        this.applyContainerOptions();
        this.jodit.events.off('rebuildToolbar');
        this.jodit.events.on('afterInit rebuildToolbar', () => this.build(buttons, parentContainer, target));
        this.__parentContainer = parentContainer;
        let lastBtnSeparator = false;
        this.clear();
        const buttonsList = typeof buttons === 'string' ? buttons.split(/[,\s]+/) : buttons;
        buttonsList
            .map(this.__getControlType)
            .forEach((buttonControl) => {
            let button = null;
            if (this.jodit.options.removeButtons.indexOf(buttonControl.name) !== -1) {
                return;
            }
            switch (buttonControl.name) {
                case '\n':
                    button = new break_ToolbarBreak(this);
                    break;
                case '|':
                    if (!lastBtnSeparator) {
                        lastBtnSeparator = true;
                        button = new separator_ToolbarSeparator(this);
                    }
                    break;
                default:
                    lastBtnSeparator = false;
                    button = new button_ToolbarButton(this, buttonControl, target);
            }
            if (button) {
                this.appendChild(button);
            }
        });
        if (this.container.parentNode !== parentContainer) {
            parentContainer.appendChild(this.container);
        }
        this.immediateCheckActiveButtons();
    }
    clear() {
        [...this.__buttons].forEach((button) => {
            this.removeChild(button);
            button.destruct();
        });
        this.__buttons.length = 0;
    }
    buttonIsActive(button) {
        if (isJoditObject(this.jodit) && !this.jodit.editorIsActive) {
            return false;
        }
        if (typeof button.control.isActive === 'function') {
            return button.control.isActive(this.jodit, button.control, button);
        }
    }
    buttonIsDisabled(button) {
        if (this.jodit.options.disabled) {
            return true;
        }
        if (this.jodit.options.readonly &&
            (!this.jodit.options.activeButtonsInReadOnly ||
                this.jodit.options.activeButtonsInReadOnly.indexOf(button.control.name) === -1)) {
            return true;
        }
        let isDisabled;
        if (typeof button.control.isDisable === 'function') {
            isDisabled = button.control.isDisable(this.jodit, button.control, button);
        }
        return isDisabled;
    }
    getTarget(button) {
        return button.target;
    }
    setDirection(direction) {
        this.container.style.direction = direction;
        this.container.setAttribute('dir', direction);
    }
    destruct() {
        if (this.isDestructed) {
            return;
        }
        this.jodit.events
            .off(this.jodit.ownerWindow, 'mousedown touchstart', this.closeAll)
            .off(this.listenEvents, this.checkActiveButtons)
            .off('afterSetMode focus', this.immediateCheckActiveButtons);
        this.clear();
        Dom_Dom.safeRemove(this.container);
        delete this.container;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/toolbar/joditToolbarCollection.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





class joditToolbarCollection_JoditToolbarCollection extends collection_ToolbarCollection {
    constructor() {
        super(...arguments);
        this.checkActiveStatus = (cssObject, node) => {
            let matches = 0, total = 0;
            Object.keys(cssObject).forEach((cssProperty) => {
                const cssValue = cssObject[cssProperty];
                if (typeof cssValue === 'function') {
                    if (cssValue(this.jodit, css_css(node, cssProperty).toString())) {
                        matches += 1;
                    }
                }
                else {
                    if (cssValue.indexOf(css_css(node, cssProperty).toString()) !== -1) {
                        matches += 1;
                    }
                }
                total += 1;
            });
            return total === matches;
        };
    }
    buttonIsActive(button) {
        const active = super.buttonIsActive(button);
        if (active !== undefined) {
            return active;
        }
        const element = this.jodit.selection
            ? this.jodit.selection.current()
            : false;
        if (!element) {
            return false;
        }
        let tags, elm, css;
        if (button.control.tags ||
            (button.control.options && button.control.options.tags)) {
            tags =
                button.control.tags ||
                    (button.control.options && button.control.options.tags);
            elm = element;
            if (Dom_Dom.up(elm, (node) => {
                if (node &&
                    tags.indexOf(node.nodeName.toLowerCase()) !== -1) {
                    return true;
                }
            }, this.jodit.editor)) {
                return true;
            }
        }
        if (button.control.css ||
            (button.control.options && button.control.options.css)) {
            css =
                button.control.css ||
                    (button.control.options && button.control.options.css);
            elm = element;
            if (Dom_Dom.up(elm, (node) => {
                if (node && node.nodeType !== Node.TEXT_NODE) {
                    return this.checkActiveStatus(css, node);
                }
            }, this.jodit.editor)) {
                return true;
            }
        }
        return false;
    }
    buttonIsDisabled(button) {
        const disabled = super.buttonIsDisabled(button);
        if (disabled !== undefined) {
            return disabled;
        }
        const mode = button.control === undefined || button.control.mode === undefined
            ? MODE_WYSIWYG
            : button.control.mode;
        return !(mode === MODE_SPLIT || mode === this.jodit.getRealMode());
    }
    getTarget(button) {
        return button.target || this.jodit.selection.current() || undefined;
    }
    static makeCollection(jodit) {
        const collection = isJoditObject(jodit)
            ? new joditToolbarCollection_JoditToolbarCollection(jodit)
            : new collection_ToolbarCollection(jodit);
        if (jodit.options.textIcons) {
            collection.container.classList.add('jodit_text_icons');
        }
        return collection;
    }
}

// CONCATENATED MODULE: ./src/modules/view/viewWithToolbar.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





class viewWithToolbar_ViewWithToolbar extends view_View {
    constructor() {
        super(...arguments);
        this.__toolbar = joditToolbarCollection_JoditToolbarCollection.makeCollection(this);
    }
    get toolbar() {
        return this.__toolbar;
    }
    setPanel(element) {
        this.jodit.options.toolbar = element;
        this.buildToolbar(this.container);
    }
    buildToolbar(container) {
        if (!this.options.toolbar) {
            return;
        }
        let toolbarContainer = container.querySelector('.jodit_toolbar_container');
        if (!toolbarContainer) {
            toolbarContainer = this.create.div('jodit_toolbar_container');
            Dom_Dom.appendChildFirst(container, toolbarContainer);
        }
        if (this.options.toolbar instanceof HTMLElement ||
            typeof this.options.toolbar === 'string') {
            toolbarContainer = this.resolveElement(this.options.toolbar);
        }
        this.toolbar.build(splitArray(this.options.buttons).concat(this.options.extraButtons), toolbarContainer);
    }
    destruct() {
        this.setStatus(STATUSES.beforeDestruct);
        this.toolbar.destruct();
        delete this.__toolbar;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/PluginSystem.ts

class PluginSystem_PluginSystem {
    constructor() {
        this.items = new Map();
    }
    add(name, plugin) {
        this.items.set(name.toLowerCase(), plugin);
    }
    get(name) {
        return this.items.get(name.toLowerCase());
    }
    remove(name) {
        this.items.delete(name.toLowerCase());
    }
    async init(jodit) {
        const extrasList = jodit.options.extraPlugins.map(s => {
            return isString(s) ? { name: s.toLowerCase() } : s;
        }), disableList = splitArray(jodit.options.disablePlugins).map(s => s.toLowerCase()), doneList = [], promiseList = {}, plugins = [], pluginsMap = {}, makeAndInit = (plugin, name) => {
            if (disableList.includes(name) ||
                doneList.includes(name) ||
                promiseList[name]) {
                return;
            }
            const instance = PluginSystem_PluginSystem.makePluginInstance(jodit, plugin);
            this.initOrWait(jodit, name, instance, doneList, promiseList);
            plugins.push(instance);
            pluginsMap[name] = instance;
        };
        if (extrasList && extrasList.length) {
            try {
                const needLoadExtras = extrasList.filter(extra => !this.items.has(extra.name));
                if (needLoadExtras.length) {
                    await this.load(jodit, needLoadExtras);
                }
            }
            catch (e) {
                console.log(e);
            }
        }
        if (jodit.isInDestruct) {
            return;
        }
        this.items.forEach(makeAndInit);
        this.addListenerOnBeforeDestruct(jodit, plugins);
        jodit.__plugins = pluginsMap;
    }
    static makePluginInstance(jodit, plugin) {
        return isFunction(plugin) ? new plugin(jodit) : plugin;
    }
    initOrWait(jodit, pluginName, instance, doneList, promiseList) {
        const initPlugin = (name, plugin) => {
            if (plugin.hasStyle) {
                PluginSystem_PluginSystem.loadStyle(jodit, name);
            }
            if (isInitable(plugin)) {
                if (!plugin.requires ||
                    !plugin.requires.length ||
                    plugin.requires.every(name => doneList.includes(name))) {
                    plugin.init(jodit);
                    doneList.push(name);
                }
                else {
                    promiseList[name] = plugin;
                    return false;
                }
            }
            else {
                doneList.push(name);
            }
            return true;
        };
        initPlugin(pluginName, instance);
        Object.keys(promiseList).forEach(name => {
            const plugin = promiseList[name];
            if (!plugin) {
                return;
            }
            if (initPlugin(name, instance)) {
                promiseList[name] = undefined;
                delete promiseList[name];
            }
        });
    }
    addListenerOnBeforeDestruct(jodit, plugins) {
        jodit.events.on('beforeDestruct', () => {
            plugins.forEach(instance => {
                if (isDestructable(instance)) {
                    instance.destruct(jodit);
                }
            });
            plugins.length = 0;
            delete jodit.__plugins;
        });
    }
    load(jodit, pluginList) {
        const reflect = (p) => p.then((v) => ({ v, status: 'fulfilled' }), (e) => ({ e, status: 'rejected' }));
        return Promise.all(pluginList.map(extra => {
            const url = extra.url || PluginSystem_PluginSystem.getFullUrl(jodit, name, true);
            return reflect(appendScriptAsync(jodit, url));
        }));
    }
    static loadStyle(jodit, pluginName) {
        return appendStyleAsync(jodit, PluginSystem_PluginSystem.getFullUrl(jodit, pluginName, false));
    }
    static getFullUrl(jodit, name, js) {
        return (jodit.basePath +
            'plugins/' +
            name +
            '/' +
            name +
            '.' +
            (js ? 'js' : 'css'));
    }
}

// CONCATENATED MODULE: ./src/Jodit.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */














const SAFE_COUNT_CHANGE_CALL = 10;
class Jodit_Jodit extends viewWithToolbar_ViewWithToolbar {
    constructor(element, options) {
        super(undefined, options);
        this.__defaultStyleDisplayKey = 'data-jodit-default-style-display';
        this.__defaultClassesKey = 'data-jodit-default-classes';
        this.commands = {};
        this.__selectionLocked = null;
        this.__wasReadOnly = false;
        this.storage = storage_Storage.makeStorage(true, this.id);
        this.editorIsActive = false;
        this.__mode = MODE_WYSIWYG;
        this.__callChangeCount = 0;
        this.elementToPlace = new Map();
        try {
            this.resolveElement(element);
        }
        catch (e) {
            this.destruct();
            throw e;
        }
        this.setStatus(STATUSES.beforeInit);
        if (this.options.events) {
            Object.keys(this.options.events).forEach((key) => this.events.on(key, this.options.events[key]));
        }
        this.events.on(this.ownerWindow, 'resize', () => {
            if (this.events) {
                this.events.fire('resize');
            }
        });
        this.selection = new Selection_Select(this);
        this.initPlugins();
        this.places.length = 0;
        const addPlaceResult = this.addPlace(element, options);
        Jodit_Jodit.instances[this.id] = this;
        const init = () => {
            if (this.events) {
                this.events.fire('afterInit', this);
            }
            this.afterInitHook();
            this.setStatus(STATUSES.ready);
            this.events.fire('afterConstructor', this);
        };
        if (isPromise(addPlaceResult)) {
            addPlaceResult.finally(init);
        }
        else {
            init();
        }
    }
    get isJodit() {
        return true;
    }
    get text() {
        if (this.editor) {
            return this.editor.innerText || '';
        }
        const div = this.create.inside.div();
        div.innerHTML = this.getElementValue();
        return div.innerText || '';
    }
    get value() {
        return this.getEditorValue();
    }
    set value(html) {
        this.setEditorValue(html);
    }
    get defaultTimeout() {
        return this.options && this.options.observer
            ? this.options.observer.timeout
            : Jodit_Jodit.defaultOptions.observer.timeout;
    }
    static Array(array) {
        return new JoditArray_JoditArray(array);
    }
    static Object(object) {
        return new JoditObject_JoditObject(object);
    }
    static fireEach(events, ...args) {
        Object.keys(Jodit_Jodit.instances).forEach(key => {
            const editor = Jodit_Jodit.instances[key];
            if (!editor.isDestructed && editor.events) {
                editor.events.fire(events, ...args);
            }
        });
    }
    static make(element, options) {
        return new Jodit_Jodit(element, options);
    }
    setPlaceField(field, value) {
        if (!this.currentPlace) {
            this.currentPlace = {};
            this.places = [this.currentPlace];
        }
        this.currentPlace[field] = value;
    }
    get element() {
        return this.currentPlace.element;
    }
    get editor() {
        return this.currentPlace.editor;
    }
    set editor(editor) {
        this.setPlaceField('editor', editor);
    }
    get container() {
        return this.currentPlace.container;
    }
    set container(container) {
        this.setPlaceField('container', container);
    }
    get workplace() {
        return this.currentPlace.workplace;
    }
    get statusbar() {
        return this.currentPlace.statusbar;
    }
    get iframe() {
        return this.currentPlace.iframe;
    }
    set iframe(iframe) {
        this.setPlaceField('iframe', iframe);
    }
    get observer() {
        return this.currentPlace.observer;
    }
    get editorWindow() {
        return this.currentPlace.editorWindow;
    }
    set editorWindow(win) {
        this.setPlaceField('editorWindow', win);
    }
    get editorDocument() {
        return this.currentPlace.editorWindow.document;
    }
    get uploader() {
        return this.getInstance('Uploader');
    }
    get filebrowser() {
        return this.getInstance('FileBrowser');
    }
    get mode() {
        return this.__mode;
    }
    set mode(mode) {
        this.setMode(mode);
    }
    getNativeEditorValue() {
        let value;
        value = this.events.fire('beforeGetNativeEditorValue');
        if (isString(value)) {
            return value;
        }
        if (this.editor) {
            return this.editor.innerHTML;
        }
        return this.getElementValue();
    }
    setNativeEditorValue(value) {
        if (this.events.fire('beforeSetNativeEditorValue', value)) {
            return;
        }
        if (this.editor) {
            this.editor.innerHTML = value;
        }
    }
    getEditorValue(removeSelectionMarkers = true) {
        let value;
        value = this.events.fire('beforeGetValueFromEditor');
        if (value !== undefined) {
            return value;
        }
        value = this.getNativeEditorValue().replace(INVISIBLE_SPACE_REG_EXP, '');
        if (removeSelectionMarkers) {
            value = value.replace(/<span[^>]+id="jodit_selection_marker_[^>]+><\/span>/g, '');
        }
        if (value === '<br>') {
            value = '';
        }
        const new_value = { value };
        this.events.fire('afterGetValueFromEditor', new_value);
        return new_value.value;
    }
    setEditorValue(value) {
        const newValue = this.events.fire('beforeSetValueToEditor', value);
        if (newValue === false) {
            return;
        }
        if (typeof newValue === 'string') {
            value = newValue;
        }
        if (!this.editor) {
            if (value !== undefined) {
                this.setElementValue(value);
            }
            return;
        }
        if (typeof value !== 'string' && value !== undefined) {
            throw type_error('value must be string');
        }
        if (value !== undefined && this.getNativeEditorValue() !== value) {
            this.setNativeEditorValue(value);
        }
        const old_value = this.getElementValue(), new_value = this.getEditorValue();
        if (old_value !== new_value &&
            this.__callChangeCount < SAFE_COUNT_CHANGE_CALL) {
            this.setElementValue(new_value);
            this.__callChangeCount += 1;
            try {
                this.events.fire('change', new_value, old_value);
                this.events.fire(this.observer, 'change', new_value, old_value);
            }
            finally {
                this.__callChangeCount = 0;
            }
        }
    }
    getElementValue() {
        return this.element.value !== undefined
            ? this.element.value
            : this.element.innerHTML;
    }
    setElementValue(value) {
        if (!isString(value) && value !== undefined) {
            throw type_error('value must be string');
        }
        if (value !== undefined) {
            if (this.element !== this.container) {
                if (this.element.value !== undefined) {
                    this.element.value = value;
                }
                else {
                    this.element.innerHTML = value;
                }
            }
        }
        else {
            value = this.getElementValue();
        }
        if (value !== this.getEditorValue()) {
            this.setEditorValue(value);
        }
    }
    registerCommand(commandNameOriginal, command) {
        const commandName = commandNameOriginal.toLowerCase();
        if (this.commands[commandName] === undefined) {
            this.commands[commandName] = [];
        }
        this.commands[commandName].push(command);
        if (typeof command !== 'function') {
            const hotkeys = this.options.commandToHotkeys[commandName] ||
                this.options.commandToHotkeys[commandNameOriginal] ||
                command.hotkeys;
            if (hotkeys) {
                this.registerHotkeyToCommand(hotkeys, commandName);
            }
        }
        return this;
    }
    registerHotkeyToCommand(hotkeys, commandName) {
        const shortcuts = asArray(hotkeys)
            .map(normalizeKeyAliases)
            .map(hotkey => hotkey + '.hotkey')
            .join(' ');
        this.events.off(shortcuts).on(shortcuts, () => {
            return this.execCommand(commandName);
        });
    }
    execCommand(command, showUI = false, value = null) {
        if (this.options.readonly && command !== 'selectall') {
            return;
        }
        let result;
        command = command.toLowerCase();
        result = this.events.fire('beforeCommand', command, showUI, value);
        if (result !== false) {
            result = this.execCustomCommands(command, showUI, value);
        }
        if (result !== false) {
            this.selection.focus();
            if (command === 'selectall') {
                this.selection.select(this.editor, true);
            }
            else {
                try {
                    result = this.editorDocument.execCommand(command, showUI, value);
                }
                catch (_a) { }
            }
        }
        this.events.fire('afterCommand', command, showUI, value);
        this.setEditorValue();
        return result;
    }
    execCustomCommands(commandName, second = false, third = null) {
        commandName = commandName.toLowerCase();
        if (this.commands[commandName] !== undefined) {
            let result;
            const exec = (command) => {
                let callback;
                if (typeof command === 'function') {
                    callback = command;
                }
                else {
                    callback = command.exec;
                }
                const resultCurrent = callback.call(this, commandName, second, third);
                if (resultCurrent !== undefined) {
                    result = resultCurrent;
                }
            };
            for (let i = 0; i < this.commands[commandName].length; i += 1) {
                exec(this.commands[commandName][i]);
            }
            return result;
        }
    }
    lock(name = 'any') {
        if (super.lock(name)) {
            this.__selectionLocked = this.selection.save();
            this.editor.classList.add('jodit_disabled');
            return true;
        }
        return false;
    }
    unlock() {
        if (super.unlock()) {
            this.editor.classList.remove('jodit_disabled');
            if (this.__selectionLocked) {
                this.selection.restore(this.__selectionLocked);
            }
            return true;
        }
        return false;
    }
    getMode() {
        return this.mode;
    }
    isEditorMode() {
        return this.getRealMode() === MODE_WYSIWYG;
    }
    getRealMode() {
        if (this.getMode() !== MODE_SPLIT) {
            return this.getMode();
        }
        const active = this.ownerDocument.activeElement;
        if (active &&
            (Dom_Dom.isOrContains(this.editor, active) ||
                Dom_Dom.isOrContains(this.toolbar.container, active))) {
            return MODE_WYSIWYG;
        }
        return MODE_SOURCE;
    }
    setMode(mode) {
        const oldmode = this.getMode();
        const data = {
            mode: parseInt(mode.toString(), 10)
        }, modeClasses = [
            'jodit_wysiwyg_mode',
            'jodit_source_mode',
            'jodit_split_mode'
        ];
        if (this.events.fire('beforeSetMode', data) === false) {
            return;
        }
        this.__mode = inArray(data.mode, [
            MODE_SOURCE,
            MODE_WYSIWYG,
            MODE_SPLIT
        ])
            ? data.mode
            : MODE_WYSIWYG;
        if (this.options.saveModeInStorage) {
            this.storage.set('jodit_default_mode', this.mode);
        }
        modeClasses.forEach(className => {
            this.container.classList.remove(className);
        });
        this.container.classList.add(modeClasses[this.mode - 1]);
        if (oldmode !== this.getMode()) {
            this.events.fire('afterSetMode');
        }
    }
    toggleMode() {
        let mode = this.getMode();
        if (inArray(mode + 1, [
            MODE_SOURCE,
            MODE_WYSIWYG,
            this.options.useSplitMode ? MODE_SPLIT : 9
        ])) {
            mode += 1;
        }
        else {
            mode = MODE_WYSIWYG;
        }
        this.setMode(mode);
    }
    setDisabled(isDisabled) {
        this.options.disabled = isDisabled;
        const readOnly = this.__wasReadOnly;
        this.setReadOnly(isDisabled || readOnly);
        this.__wasReadOnly = readOnly;
        if (this.editor) {
            this.editor.setAttribute('aria-disabled', isDisabled.toString());
            this.container.classList.toggle('jodit_disabled', isDisabled);
            this.events.fire('disabled', isDisabled);
        }
    }
    getDisabled() {
        return this.options.disabled;
    }
    setReadOnly(isReadOnly) {
        if (this.__wasReadOnly === isReadOnly) {
            return;
        }
        this.__wasReadOnly = isReadOnly;
        this.options.readonly = isReadOnly;
        if (isReadOnly) {
            this.editor && this.editor.removeAttribute('contenteditable');
        }
        else {
            this.editor && this.editor.setAttribute('contenteditable', 'true');
        }
        this.events && this.events.fire('readonly', isReadOnly);
    }
    getReadOnly() {
        return this.options.readonly;
    }
    beforeInitHook() {
    }
    afterInitHook() {
    }
    initOptions(options) {
        this.options = new OptionsDefault(options);
    }
    initOwners() {
        this.editorWindow = this.options.ownerWindow;
        this.ownerDocument = this.options.ownerDocument;
        this.ownerWindow = this.options.ownerWindow;
    }
    addPlace(source, options) {
        const element = this.resolveElement(source);
        if (!this.places.length) {
            this.id =
                element.getAttribute('id') || new Date().getTime().toString();
            Jodit_Jodit.instances[this.id] = this;
        }
        if (element.attributes) {
            Array.from(element.attributes).forEach((attr) => {
                const name = attr.name;
                let value = attr.value;
                if (Jodit_Jodit.defaultOptions[name] !== undefined &&
                    (!options || options[name] === undefined)) {
                    if (['readonly', 'disabled'].indexOf(name) !== -1) {
                        value = value === '' || value === 'true';
                    }
                    if (/^[0-9]+(\.)?([0-9]+)?$/.test(value.toString())) {
                        value = Number(value);
                    }
                    this.options[name] = value;
                }
            });
        }
        let container = this.create.div('jodit_container');
        container.classList.add('jodit_container');
        container.setAttribute('contenteditable', 'false');
        let buffer = null;
        if (this.options.inline) {
            if (['TEXTAREA', 'INPUT'].indexOf(element.nodeName) === -1) {
                container = element;
                element.setAttribute(this.__defaultClassesKey, element.className.toString());
                buffer = container.innerHTML;
                container.innerHTML = '';
            }
            container.classList.add('jodit_inline');
            container.classList.add('jodit_container');
        }
        if (element !== container) {
            if (element.style.display) {
                element.setAttribute(this.__defaultStyleDisplayKey, element.style.display);
            }
            // using display none means that other Ampletracks code treats this as hidden on form submission
            // but it may not actually be hidden - or at least the visible editor it is linked to may, or may not be
            // so instead we shift it off the screen
            //element.style.display = 'none';
            element.style.position = 'absolute';
            element.style.left = '-5000px';
        }
        const workplace = this.create.div('jodit_workplace', {
            contenteditable: false
        });
        container.appendChild(workplace);
        const statusbar = new StatusBar_StatusBar(this, container);
        if (element.parentNode && element !== container) {
            element.parentNode.insertBefore(container, element);
        }
        const editor = this.create.div('jodit_wysiwyg', {
            contenteditable: true,
            'aria-disabled': false,
            tabindex: this.options.tabIndex
        });
        workplace.appendChild(editor);
        const currentPlace = {
            editor,
            element,
            container,
            workplace,
            statusbar,
            observer: new observer_Observer(this),
            editorWindow: this.ownerWindow
        };
        this.elementToPlace.set(editor, currentPlace);
        this.setCurrentPlace(currentPlace);
        this.places.push(currentPlace);
        this.setNativeEditorValue(this.getElementValue());
        const opt = this.options;
        const initResult = this.initEditor(buffer);
        const init = () => {
            if (opt.enableDragAndDropFileToEditor &&
                opt.uploader &&
                (opt.uploader.url || opt.uploader.insertImageAsBase64URI)) {
                this.uploader.bind(this.editor);
            }
            if (!this.elementToPlace.get(this.editor)) {
                this.elementToPlace.set(this.editor, currentPlace);
            }
            this.events.fire('afterAddPlace', currentPlace);
        };
        if (isPromise(initResult)) {
            return initResult.then(init);
        }
        init();
    }
    setCurrentPlace(place) {
        if (this.currentPlace === place) {
            return;
        }
        if (!this.isEditorMode()) {
            this.setMode(MODE_WYSIWYG);
        }
        this.currentPlace = place;
        this.buildToolbar(place.container);
        if (this.isReady) {
            this.events.fire('changePlace', place);
        }
    }
    initPlugins() {
        this.beforeInitHook();
        this.events.fire('beforeInit', this);
        try {
            Jodit_Jodit.plugins.init(this);
        }
        catch (e) {
            console.error(e);
        }
    }
    initEditor(buffer) {
        const result = this.createEditor();
        const init = () => {
            if (this.isInDestruct) {
                return;
            }
            if (this.element !== this.container) {
                this.setElementValue();
            }
            else {
                buffer !== null && this.setEditorValue(buffer);
            }
            let mode = this.options.defaultMode;
            if (this.options.saveModeInStorage) {
                const localMode = this.storage.get('jodit_default_mode');
                if (typeof localMode === 'string') {
                    mode = parseInt(localMode, 10);
                }
            }
            this.setMode(mode);
            if (this.options.readonly) {
                this.__wasReadOnly = false;
                this.setReadOnly(true);
            }
            if (this.options.disabled) {
                this.setDisabled(true);
            }
            try {
                this.editorDocument.execCommand('defaultParagraphSeparator', false, this.options.enter.toLowerCase());
            }
            catch (_a) { }
            try {
                this.editorDocument.execCommand('enableObjectResizing', false, 'false');
            }
            catch (_b) { }
            try {
                this.editorDocument.execCommand('enableInlineTableEditing', false, 'false');
            }
            catch (_c) { }
        };
        if (isPromise(result)) {
            return result.then(init);
        }
        init();
    }
    createEditor() {
        const defaultEditorArea = this.editor;
        const stayDefault = this.events.fire('createEditor', this);
        const init = () => {
            if (this.isInDestruct) {
                return;
            }
            if (stayDefault === false || isPromise(stayDefault)) {
                Dom_Dom.safeRemove(defaultEditorArea);
            }
            if (this.options.editorCssClass) {
                this.editor.classList.add(this.options.editorCssClass);
            }
            if (this.options.style) {
                css_css(this.editor, this.options.style);
            }
            const editor = this.editor;
            this.events
                .on('synchro', () => {
                this.setEditorValue();
            })
                .on('focus', () => {
                this.editorIsActive = true;
            })
                .on('blur', () => (this.editorIsActive = false))
                .on(editor, 'mousedown touchstart focus', () => {
                const place = this.elementToPlace.get(editor);
                if (place) {
                    this.setCurrentPlace(place);
                }
            })
                .on(editor, 'selectionchange selectionstart keydown keyup keypress dblclick mousedown mouseup ' +
                'click copy cut dragstart drop dragover paste resize touchstart touchend focus blur', (event) => {
                if (this.options.readonly) {
                    return;
                }
                if (this.events && this.events.fire) {
                    if (this.events.fire(event.type, event) === false) {
                        return false;
                    }
                    this.setEditorValue();
                }
            });
            if (this.options.spellcheck) {
                this.editor.setAttribute('spellcheck', 'true');
            }
            if (this.options.direction) {
                const direction = this.options.direction.toLowerCase() === 'rtl'
                    ? 'rtl'
                    : 'ltr';
                this.editor.style.direction = direction;
                this.container.style.direction = direction;
                this.editor.setAttribute('dir', direction);
                this.container.setAttribute('dir', direction);
                this.toolbar.setDirection(direction);
            }
            if (this.options.triggerChangeEvent) {
                this.events.on('change', debounce(() => {
                    this.events && this.events.fire(this.element, 'change');
                }, this.defaultTimeout));
            }
        };
        if (isPromise(stayDefault)) {
            return stayDefault.then(init);
        }
        init();
    }
    destruct() {
        if (this.isInDestruct) {
            return;
        }
        this.setStatus(STATUSES.beforeDestruct);
        this.async.clear();
        this.elementToPlace.clear();
        if (this.events.fire('beforeDestruct') === false) {
            return;
        }
        if (!this.editor) {
            return;
        }
        const buffer = this.getEditorValue();
        this.storage.clear();
        delete this.storage;
        this.buffer.clear();
        delete this.buffer;
        this.commands = {};
        delete this.selection;
        this.__selectionLocked = null;
        this.events.off(this.ownerWindow, 'resize');
        this.events.off(this.ownerWindow);
        this.events.off(this.ownerDocument);
        this.events.off(this.ownerDocument.body);
        this.components.forEach(component => {
            if (isDestructable(component) && !component.isInDestruct) {
                component.destruct();
            }
        });
        this.components.clear();
        this.places.forEach(({ container, workplace, statusbar, element, iframe, editor, observer }) => {
            if (element !== container) {
                if (element.hasAttribute(this.__defaultStyleDisplayKey)) {
                    const attr = element.getAttribute(this.__defaultStyleDisplayKey);
                    if (attr) {
                        element.style.display = attr;
                        element.removeAttribute(this.__defaultStyleDisplayKey);
                    }
                }
                else {
                    element.style.display = '';
                }
            }
            else {
                if (element.hasAttribute(this.__defaultClassesKey)) {
                    element.className =
                        element.getAttribute(this.__defaultClassesKey) ||
                            '';
                    element.removeAttribute(this.__defaultClassesKey);
                }
            }
            if (element.hasAttribute('style') &&
                !element.getAttribute('style')) {
                element.removeAttribute('style');
            }
            !statusbar.isInDestruct && statusbar.destruct();
            this.events.off(container);
            this.events.off(element);
            this.events.off(editor);
            Dom_Dom.safeRemove(workplace);
            Dom_Dom.safeRemove(editor);
            if (container !== element) {
                Dom_Dom.safeRemove(container);
            }
            Dom_Dom.safeRemove(iframe);
            if (container === element) {
                element.innerHTML = buffer;
            }
            !observer.isInDestruct && observer.destruct();
        });
        this.places.length = 0;
        this.currentPlace = {};
        delete Jodit_Jodit.instances[this.id];
        super.destruct();
    }
}
Jodit_Jodit.plugins = new PluginSystem_PluginSystem();
Jodit_Jodit.modules = {};
Jodit_Jodit.instances = {};
Jodit_Jodit.lang = {};

// EXTERNAL MODULE: ./src/langs/ar.ts
var ar = __webpack_require__(79);
var ar_default = /*#__PURE__*/__webpack_require__.n(ar);

// EXTERNAL MODULE: ./src/langs/cs_cz.ts
var cs_cz = __webpack_require__(80);
var cs_cz_default = /*#__PURE__*/__webpack_require__.n(cs_cz);

// EXTERNAL MODULE: ./src/langs/de.ts
var de = __webpack_require__(81);
var de_default = /*#__PURE__*/__webpack_require__.n(de);

// EXTERNAL MODULE: ./src/langs/en.ts
var en = __webpack_require__(0);
var en_default = /*#__PURE__*/__webpack_require__.n(en);

// EXTERNAL MODULE: ./src/langs/es.ts
var es = __webpack_require__(82);
var es_default = /*#__PURE__*/__webpack_require__.n(es);

// EXTERNAL MODULE: ./src/langs/fr.ts
var fr = __webpack_require__(83);
var fr_default = /*#__PURE__*/__webpack_require__.n(fr);

// EXTERNAL MODULE: ./src/langs/he.ts
var he = __webpack_require__(84);
var he_default = /*#__PURE__*/__webpack_require__.n(he);

// EXTERNAL MODULE: ./src/langs/hu.ts
var hu = __webpack_require__(85);
var hu_default = /*#__PURE__*/__webpack_require__.n(hu);

// EXTERNAL MODULE: ./src/langs/id.ts
var langs_id = __webpack_require__(86);
var id_default = /*#__PURE__*/__webpack_require__.n(langs_id);

// EXTERNAL MODULE: ./src/langs/it.ts
var it = __webpack_require__(87);
var it_default = /*#__PURE__*/__webpack_require__.n(it);

// EXTERNAL MODULE: ./src/langs/ja.ts
var ja = __webpack_require__(88);
var ja_default = /*#__PURE__*/__webpack_require__.n(ja);

// EXTERNAL MODULE: ./src/langs/nl.ts
var nl = __webpack_require__(89);
var nl_default = /*#__PURE__*/__webpack_require__.n(nl);

// EXTERNAL MODULE: ./src/langs/pl.ts
var pl = __webpack_require__(90);
var pl_default = /*#__PURE__*/__webpack_require__.n(pl);

// EXTERNAL MODULE: ./src/langs/pt_br.ts
var pt_br = __webpack_require__(91);
var pt_br_default = /*#__PURE__*/__webpack_require__.n(pt_br);

// EXTERNAL MODULE: ./src/langs/ru.ts
var ru = __webpack_require__(92);
var ru_default = /*#__PURE__*/__webpack_require__.n(ru);

// EXTERNAL MODULE: ./src/langs/tr.ts
var langs_tr = __webpack_require__(93);
var tr_default = /*#__PURE__*/__webpack_require__.n(langs_tr);

// EXTERNAL MODULE: ./src/langs/zh_cn.ts
var zh_cn = __webpack_require__(94);
var zh_cn_default = /*#__PURE__*/__webpack_require__.n(zh_cn);

// EXTERNAL MODULE: ./src/langs/zh_tw.ts
var zh_tw = __webpack_require__(95);
var zh_tw_default = /*#__PURE__*/__webpack_require__.n(zh_tw);

// CONCATENATED MODULE: ./src/langs/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


















const exp = {
    ar: ar_default.a,
    cs_cz: cs_cz_default.a,
    de: de_default.a,
    en: en_default.a,
    es: es_default.a,
    fr: fr_default.a,
    he: he_default.a,
    hu: hu_default.a,
    id: id_default.a,
    it: it_default.a,
    ja: ja_default.a,
    nl: nl_default.a,
    pl: pl_default.a,
    pt_br: pt_br_default.a,
    ru: ru_default.a,
    tr: tr_default.a,
    zh_cn: zh_cn_default.a,
    zh_tw: zh_tw_default.a
};
const get = (value) => value.default || value, hashLang = {};
if (Array.isArray(get(en_default.a))) {
    get(en_default.a).forEach((key, index) => {
        hashLang[index] = key;
    });
}
Object.keys(exp).forEach((lang) => {
    const list = get(exp[lang]);
    if (Array.isArray(list)) {
        exp[lang] = {};
        list.forEach((value, index) => {
            exp[lang][hashLang[index]] = value;
        });
    }
});
/* harmony default export */ var langs = (exp);

// CONCATENATED MODULE: ./src/modules/Ajax.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.defaultAjaxOptions = {
    dataType: 'json',
    method: 'GET',
    url: '',
    data: null,
    contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
    headers: {
        'X-REQUESTED-WITH': 'XMLHttpRequest'
    },
    withCredentials: false,
    xhr() {
        return new XMLHttpRequest();
    }
};
class Ajax_Ajax {
    constructor(editor, options) {
        this.success_response_codes = [200, 201, 202];
        this.jodit = editor;
        this.options = extend(true, {}, Config_Config.prototype.defaultAjaxOptions, options);
        if (this.options.xhr) {
            this.xhr = this.options.xhr();
        }
        editor &&
            editor.events &&
            editor.events.on('beforeDestruct', () => {
                this.abort();
            });
    }
    __buildParams(obj, prefix) {
        if (this.options.queryBuild &&
            typeof this.options.queryBuild === 'function') {
            return this.options.queryBuild.call(this, obj, prefix);
        }
        if (typeof obj === 'string' ||
            (this.jodit.ownerWindow.FormData &&
                obj instanceof this.jodit.ownerWindow.FormData)) {
            return obj;
        }
        return buildQuery(obj);
    }
    abort() {
        try {
            this.xhr.abort();
        }
        catch (_a) { }
        return this;
    }
    send() {
        return new Promise((resolve, reject) => {
            const __parse = (resp) => {
                let result = null;
                if (this.options.dataType === 'json') {
                    result = JSON.parse(resp);
                }
                if (!result) {
                    throw type_error('No JSON format');
                }
                return result;
            };
            this.xhr.onabort = () => {
                reject(type_error(this.xhr.statusText));
            };
            this.xhr.onerror = () => {
                reject(type_error(this.xhr.statusText));
            };
            this.xhr.ontimeout = () => {
                reject(type_error(this.xhr.statusText));
            };
            this.xhr.onload = () => {
                this.response = this.xhr.responseText;
                this.status = this.xhr.status;
                resolve.call(this.xhr, __parse(this.response) || {});
            };
            this.xhr.onreadystatechange = () => {
                if (this.xhr.readyState === XMLHttpRequest.DONE) {
                    const resp = this.xhr.responseText;
                    this.response = resp;
                    this.status = this.xhr.status;
                    if (this.success_response_codes.indexOf(this.xhr.status) > -1) {
                        resolve.call(this.xhr, __parse(resp));
                    }
                    else {
                        reject.call(this.xhr, type_error(this.xhr.statusText ||
                            this.jodit.i18n('Connection error!')));
                    }
                }
            };
            this.xhr.withCredentials =
                this.options.withCredentials || false;
            const { url, data, method } = this.prepareRequest();
            this.xhr.open(method, url, true);
            if (this.options.contentType && this.xhr.setRequestHeader) {
                this.xhr.setRequestHeader('Content-type', this.options.contentType);
            }
            if (this.options.headers && this.xhr.setRequestHeader) {
                each(this.options.headers, (key, value) => {
                    this.xhr.setRequestHeader(key, value);
                });
            }
            setTimeout(() => {
                this.xhr.send(data
                    ? this.__buildParams(data)
                    : undefined);
            }, 0);
        });
    }
    prepareRequest() {
        if (!this.options.url) {
            throw type_error('Need URL for AJAX request');
        }
        let url = this.options.url;
        const data = this.options.data;
        const method = (this.options.method || 'get').toLowerCase();
        if (method === 'get' && data && isPlainObject(data)) {
            const qIndex = url.indexOf('?');
            if (qIndex !== -1) {
                const urlData = parseQuery(url);
                url = url.substr(0, qIndex) + '?' + buildQuery({ ...urlData, ...data });
            }
            else {
                url += '?' + buildQuery(this.options.data);
            }
        }
        const request = {
            url,
            method,
            data
        };
        Ajax_Ajax.log.splice(100);
        Ajax_Ajax.log.push(request);
        return request;
    }
}
Ajax_Ajax.log = [];

// CONCATENATED MODULE: ./src/modules/ContextMenu.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class ContextMenu_ContextMenu extends Component_Component {
    constructor(editor) {
        super(editor);
        this.hide = () => {
            this.context.classList.remove('jodit_context_menu-show');
            this.jodit.ownerWindow.removeEventListener('mouseup', this.hide);
        };
        this.context = editor.create.div('jodit_context_menu');
        editor.ownerDocument.body.appendChild(this.context);
    }
    show(x, y, actions, zIndex) {
        const self = this;
        if (!Array.isArray(actions)) {
            return;
        }
        if (zIndex) {
            this.context.style.zIndex = zIndex.toString();
        }
        this.context.innerHTML = '';
        actions.forEach(item => {
            if (!item) {
                return;
            }
            const title = self.jodit.i18n(item.title || '');
            const action = this.jodit.create.fromHTML(`<a title="${title}" data-icon="${item.icon}"  href="javascript:void(0)">` +
                (item.icon ? ToolbarIcon.getIcon(item.icon) : '') +
                '<span></span></a>');
            const span = action.querySelector('span');
            action.addEventListener('click', (e) => {
                item.exec && item.exec.call(self, e);
                self.hide();
                return false;
            });
            span.textContent = title;
            self.context.appendChild(action);
        });
        css_css(self.context, {
            left: x,
            top: y
        });
        this.jodit.events.on(this.jodit.ownerWindow, 'mouseup jodit_close_dialog', self.hide);
        this.context.classList.add('jodit_context_menu-show');
        this.jodit.markOwner(this.context);
    }
    destruct() {
        this.setStatus(STATUSES.beforeDestruct);
        Dom_Dom.safeRemove(this.context);
        delete this.context;
        this.jodit.events.off(this.jodit.ownerWindow, 'mouseup', this.hide);
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/plugins/add-new-line.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





Config_Config.prototype.addNewLine = true;
Config_Config.prototype.addNewLineOnDBLClick = true;
Config_Config.prototype.addNewLineTagsTriggers = [
    'table',
    'iframe',
    'img',
    'hr',
    'jodit'
];
function addNewLine(editor) {
    if (!editor.options.addNewLine) {
        return;
    }
    const line = editor.create.fromHTML('<div role="button" tabIndex="-1" title="' +
        editor.i18n('Break') +
        '" class="jodit-add-new-line"><span>' +
        ToolbarIcon.getIcon('enter') +
        '</span></div>');
    const delta = 10;
    const isMatchedTag = new RegExp('^(' + editor.options.addNewLineTagsTriggers.join('|') + ')$', 'i');
    let timeout;
    let hidden = false;
    let preview = false;
    let current;
    let lineInFocus = false;
    const show = () => {
        if (editor.options.readonly || editor.isLocked()) {
            return;
        }
        if (editor.container.classList.contains('jodit_popup_active')) {
            return;
        }
        editor.async.clearTimeout(timeout);
        line.classList.toggle('jodit-add-new-line_after', !preview);
        editor.container.appendChild(line);
        line.style.width = editor.editor.clientWidth + 'px';
        hidden = false;
    };
    const hideForce = () => {
        editor.async.clearTimeout(timeout);
        lineInFocus = false;
        Dom_Dom.safeRemove(line);
        hidden = true;
    };
    const canGetFocus = (elm) => {
        return (elm !== null &&
            Dom_Dom.isBlock(elm, editor.editorWindow) &&
            !/^(img|table|iframe|hr)$/i.test(elm.nodeName));
    };
    const hide = () => {
        if (hidden || lineInFocus) {
            return;
        }
        timeout = editor.async.setTimeout(hideForce, {
            timeout: 500,
            label: 'add-new-line-hide'
        });
    };
    editor.events
        .on('beforeDestruct', () => {
        editor.async.clearTimeout(timeout);
        Dom_Dom.safeRemove(line);
        editor.events.off(line);
    })
        .on('afterInit', () => {
        editor.events
            .on(line, 'mousemove', (e) => {
            e.stopPropagation();
        })
            .on(line, 'mousedown touchstart', (e) => {
            const p = editor.create.inside.element(editor.options.enter);
            if (preview && current && current.parentNode) {
                current.parentNode.insertBefore(p, current);
            }
            else {
                editor.editor.appendChild(p);
            }
            editor.selection.setCursorIn(p);
            editor.events.fire('synchro');
            hideForce();
            e.preventDefault();
        });
    })
        .on('afterInit', () => {
        editor.events
            .on(editor.editor, 'scroll', hideForce)
            .on('change', hideForce)
            .on(editor.container, 'mouseleave', hide)
            .on(line, 'mouseenter', () => {
            clearTimeout(timeout);
            lineInFocus = true;
        })
            .on(line, 'mouseleave', () => {
            lineInFocus = false;
        })
            .on(editor.editor, 'dblclick', (e) => {
            if (!editor.options.readonly &&
                editor.options.addNewLineOnDBLClick &&
                e.target === editor.editor &&
                editor.selection.isCollapsed()) {
                const editorBound = offset(editor.editor, editor, editor.editorDocument);
                const top = e.pageY - editor.editorWindow.pageYOffset;
                const p = editor.create.inside.element(editor.options.enter);
                if (Math.abs(top - editorBound.top) <
                    Math.abs(top - (editorBound.height + editorBound.top)) &&
                    editor.editor.firstChild) {
                    editor.editor.insertBefore(p, editor.editor.firstChild);
                }
                else {
                    editor.editor.appendChild(p);
                }
                editor.selection.setCursorIn(p);
                editor.setEditorValue();
                hideForce();
                e.preventDefault();
            }
        })
            .on(editor.editor, 'mousemove', debounce((e) => {
            let currentElement = editor.editorDocument.elementFromPoint(e.pageX - editor.editorWindow.pageXOffset, e.pageY - editor.editorWindow.pageYOffset);
            if (currentElement &&
                Dom_Dom.isOrContains(line, currentElement)) {
                return;
            }
            if (!currentElement ||
                !Dom_Dom.isOrContains(editor.editor, currentElement)) {
                return;
            }
            if (!currentElement ||
                !currentElement.nodeName.match(isMatchedTag) ||
                !Dom_Dom.isOrContains(editor.editor, currentElement)) {
                currentElement = Dom_Dom.closest(currentElement, isMatchedTag, editor.editor);
                if (!currentElement) {
                    hide();
                    return;
                }
            }
            if (isMatchedTag.test(currentElement.nodeName)) {
                const parentBox = Dom_Dom.up(currentElement, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
                if (parentBox && parentBox !== editor.editor) {
                    currentElement = parentBox;
                }
            }
            const editorBound = offset(editor.editor, editor, editor.editorDocument);
            const position = offset(currentElement, editor, editor.editorDocument);
            let top = false;
            if (Math.abs(e.pageY - position.top) < delta) {
                top = position.top;
                if (top - editorBound.top >= 20) {
                    top -= 15;
                }
                preview = true;
            }
            if (Math.abs(e.pageY - (position.top + position.height)) < delta) {
                top = position.top + position.height;
                if (editorBound.top + editorBound.height - top >=
                    25) {
                    top += 15;
                }
                preview = false;
            }
            if (top !== false &&
                ((preview &&
                    !Dom_Dom.prev(currentElement, canGetFocus, editor.editor)) ||
                    (!preview &&
                        !Dom_Dom.next(currentElement, canGetFocus, editor.editor)))) {
                line.style.top = top + 'px';
                current = currentElement;
                show();
            }
            else {
                current = false;
                hide();
            }
        }, editor.defaultTimeout));
    });
}

// CONCATENATED MODULE: ./src/plugins/autofocus.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


Config_Config.prototype.autofocus = false;
function autofocus(editor) {
    editor.events.on('afterInit', () => {
        if (editor.options.autofocus) {
            if (editor.defaultTimeout) {
                editor.async.setTimeout(editor.selection.focus, 300);
            }
            else {
                editor.selection.focus();
            }
        }
    });
    editor.events.on('afterInit afterAddPlace', () => {
        editor.events
            .off(editor.editor, 'mousedown.autofocus')
            .on(editor.editor, 'mousedown.autofocus', (e) => {
            if (editor.isEditorMode() &&
                e.target &&
                Dom_Dom.isBlock(e.target, editor.editorWindow) &&
                !e.target.childNodes.length) {
                if (editor.editor === e.target) {
                    editor.selection.focus();
                }
                else {
                    editor.selection.setCursorIn(e.target);
                }
            }
        });
    });
}

// CONCATENATED MODULE: ./src/plugins/backspace.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




function backspace(editor) {
    const removeEmptyBlocks = (container) => {
        let box = container, parent;
        normalizeNode(container);
        do {
            const html = box.innerHTML.replace(INVISIBLE_SPACE_REG_EXP, '');
            if ((!html.length || html === '<br>') &&
                !Dom_Dom.isCell(box, editor.editorWindow) &&
                box.parentNode &&
                container !== editor.editor) {
                parent = box.parentNode;
                editor.selection.removeNode(box);
            }
            else {
                break;
            }
            box = parent;
        } while (box && box !== editor.editor);
    };
    const removeChar = (box, toLeft, range) => {
        if (box.node &&
            box.node.nodeType === Node.TEXT_NODE &&
            typeof box.node.nodeValue === 'string') {
            let value = box.node.nodeValue, startOffset = toLeft ? value.length : 0;
            const increment = toLeft ? -1 : 1, startOffsetInRange = startOffset;
            while (startOffset >= 0 &&
                startOffset <= value.length &&
                value[startOffset + (toLeft ? -1 : 0)] ===
                    INVISIBLE_SPACE) {
                startOffset += increment;
            }
            if (startOffset !== startOffsetInRange) {
                if (toLeft) {
                    value =
                        value.substr(0, startOffset) +
                            value.substr(startOffsetInRange);
                }
                else {
                    value =
                        value.substr(0, startOffsetInRange) +
                            value.substr(startOffset);
                    startOffset = startOffsetInRange;
                }
                box.node.nodeValue = value;
            }
            range.setStart(box.node, startOffset);
            range.collapse(true);
            editor.selection.selectRange(range);
            let nextElement = Dom_Dom.findInline(box.node, toLeft, editor.editor);
            if (value.length) {
                let setRange = false;
                if (toLeft) {
                    if (startOffset) {
                        setRange = true;
                    }
                }
                else {
                    if (startOffset < value.length) {
                        setRange = true;
                    }
                }
                if (setRange) {
                    return true;
                }
            }
            else {
                range.setStartBefore(box.node);
                range.collapse(true);
                editor.selection.selectRange(range);
                editor.selection.removeNode(box.node);
                box.node = nextElement;
            }
            if (nextElement) {
                if (Dom_Dom.isInlineBlock(nextElement)) {
                    nextElement = toLeft
                        ? nextElement.lastChild
                        : nextElement.firstChild;
                }
                if (nextElement && nextElement.nodeType === Node.TEXT_NODE) {
                    box.node = nextElement;
                    return removeChar(box, toLeft, range);
                }
            }
        }
    };
    const potentialRemovable = MAY_BE_REMOVED_WITH_KEY;
    const removePotential = (node) => {
        if (node && potentialRemovable.test(node.nodeName)) {
            editor.selection.removeNode(node);
            return false;
        }
    };
    const removeInline = (box, toLeft, range) => {
        if (box.node) {
            const workElement = box.node;
            const removeCharFlag = removeChar(box, toLeft, range);
            if (removeCharFlag !== undefined) {
                return true;
            }
            if (!box.node) {
                box.node = workElement.parentNode;
            }
            if (box.node === editor.editor) {
                return false;
            }
            let node = box.node;
            if (removePotential(node) === false) {
                return false;
            }
            if (node) {
                node = toLeft ? node.previousSibling : node.nextSibling;
            }
            while (node &&
                node.nodeType === Node.TEXT_NODE &&
                node.nodeValue &&
                node.nodeValue.match(/^[\n\r]+$/)) {
                node = toLeft ? node.previousSibling : node.nextSibling;
            }
            return removePotential(node);
        }
    };
    const isEmpty = (node) => {
        if (node.nodeName.match(/^(TD|TH|TR|TABLE|LI)$/) !== null) {
            return false;
        }
        if (Dom_Dom.isEmpty(node) ||
            node.nodeName.match(potentialRemovable) !== null) {
            return true;
        }
        if (node.nodeType === Node.TEXT_NODE && !Dom_Dom.isEmptyTextNode(node)) {
            return false;
        }
        return node.childNodes.length
            ? Array.from(node.childNodes).every(isEmpty)
            : true;
    };
    editor.events
        .on('afterCommand', (command) => {
        if (command === 'delete') {
            const current = editor.selection.current();
            if (current &&
                current.firstChild &&
                current.firstChild.nodeName === 'BR') {
                editor.selection.removeNode(current.firstChild);
            }
            if (!trim(editor.editor.textContent || '') &&
                !editor.editor.querySelector('img') &&
                (!current || !Dom_Dom.closest(current, 'table', editor.editor))) {
                editor.editor.innerHTML = '';
                const node = editor.selection.setCursorIn(editor.editor);
                editor.selection.removeNode(node);
            }
        }
    })
        .on('keydown', (event) => {
        if (event.which === KEY_BACKSPACE ||
            event.which === KEY_DELETE) {
            const toLeft = event.which === KEY_BACKSPACE;
            if (!editor.selection.isFocused()) {
                editor.selection.focus();
            }
            if (!editor.selection.isCollapsed()) {
                editor.execCommand('Delete');
                return false;
            }
            const sel = editor.selection.sel, range = sel && sel.rangeCount ? sel.getRangeAt(0) : false;
            if (!range) {
                return false;
            }
            const fakeNode = editor.create.inside.text(INVISIBLE_SPACE);
            const marker = editor.create.inside.span();
            try {
                range.insertNode(fakeNode);
                if (!Dom_Dom.isOrContains(editor.editor, fakeNode)) {
                    return false;
                }
                let container = Dom_Dom.up(fakeNode, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
                const workElement = Dom_Dom.findInline(fakeNode, toLeft, editor.editor);
                const box = {
                    node: workElement
                };
                let tryRemoveInline;
                if (workElement) {
                    tryRemoveInline = removeInline(box, toLeft, range);
                }
                else if (fakeNode.parentNode) {
                    tryRemoveInline = removeInline({
                        node: toLeft
                            ? fakeNode.parentNode.previousSibling
                            : fakeNode.parentNode.nextSibling
                    }, toLeft, range);
                }
                if (tryRemoveInline !== undefined) {
                    return tryRemoveInline ? undefined : false;
                }
                if (container && container.nodeName.match(/^(TD)$/)) {
                    return false;
                }
                let prevBox = toLeft
                    ? Dom_Dom.prev(box.node || fakeNode, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor)
                    : Dom_Dom.next(box.node || fakeNode, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
                if (!prevBox && container && container.parentNode) {
                    prevBox = editor.create.inside.element(editor.options.enter);
                    let boxNode = container;
                    while (boxNode &&
                        boxNode.parentNode &&
                        boxNode.parentNode !== editor.editor) {
                        boxNode = boxNode.parentNode;
                    }
                    boxNode.parentNode &&
                        boxNode.parentNode.insertBefore(prevBox, boxNode);
                }
                else {
                    if (prevBox && isEmpty(prevBox)) {
                        editor.selection.removeNode(prevBox);
                        return false;
                    }
                }
                if (prevBox) {
                    const tmpNode = editor.selection.setCursorIn(prevBox, !toLeft);
                    editor.selection.insertNode(marker, false, false);
                    if (tmpNode.nodeType === Node.TEXT_NODE &&
                        tmpNode.nodeValue === INVISIBLE_SPACE) {
                        Dom_Dom.safeRemove(tmpNode);
                    }
                }
                if (container) {
                    removeEmptyBlocks(container);
                    if (prevBox && container.parentNode) {
                        if (container.nodeName === prevBox.nodeName &&
                            container.parentNode &&
                            prevBox.parentNode &&
                            container.parentNode !== editor.editor &&
                            prevBox.parentNode !== editor.editor &&
                            container.parentNode !==
                                prevBox.parentNode &&
                            container.parentNode.nodeName ===
                                prevBox.parentNode.nodeName) {
                            container = container.parentNode;
                            prevBox = prevBox.parentNode;
                        }
                        Dom_Dom.moveContent(container, prevBox, !toLeft);
                        normalizeNode(prevBox);
                    }
                    if (prevBox && prevBox.nodeName === 'LI') {
                        const UL = Dom_Dom.closest(prevBox, 'Ul|OL', editor.editor);
                        if (UL) {
                            const nextBox = UL.nextSibling;
                            if (nextBox &&
                                nextBox.nodeName === UL.nodeName &&
                                UL !== nextBox) {
                                Dom_Dom.moveContent(nextBox, UL, !toLeft);
                                editor.selection.removeNode(nextBox);
                            }
                        }
                    }
                    removeEmptyBlocks(container);
                    return false;
                }
            }
            finally {
                if (fakeNode.parentNode &&
                    fakeNode.nodeValue === INVISIBLE_SPACE) {
                    const parent = fakeNode.parentNode;
                    Dom_Dom.safeRemove(fakeNode);
                    if (!parent.firstChild &&
                        parent.parentNode &&
                        parent !== editor.editor) {
                        editor.selection.removeNode(parent);
                    }
                }
                if (marker &&
                    Dom_Dom.isOrContains(editor.editor, marker, true)) {
                    const tmpNode = editor.selection.setCursorBefore(marker);
                    Dom_Dom.safeRemove(marker);
                    if (tmpNode &&
                        tmpNode.parentNode &&
                        (Dom_Dom.findInline(tmpNode, true, tmpNode.parentNode) ||
                            Dom_Dom.findInline(tmpNode, true, tmpNode.parentNode))) {
                        Dom_Dom.safeRemove(tmpNode);
                    }
                }
                editor.setEditorValue();
            }
            return false;
        }
    });
}

// CONCATENATED MODULE: ./src/plugins/bold.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

Config_Config.prototype.controls.subscript = {
    tags: ['sub'],
    tooltip: 'subscript'
};
Config_Config.prototype.controls.superscript = {
    tags: ['sup'],
    tooltip: 'superscript'
};
Config_Config.prototype.controls.bold = {
    tagRegExp: /^(strong|b)$/i,
    tags: ['strong', 'b'],
    css: {
        'font-weight': ['bold', '700']
    },
    tooltip: 'Bold'
};
Config_Config.prototype.controls.italic = {
    tagRegExp: /^(em|i)$/i,
    tags: ['em', 'i'],
    css: {
        'font-style': 'italic'
    },
    tooltip: 'Italic'
};
Config_Config.prototype.controls.underline = {
    tagRegExp: /^(u)$/i,
    tags: ['u'],
    css: {
        'text-decoration': 'underline'
    },
    tooltip: 'Underline'
};
Config_Config.prototype.controls.strikethrough = {
    tagRegExp: /^(s)$/i,
    tags: ['s'],
    css: {
        'text-decoration': 'line-through'
    },
    tooltip: 'Strike through'
};
function bold(editor) {
    const callBack = (command) => {
        const control = Config_Config.defaultOptions.controls[command], cssOptions = {
            ...control.css
        }, cssRules = {};
        Object.keys(cssOptions).forEach((key) => {
            cssRules[key] = Array.isArray(cssOptions[key])
                ? cssOptions[key][0]
                : cssOptions[key];
        });
        editor.selection.applyCSS(cssRules, control.tags ? control.tags[0] : undefined, control.css);
        editor.events.fire('synchro');
        return false;
    };
    editor
        .registerCommand('bold', {
        exec: callBack,
        hotkeys: ['ctrl+b', 'cmd+b']
    })
        .registerCommand('italic', {
        exec: callBack,
        hotkeys: ['ctrl+i', 'cmd+i']
    })
        .registerCommand('underline', {
        exec: callBack,
        hotkeys: ['ctrl+u', 'cmd+u']
    })
        .registerCommand('strikethrough', {
        exec: callBack
    });
}

// CONCATENATED MODULE: ./src/plugins/clean-html.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





Config_Config.prototype.cleanHTML = {
    timeout: 300,
    removeEmptyElements: true,
    fillEmptyParagraph: true,
    replaceNBSP: true,
    cleanOnPaste: true,
    replaceOldTags: {
        i: 'em',
        b: 'strong'
    },
    allowTags: false,
    denyTags: false
};
Config_Config.prototype.controls.eraser = {
    command: 'removeFormat',
    tooltip: 'Clear Formatting'
};
function cleanHtml(editor) {
    if (editor.options.cleanHTML.cleanOnPaste) {
        editor.events
            .off('processPaste.cleanHtml')
            .on('processPaste.cleanHtml', (event, html) => {
            return cleanFromWord(html);
        });
    }
    const attributesReg = /([^\[]*)\[([^\]]+)]/, seperator = /[\s]*,[\s]*/, attrReg = /^(.*)[\s]*=[\s]*(.*)$/;
    const getHash = (tags) => {
        const tagsHash = {};
        if (typeof tags === 'string') {
            tags.split(seperator).map((elm) => {
                elm = trim(elm);
                const attr = attributesReg.exec(elm), allowAttributes = {}, attributeMap = (attrName) => {
                    attrName = trim(attrName);
                    const val = attrReg.exec(attrName);
                    if (val) {
                        allowAttributes[val[1]] = val[2];
                    }
                    else {
                        allowAttributes[attrName] = true;
                    }
                };
                if (attr) {
                    const attr2 = attr[2].split(seperator);
                    if (attr[1]) {
                        attr2.forEach(attributeMap);
                        tagsHash[attr[1].toUpperCase()] = allowAttributes;
                    }
                }
                else {
                    tagsHash[elm.toUpperCase()] = true;
                }
            });
            return tagsHash;
        }
        if (tags) {
            Object.keys(tags).forEach((tagName) => {
                tagsHash[tagName.toUpperCase()] = tags[tagName];
            });
            return tagsHash;
        }
        return false;
    };
    let current;
    const allowTagsHash = getHash(editor.options.cleanHTML.allowTags), denyTagsHash = getHash(editor.options.cleanHTML.denyTags);
    const hasNotEmptyTextSibling = (node, next = false) => {
        let prev = next ? node.nextSibling : node.previousSibling;
        while (prev) {
            if (prev.nodeType === Node.ELEMENT_NODE ||
                !Dom_Dom.isEmptyTextNode(prev)) {
                return true;
            }
            prev = next ? prev.nextSibling : prev.previousSibling;
        }
        return false;
    };
    const isRemovableNode = (node) => {
        if (node.nodeType !== Node.TEXT_NODE &&
            ((allowTagsHash && !allowTagsHash[node.nodeName]) ||
                (denyTagsHash && denyTagsHash[node.nodeName]))) {
            return true;
        }
        if (current &&
            node.nodeName === 'BR' &&
            hasNotEmptyTextSibling(node) &&
            !hasNotEmptyTextSibling(node, true) &&
            Dom_Dom.up(node, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor) !==
                Dom_Dom.up(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor)) {
            return true;
        }
        return (editor.options.cleanHTML.removeEmptyElements &&
            current !== false &&
            node.nodeType === Node.ELEMENT_NODE &&
            node.nodeName.match(IS_INLINE) !== null &&
            !editor.selection.isMarker(node) &&
            trim(node.innerHTML).length === 0 &&
            !Dom_Dom.isOrContains(node, current));
    };
    editor.events
        .on('change afterSetMode afterInit mousedown keydown', debounce(() => {
        if (!editor.isDestructed &&
            editor.isEditorMode() &&
            editor.selection) {
            current = editor.selection.current();
            let node = null, work = false, i = 0;
            const remove = [], replaceOldTags = editor.options.cleanHTML.replaceOldTags;
            if (replaceOldTags && current) {
                const tags = Object.keys(replaceOldTags).join('|');
                if (editor.selection.isCollapsed()) {
                    const oldParent = Dom_Dom.closest(current, tags, editor.editor);
                    if (oldParent) {
                        const selInfo = editor.selection.save(), tagName = replaceOldTags[oldParent.nodeName.toLowerCase()] || replaceOldTags[oldParent.nodeName];
                        Dom_Dom.replace(oldParent, tagName, true, false, editor.create.inside);
                        editor.selection.restore(selInfo);
                    }
                }
            }
            const checkNode = (nodeElm) => {
                if (nodeElm) {
                    if (isRemovableNode(nodeElm)) {
                        remove.push(nodeElm);
                        return checkNode(nodeElm.nextSibling);
                    }
                    if (editor.options.cleanHTML.fillEmptyParagraph &&
                        Dom_Dom.isBlock(nodeElm, editor.editorWindow) &&
                        Dom_Dom.isEmpty(nodeElm, /^(img|svg|canvas|input|textarea|form|br)$/)) {
                        const br = editor.create.inside.element('br');
                        nodeElm.appendChild(br);
                    }
                    if (allowTagsHash &&
                        allowTagsHash[nodeElm.nodeName] !== true) {
                        const attributes = nodeElm
                            .attributes;
                        if (attributes && attributes.length) {
                            const removeAttrs = [];
                            for (i = 0; i < attributes.length; i += 1) {
                                if (!allowTagsHash[nodeElm.nodeName][attributes[i].name] ||
                                    (allowTagsHash[nodeElm.nodeName][attributes[i].name] !== true &&
                                        allowTagsHash[nodeElm.nodeName][attributes[i].name] !== attributes[i].value)) {
                                    removeAttrs.push(attributes[i].name);
                                }
                            }
                            if (removeAttrs.length) {
                                work = true;
                            }
                            removeAttrs.forEach((attr) => {
                                nodeElm.removeAttribute(attr);
                            });
                        }
                    }
                    checkNode(nodeElm.firstChild);
                    checkNode(nodeElm.nextSibling);
                }
            };
            if (editor.editor.firstChild) {
                node = editor.editor.firstChild;
            }
            checkNode(node);
            remove.forEach(Dom_Dom.safeRemove);
            if (remove.length || work) {
                editor.events && editor.events.fire('syncho');
            }
        }
    }, editor.options.cleanHTML.timeout))
        .on('keyup', () => {
        if (editor.options.readonly) {
            return;
        }
        const currentNode = editor.selection.current();
        if (currentNode) {
            const currentParagraph = Dom_Dom.up(currentNode, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
            if (currentParagraph) {
                Dom_Dom.all(currentParagraph, node => {
                    if (node && node.nodeType === Node.TEXT_NODE) {
                        if (node.nodeValue !== null &&
                            INVISIBLE_SPACE_REG_EXP.test(node.nodeValue) &&
                            node.nodeValue.replace(INVISIBLE_SPACE_REG_EXP, '').length !== 0) {
                            node.nodeValue = node.nodeValue.replace(INVISIBLE_SPACE_REG_EXP, '');
                            if (node === currentNode &&
                                editor.selection.isCollapsed()) {
                                editor.selection.setCursorAfter(node);
                            }
                        }
                    }
                });
            }
        }
    })
        .on('afterCommand', (command) => {
        const sel = editor.selection;
        let hr, node;
        switch (command.toLowerCase()) {
            case 'inserthorizontalrule':
                hr = editor.editor.querySelector('hr[id=null]');
                if (hr) {
                    node = Dom_Dom.next(hr, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor, false);
                    if (!node) {
                        node = editor.create.inside.element(editor.options.enter);
                        if (node) {
                            Dom_Dom.after(hr, node);
                        }
                    }
                    sel.setCursorIn(node);
                }
                break;
            case 'removeformat':
                node = sel.current();
                const clean = (elm) => {
                    switch (elm.nodeType) {
                        case Node.ELEMENT_NODE:
                            Dom_Dom.each(elm, clean);
                            if (elm.nodeName === 'FONT') {
                                Dom_Dom.unwrap(elm);
                            }
                            else {
                                [].slice
                                    .call(elm.attributes)
                                    .forEach((attr) => {
                                    if ([
                                        'src',
                                        'href',
                                        'rel',
                                        'content'
                                    ].indexOf(attr.name.toLowerCase()) === -1) {
                                        elm.removeAttribute(attr.name);
                                    }
                                });
                                normalizeNode(elm);
                            }
                            break;
                        case Node.TEXT_NODE:
                            if (editor.options.cleanHTML.replaceNBSP &&
                                elm.nodeType === Node.TEXT_NODE &&
                                elm.nodeValue !== null &&
                                elm.nodeValue.match(SPACE_REG_EXP)) {
                                elm.nodeValue = elm.nodeValue.replace(SPACE_REG_EXP, ' ');
                            }
                            break;
                        default:
                            Dom_Dom.safeRemove(elm);
                    }
                };
                if (!sel.isCollapsed()) {
                    editor.selection.eachSelection((currentNode) => {
                        clean(currentNode);
                    });
                }
                else {
                    while (node &&
                        node.nodeType !== Node.ELEMENT_NODE &&
                        node !== editor.editor) {
                        clean(node);
                        if (node) {
                            node = node.parentNode;
                        }
                    }
                }
                break;
        }
    });
}

// CONCATENATED MODULE: ./src/modules/helpers/html/nl2br.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
const nl2br = (html) => {
    return html.replace(/([^>])([\n\r]+)/g, '$1<br/>$2');
};

// CONCATENATED MODULE: ./src/plugins/clipboard/paste.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */







Config_Config.prototype.askBeforePasteHTML = true;
Config_Config.prototype.processPasteHTML = true;
Config_Config.prototype.askBeforePasteFromWord = true;
Config_Config.prototype.processPasteFromWord = true;
Config_Config.prototype.nl2brInPlainText = true;
Config_Config.prototype.defaultActionOnPaste = INSERT_AS_HTML;
const getDataTransfer = (event) => {
    if (event.clipboardData) {
        return event.clipboardData;
    }
    try {
        return event.dataTransfer || new DataTransfer();
    }
    catch (_a) {
        return null;
    }
};
Config_Config.prototype.controls.paste = {
    tooltip: 'Paste from clipboard',
    async exec(editor) {
        editor.selection.focus();
        let text = '', error = true;
        if (error) {
            text = editor.buffer.get(pluginKey) || '';
            error = text.length === 0;
        }
        if (error && navigator.clipboard) {
            try {
                const items = await navigator.clipboard.read();
                if (items && items.length) {
                    const textBlob = await items[0].getType('text/plain');
                    text = await new Response(textBlob).text();
                }
            }
            catch (_a) { }
            if (error) {
                try {
                    text = await navigator.clipboard.readText();
                    error = false;
                }
                catch (_b) { }
            }
        }
        if (error) {
            const value = editor.value;
            editor.editorDocument.execCommand('paste');
            error = value !== editor.value;
        }
        if (text) {
            editor.selection.insertHTML(text);
        }
        else {
            if (error) {
                Alert(editor.i18n("Your browser doesn't support direct access to the clipboard."), () => {
                    editor.selection.focus();
                });
            }
        }
    }
};
function paste(editor) {
    const opt = editor.options, clearOrKeep = (msg, title, callback, clearButton = 'Clean', clear2Button = 'Insert only Text') => {
        var _a;
        if (editor.events &&
            editor.events.fire('beforeOpenPasteDialog', msg, title, callback, clearButton, clear2Button) === false) {
            return;
        }
        const dialog = Confirm(`<div style="word-break: normal; white-space: normal">${msg}</div>`, title, callback);
        editor.markOwner(dialog.container);
        const keep = dialog.create.fromHTML(`<a href="javascript:void(0)" class="jodit_button jodit_button_primary"><span>${editor.i18n('Keep')}</span></a>`);
        const clear = dialog.create.fromHTML(`<a href="javascript:void(0)" class="jodit_button"><span>${editor.i18n(clearButton)}</span></a>`);
        const clear2 = dialog.create.fromHTML(`<a href="javascript:void(0)" class="jodit_button"><span>${editor.i18n(clear2Button)}</span></a>`);
        const cancel = dialog.create.fromHTML(`<a href="javascript:void(0)" class="jodit_button"><span>${editor.i18n('Cancel')}</span></a>`);
        editor.events.on(keep, 'click', () => {
            dialog.close();
            callback && callback(true);
        });
        editor.events.on(clear, 'click', () => {
            dialog.close();
            callback && callback(false);
        });
        editor.events.on(clear2, 'click', () => {
            dialog.close();
            callback && callback(0);
        });
        editor.events.on(cancel, 'click', () => {
            dialog.close();
        });
        dialog.setFooter([keep, clear, clear2Button ? clear2 : '', cancel]);
        (_a = editor.events) === null || _a === void 0 ? void 0 : _a.fire('afterOpenPasteDialog', dialog, msg, title, callback, clearButton, clear2Button);
        return dialog;
    };
    const insertByType = (html, subtype) => {
        if (typeof html === 'string') {
            switch (subtype) {
                case INSERT_CLEAR_HTML:
                    html = cleanFromWord(html);
                    break;
                case INSERT_ONLY_TEXT:
                    html = stripTags(html);
                    break;
                case INSERT_AS_TEXT:
                    html = htmlspecialchars(html);
                    break;
                default:
            }
        }
        if (typeof html === 'string') {
            editor.buffer.set(pluginKey, html);
        }
        editor.selection.insertHTML(html);
    };
    const insertHTML = (html, event) => {
        const buffer = editor.buffer.get(pluginKey);
        if (isHTML(html) && buffer !== trimFragment(html)) {
            html = trimFragment(html);
            const pasteHTMLByType = (insertType) => {
                if (event.type === 'drop') {
                    editor.selection.insertCursorAtPoint(event.clientX, event.clientY);
                }
                insertByType(html, insertType);
                editor.setEditorValue();
            };
            if (opt.askBeforePasteHTML) {
                clearOrKeep(editor.i18n('Your code is similar to HTML. Keep as HTML?'), editor.i18n('Paste as HTML'), (agree) => {
                    let insertType = INSERT_AS_HTML;
                    if (agree === false) {
                        insertType = INSERT_AS_TEXT;
                    }
                    if (agree === 0) {
                        insertType = INSERT_ONLY_TEXT;
                    }
                    pasteHTMLByType(insertType);
                }, 'Insert as Text');
            }
            else {
                pasteHTMLByType(opt.defaultActionOnPaste);
            }
            return false;
        }
    };
    const trimFragment = (html) => {
        const start = html.search(/<!--StartFragment-->/i);
        if (start !== -1) {
            html = html.substr(start + 20);
        }
        const end = html.search(/<!--EndFragment-->/i);
        if (end !== -1) {
            html = html.substr(0, end);
        }
        return html;
    };
    const beforePaste = (event) => {
        const dt = getDataTransfer(event);
        if (!dt || !event || !dt.getData) {
            return;
        }
        if (dt.getData(TEXT_HTML)) {
            const processHTMLData = (html) => {
                const buffer = editor.buffer.get(pluginKey);
                if (opt.processPasteHTML &&
                    isHTML(html) &&
                    buffer !== trimFragment(html)) {
                    if (opt.processPasteFromWord && isHTMLFromWord(html)) {
                        const pasteFromWordByType = (method) => {
                            var _a;
                            if (method === INSERT_AS_HTML) {
                                html = applyStyles(html);
                                if (opt.beautifyHTML) {
                                    const value = (_a = editor.events) === null || _a === void 0 ? void 0 : _a.fire('beautifyHTML', html);
                                    if (isString(value)) {
                                        html = value;
                                    }
                                }
                            }
                            if (method === INSERT_AS_TEXT) {
                                html = cleanFromWord(html);
                            }
                            if (method === INSERT_ONLY_TEXT) {
                                html = stripTags(cleanFromWord(html));
                            }
                            editor.selection.insertHTML(html);
                            editor.setEditorValue();
                        };
                        if (opt.askBeforePasteFromWord) {
                            clearOrKeep(editor.i18n('The pasted content is coming from a Microsoft Word/Excel document. ' +
                                'Do you want to keep the format or clean it up?'), editor.i18n('Word Paste Detected'), (agree) => {
                                let insertType = INSERT_AS_HTML;
                                if (agree === false) {
                                    insertType = INSERT_AS_TEXT;
                                }
                                if (agree === 0) {
                                    insertType = INSERT_ONLY_TEXT;
                                }
                                pasteFromWordByType(insertType);
                            });
                        }
                        else {
                            pasteFromWordByType(opt.defaultActionOnPaste);
                        }
                    }
                    else {
                        insertHTML(html, event);
                    }
                    return false;
                }
            };
            if (dt.types && Array.from(dt.types).indexOf('text/html') !== -1) {
                const html = dt.getData(TEXT_HTML);
                return processHTMLData(html);
            }
            if (event.type !== 'drop') {
                const div = editor.create.div('', {
                    tabindex: -1,
                    contenteditable: true,
                    style: {
                        left: -9999,
                        top: 0,
                        width: 0,
                        height: '100%',
                        lineHeight: '140%',
                        overflow: 'hidden',
                        position: 'fixed',
                        zIndex: 2147483647,
                        wordBreak: 'break-all'
                    }
                });
                editor.container.appendChild(div);
                const selData = editor.selection.save();
                div.focus();
                let tick = 0;
                const removeFakeFocus = () => {
                    Dom_Dom.safeRemove(div);
                    editor.selection && editor.selection.restore(selData);
                };
                const waitData = () => {
                    tick += 1;
                    if (div.childNodes && div.childNodes.length > 0) {
                        const pastedData = div.innerHTML;
                        removeFakeFocus();
                        if (processHTMLData(pastedData) !== false) {
                            editor.selection.insertHTML(pastedData);
                        }
                        return;
                    }
                    if (tick < 5) {
                        editor.async.setTimeout(waitData, 20);
                    }
                    else {
                        removeFakeFocus();
                    }
                };
                waitData();
            }
        }
        if (dt.getData(TEXT_PLAIN)) {
            return insertHTML(dt.getData(TEXT_PLAIN), event);
        }
    };
    editor.events
        .off('paste.paste')
        .on('paste.paste', (event) => {
        if (beforePaste(event) === false ||
            editor.events.fire('beforePaste', event) === false) {
            event.preventDefault();
            return false;
        }
        const dt = getDataTransfer(event);
        if (event && dt) {
            const types = dt.types;
            let types_str = '';
            if (Array.isArray(types) || type_type(types) === 'domstringlist') {
                for (let i = 0; i < types.length; i += 1) {
                    types_str += types[i] + ';';
                }
            }
            else {
                types_str = (types || TEXT_PLAIN).toString() + ';';
            }
            const getText = () => {
                if (/text\/html/i.test(types_str)) {
                    return dt.getData('text/html');
                }
                if (/text\/rtf/i.test(types_str) && browser('safari')) {
                    return dt.getData('text/rtf');
                }
                if (/text\/plain/i.test(types_str) && !browser('mozilla')) {
                    return dt.getData(TEXT_PLAIN);
                }
                if (/text/i.test(types_str) && IS_IE) {
                    return dt.getData(TEXT_PLAIN);
                }
                return '';
            };
            let clipboard_html = getText();
            if (Dom_Dom.isNode(clipboard_html, editor.editorWindow) ||
                trim(clipboard_html) !== '') {
                clipboard_html = trimFragment(clipboard_html);
                const buffer = editor.buffer.get(pluginKey);
                if (buffer !== clipboard_html) {
                    clipboard_html = editor.events.fire('processPaste', event, clipboard_html, types_str);
                }
                if (typeof clipboard_html === 'string' ||
                    Dom_Dom.isNode(clipboard_html, editor.editorWindow)) {
                    if (event.type === 'drop') {
                        editor.selection.insertCursorAtPoint(event.clientX, event.clientY);
                    }
                    insertByType(clipboard_html, opt.defaultActionOnPaste);
                }
                event.preventDefault();
                event.stopPropagation();
            }
        }
        if (editor.events.fire('afterPaste', event) === false) {
            return false;
        }
    });
    if (opt.nl2brInPlainText) {
        editor.events
            .off('processPaste.paste')
            .on('processPaste.paste', (event, text, type) => {
            if (type === TEXT_PLAIN + ';' && !isHTML(text)) {
                return nl2br(text);
            }
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/clipboard/cut.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.controls.cut = {
    command: 'cut',
    isDisable: (editor) => editor.selection.isCollapsed(),
    tooltip: 'Cut selection'
};
Config_Config.prototype.controls.copy = {
    command: 'copy',
    isDisable: (editor) => editor.selection.isCollapsed(),
    tooltip: 'Copy selection'
};
const pluginKey = 'clipboard';
class cut_clipboard {
    init(editor) {
        editor.events
            .off(`copy.${pluginKey} cut.${pluginKey}`)
            .on(`copy.${pluginKey} cut.${pluginKey}`, (event) => {
            var _a, _b;
            const selectedText = editor.selection.getHTML();
            const clipboardData = getDataTransfer(event) ||
                getDataTransfer(editor.editorWindow) ||
                getDataTransfer(event.originalEvent);
            if (clipboardData) {
                clipboardData.setData(TEXT_PLAIN, stripTags(selectedText));
                clipboardData.setData(TEXT_HTML, selectedText);
            }
            editor.buffer.set(pluginKey, selectedText);
            if (event.type === 'cut') {
                editor.selection.remove();
                editor.selection.focus();
            }
            event.preventDefault();
            (_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.fire('afterCopy', selectedText);
        });
    }
    destruct(editor) {
        var _a, _b, _c, _d;
        (_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.buffer) === null || _b === void 0 ? void 0 : _b.set(pluginKey, '');
        (_d = (_c = editor) === null || _c === void 0 ? void 0 : _c.events) === null || _d === void 0 ? void 0 : _d.off('.' + pluginKey);
    }
}

// CONCATENATED MODULE: ./src/modules/Plugin.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

class Plugin_Plugin extends Component_Component {
    constructor(jodit) {
        super(jodit);
        this.destruct = this.destruct.bind(this, jodit);
        jodit.events
            .on('afterInit', this.afterInit.bind(this, jodit))
            .on('beforeDestruct', this.destruct);
    }
    init(jodit) { }
    destruct() {
        var _a, _b;
        if (!this.isDestructed) {
            this.setStatus(STATUSES.beforeDestruct);
            (_b = (_a = this.jodit) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.off('beforeDestruct', this.destruct);
            this.beforeDestruct(this.jodit);
            super.destruct();
        }
    }
}

// CONCATENATED MODULE: ./src/plugins/clipboard/paste-storage.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class paste_storage_pasteStorage extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.currentIndex = 0;
        this.list = [];
        this.container = null;
        this.listBox = null;
        this.previewBox = null;
        this.dialog = null;
        this.paste = () => {
            this.jodit.selection.focus();
            this.jodit.selection.insertHTML(this.list[this.currentIndex]);
            if (this.currentIndex !== 0) {
                const buffer = this.list[0];
                this.list[0] = this.list[this.currentIndex];
                this.list[this.currentIndex] = buffer;
            }
            this.dialog && this.dialog.close();
            this.jodit.setEditorValue();
        };
        this.onKeyDown = (e) => {
            let index = this.currentIndex;
            if ([KEY_UP, KEY_DOWN, KEY_ENTER].indexOf(e.which) === -1) {
                return;
            }
            if (e.which === KEY_UP) {
                if (index === 0) {
                    index = this.list.length - 1;
                }
                else {
                    index -= 1;
                }
            }
            if (e.which === KEY_DOWN) {
                if (index === this.list.length - 1) {
                    index = 0;
                }
                else {
                    index += 1;
                }
            }
            if (e.which === KEY_ENTER) {
                this.paste();
                return;
            }
            if (index !== this.currentIndex) {
                this.selectIndex(index);
            }
            e.stopImmediatePropagation();
            e.preventDefault();
        };
        this.selectIndex = (index) => {
            if (this.listBox) {
                Array.from(this.listBox.childNodes).forEach((a, i) => {
                    a.classList.remove('jodit_active');
                    if (index === i && this.previewBox) {
                        a.classList.add('jodit_active');
                        this.previewBox.innerHTML = this.list[index];
                        a.focus();
                    }
                });
            }
            this.currentIndex = index;
        };
        this.showDialog = () => {
            if (this.list.length < 2) {
                return;
            }
            this.dialog || this.createDialog();
            if (this.listBox) {
                this.listBox.innerHTML = '';
            }
            if (this.previewBox) {
                this.previewBox.innerHTML = '';
            }
            this.list.forEach((html, index) => {
                const a = this.jodit.create.element('a');
                a.textContent = index + 1 + '. ' + html.replace(SPACE_REG_EXP, '');
                a.addEventListener('keydown', this.onKeyDown);
                a.setAttribute('href', 'javascript:void(0)');
                a.setAttribute('data-index', index.toString());
                a.setAttribute('tab-index', '-1');
                this.listBox && this.listBox.appendChild(a);
            });
            this.dialog && this.dialog.open();
            this.jodit.async.setTimeout(() => {
                this.selectIndex(0);
            }, 100);
        };
    }
    createDialog() {
        this.dialog = new dialog_Dialog(this.jodit);
        const pasteButton = this.jodit.create.fromHTML('<a href="javascript:void(0)" style="float:right;" class="jodit_button">' +
            '<span>' +
            this.jodit.i18n('Paste') +
            '</span>' +
            '</a>');
        pasteButton.addEventListener('click', this.paste);
        const cancelButton = this.jodit.create.fromHTML('<a href="javascript:void(0)" style="float:right; margin-right: 10px;" class="jodit_button">' +
            '<span>' +
            this.jodit.i18n('Cancel') +
            '</span>' +
            '</a>');
        cancelButton.addEventListener('click', this.dialog.close);
        this.container = this.jodit.create.div();
        this.container.classList.add('jodit_paste_storage');
        this.listBox = this.jodit.create.div();
        this.previewBox = this.jodit.create.div();
        this.container.appendChild(this.listBox);
        this.container.appendChild(this.previewBox);
        this.dialog.setTitle(this.jodit.i18n('Choose Content to Paste'));
        this.dialog.setContent(this.container);
        this.dialog.setFooter([pasteButton, cancelButton]);
        this.jodit.events.on(this.listBox, 'click dblclick', (e) => {
            const a = e.target;
            if (a && a.nodeName === 'A' && a.hasAttribute('data-index')) {
                this.selectIndex(parseInt(a.getAttribute('data-index') || '0', 10));
            }
            if (e.type === 'dblclick') {
                this.paste();
            }
            return false;
        }, 'a');
    }
    afterInit() {
        this.jodit.events
            .off('afterCopy.paste-storage')
            .on('afterCopy.paste-storage', (html) => {
            if (this.list.indexOf(html) !== -1) {
                this.list.splice(this.list.indexOf(html), 1);
            }
            this.list.unshift(html);
            if (this.list.length > 5) {
                this.list.length = 5;
            }
        });
        this.jodit.registerCommand('showPasteStorage', {
            exec: this.showDialog,
            hotkeys: ['ctrl+shift+v', 'cmd+shift+v']
        });
    }
    beforeDestruct() {
        this.dialog && this.dialog.destruct();
        Dom_Dom.safeRemove(this.previewBox);
        Dom_Dom.safeRemove(this.listBox);
        Dom_Dom.safeRemove(this.container);
        this.container = null;
        this.listBox = null;
        this.previewBox = null;
        this.dialog = null;
        this.list = [];
    }
}

// CONCATENATED MODULE: ./src/plugins/clipboard/copyformat.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



const copyformat_pluginKey = 'copyformat';
const copyStyles = [
    'fontWeight',
    'fontStyle',
    'fontSize',
    'color',
    'margin',
    'padding',
    'borderWidth',
    'borderStyle',
    'borderColor',
    'borderRadius',
    'backgroundColor',
    'textDecorationLine',
    'fontFamily'
];
const getStyle = (editor, key, box, defaultStyles) => {
    let result = css_css(box, key);
    if (result === defaultStyles[key]) {
        if (box.parentNode &&
            box !== editor.editor &&
            box.parentNode !== editor.editor) {
            result = getStyle(editor, key, box.parentNode, defaultStyles);
        }
        else {
            result = undefined;
        }
    }
    return result;
};
const getStyles = (editor, box, defaultStyles) => {
    const result = {};
    if (box) {
        copyStyles.forEach((key) => {
            result[key] = getStyle(editor, key, box, defaultStyles);
            if (key.match(/border(Style|Color)/) && !result.borderWidth) {
                result[key] = undefined;
            }
        });
    }
    return result;
};
Config_Config.prototype.controls.copyformat = {
    exec: (editor, current) => {
        if (current) {
            if (editor.buffer.exists(copyformat_pluginKey)) {
                editor.buffer.set(copyformat_pluginKey, false);
                editor.events.off(editor.editor, 'mouseup.' + copyformat_pluginKey);
            }
            else {
                const defaultStyles = {}, box = Dom_Dom.up(current, (elm) => elm && elm.nodeType !== Node.TEXT_NODE, editor.editor) || editor.editor;
                const ideal = editor.create.inside.span();
                editor.editor.appendChild(ideal);
                copyStyles.forEach((key) => {
                    defaultStyles[key] = css_css(ideal, key);
                });
                if (ideal !== editor.editor) {
                    Dom_Dom.safeRemove(ideal);
                }
                const format = getStyles(editor, box, defaultStyles);
                const onMouseDown = () => {
                    editor.buffer.set(copyformat_pluginKey, false);
                    const currentNode = editor.selection.current();
                    if (currentNode) {
                        if (currentNode.nodeName === 'IMG') {
                            css_css(currentNode, format);
                        }
                        else {
                            editor.selection.applyCSS(format);
                        }
                    }
                    editor.events.off(editor.editor, 'mouseup.' + copyformat_pluginKey);
                };
                editor.events.on(editor.editor, 'mouseup.' + copyformat_pluginKey, onMouseDown);
                editor.buffer.set(copyformat_pluginKey, true);
            }
        }
    },
    isActive: (editor) => !!editor.buffer.get(copyformat_pluginKey),
    tooltip: 'Paint format'
};

// CONCATENATED MODULE: ./src/plugins/clipboard/index.ts





// CONCATENATED MODULE: ./src/plugins/color.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


var color_TabsWidget = Widget_Widget.TabsWidget;
var ColorPickerWidget = Widget_Widget.ColorPickerWidget;


Config_Config.prototype.controls.brush = {
    isActive: (editor, control, button) => {
        if (!button) {
            return true;
        }
        const current = editor.selection.current(), icon = button.container.querySelector('svg');
        if (icon && icon.style.fill) {
            icon.style.removeProperty('fill');
        }
        if (current && !button.isDisable()) {
            const currentBpx = Dom_Dom.closest(current, elm => {
                return (Dom_Dom.isBlock(elm, editor.editorWindow) ||
                    (elm &&
                        Dom_Dom.isNode(elm, editor.editorWindow) &&
                        elm.nodeType === Node.ELEMENT_NODE));
            }, editor.editor) || editor.editor;
            const colorHEX = css_css(currentBpx, 'color').toString(), bgHEX = css_css(currentBpx, 'background-color').toString();
            if (colorHEX !== css_css(editor.editor, 'color').toString()) {
                icon && (icon.style.fill = colorHEX);
                return true;
            }
            if (bgHEX !== css_css(editor.editor, 'background-color').toString()) {
                icon && (icon.style.fill = bgHEX);
                return true;
            }
        }
        return false;
    },
    popup: (editor, current, self, close) => {
        let colorHEX = '', bg_color = '', tabs, currentElement = null;
        if (current &&
            current !== editor.editor &&
            Dom_Dom.isNode(current, editor.editorWindow) &&
            current.nodeType === Node.ELEMENT_NODE) {
            colorHEX = css_css(current, 'color').toString();
            bg_color = css_css(current, 'background-color').toString();
            currentElement = current;
        }
        const backgroundTag = ColorPickerWidget(editor, (value) => {
            if (!currentElement) {
                editor.execCommand('background', false, value);
            }
            else {
                currentElement.style.backgroundColor = value;
            }
            close();
        }, bg_color);
        const colorTab = ColorPickerWidget(editor, (value) => {
            if (!currentElement) {
                editor.execCommand('forecolor', false, value);
            }
            else {
                currentElement.style.color = value;
            }
            close();
        }, colorHEX);
        if (editor.options.colorPickerDefaultTab === 'background') {
            tabs = {
                Background: backgroundTag,
                Text: colorTab
            };
        }
        else {
            tabs = {
                Text: colorTab,
                Background: backgroundTag
            };
        }
        return color_TabsWidget(editor, tabs, currentElement);
    },
    tooltip: 'Fill color or set the text color'
};
function color_color(editor) {
    const callback = (command, second, third) => {
        const colorHEX = normalizeColor(third);
        switch (command) {
            case 'background':
                editor.selection.applyCSS({
                    backgroundColor: !colorHEX ? '' : colorHEX
                });
                break;
            case 'forecolor':
                editor.selection.applyCSS({
                    color: !colorHEX ? '' : colorHEX
                });
                break;
        }
        editor.setEditorValue();
        return false;
    };
    editor
        .registerCommand('forecolor', callback)
        .registerCommand('background', callback);
}

// CONCATENATED MODULE: ./src/plugins/drag-and-drop.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





class drag_and_drop_DragAndDrop extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.isFragmentFromEditor = false;
        this.isCopyMode = false;
        this.startDragPoint = { x: 0, y: 0 };
        this.draggable = null;
        this.bufferRange = null;
        this.onDragEnd = () => {
            if (this.draggable) {
                Dom_Dom.safeRemove(this.draggable);
                this.draggable = null;
            }
            this.isCopyMode = false;
        };
        this.onDrag = (event) => {
            if (this.draggable) {
                if (!this.draggable.parentNode) {
                    this.jodit.ownerDocument.body.appendChild(this.draggable);
                }
                this.jodit.events.fire('hidePopup');
                css_css(this.draggable, {
                    left: event.clientX + 20,
                    top: event.clientY + 20
                });
                this.jodit.selection.insertCursorAtPoint(event.clientX, event.clientY);
                event.preventDefault();
                event.stopPropagation();
            }
        };
        this.onDrop = (event) => {
            if (!event.dataTransfer ||
                !event.dataTransfer.files ||
                !event.dataTransfer.files.length) {
                if (!this.isFragmentFromEditor && !this.draggable) {
                    this.jodit.events.fire('paste', event);
                    event.preventDefault();
                    event.stopPropagation();
                    return false;
                }
                const sel = this.jodit.selection.sel;
                const range = this.bufferRange ||
                    (sel && sel.rangeCount ? sel.getRangeAt(0) : null);
                let fragment = null;
                if (!this.draggable && range) {
                    fragment = this.isCopyMode
                        ? range.cloneContents()
                        : range.extractContents();
                }
                else if (this.draggable) {
                    if (this.isCopyMode) {
                        const [tagName, attr] = this.draggable.getAttribute('data-is-file') === '1'
                            ? ['a', 'href']
                            : ['img', 'src'];
                        fragment = this.jodit.create.inside.element(tagName);
                        fragment.setAttribute(attr, this.draggable.getAttribute('data-src') ||
                            this.draggable.getAttribute('src') ||
                            '');
                        if (tagName === 'a') {
                            fragment.textContent =
                                fragment.getAttribute(attr) || '';
                        }
                    }
                    else {
                        fragment = dataBind(this.draggable, 'target');
                    }
                }
                else if (this.getText(event)) {
                    fragment = this.jodit.create.inside.fromHTML(this.getText(event));
                }
                sel && sel.removeAllRanges();
                this.jodit.selection.insertCursorAtPoint(event.clientX, event.clientY);
                if (fragment) {
                    this.jodit.selection.insertNode(fragment, false, false);
                    if (range && fragment.firstChild && fragment.lastChild) {
                        range.setStartBefore(fragment.firstChild);
                        range.setEndAfter(fragment.lastChild);
                        this.jodit.selection.selectRange(range);
                        this.jodit.events.fire('synchro');
                    }
                    if (fragment.nodeName === 'IMG' && this.jodit.events) {
                        this.jodit.events.fire('afterInsertImage', fragment);
                    }
                }
                event.preventDefault();
                event.stopPropagation();
            }
            this.isFragmentFromEditor = false;
        };
        this.onDragStart = (event) => {
            let target = event.target;
            this.onDragEnd();
            this.isFragmentFromEditor = Dom_Dom.isOrContains(this.jodit.editor, target, true);
            this.isCopyMode = this.isFragmentFromEditor ? ctrlKey(event) : true;
            if (this.isFragmentFromEditor) {
                const sel = this.jodit.selection.sel;
                const range = sel && sel.rangeCount ? sel.getRangeAt(0) : null;
                if (range) {
                    this.bufferRange = range.cloneRange();
                }
            }
            else {
                this.bufferRange = null;
            }
            this.startDragPoint.x = event.clientX;
            this.startDragPoint.y = event.clientY;
            if (target.nodeType === Node.ELEMENT_NODE &&
                target.matches('.jodit_filebrowser_files_item')) {
                target = target.querySelector('img');
            }
            if (target.nodeName === 'IMG') {
                this.draggable = target.cloneNode(true);
                dataBind(this.draggable, 'target', target);
                css_css(this.draggable, {
                    'z-index': 100000000000000,
                    'pointer-events': 'none',
                    position: 'fixed',
                    display: 'inlin-block',
                    left: this.startDragPoint.x,
                    top: this.startDragPoint.y,
                    width: target.offsetWidth,
                    height: target.offsetHeight
                });
            }
        };
        this.getText = (event) => {
            const dt = getDataTransfer(event);
            return dt ? dt.getData(TEXT_HTML) || dt.getData(TEXT_PLAIN) : null;
        };
    }
    afterInit() {
        this.jodit.events
            .off(window, '.DragAndDrop')
            .off('.DragAndDrop')
            .off([window, this.jodit.editorDocument, this.jodit.editor], 'dragstart.DragAndDrop', this.onDragStart)
            .on(window, 'dragover.DragAndDrop', this.onDrag)
            .on([window, this.jodit.editorDocument, this.jodit.editor], 'dragstart.DragAndDrop', this.onDragStart)
            .on('drop.DragAndDrop', this.onDrop)
            .on(window, 'dragend.DragAndDrop drop.DragAndDrop mouseup.DragAndDrop', this.onDragEnd);
    }
    beforeDestruct() {
        this.onDragEnd();
    }
}

// CONCATENATED MODULE: ./src/plugins/drag-and-drop-element.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.draggableTags = ['img', 'a', 'jodit-media', 'jodit'];
class drag_and_drop_element_DragAndDropElement extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.dragList = [];
        this.isCopyMode = false;
        this.draggable = null;
        this.wasMoved = false;
        this.timeout = 0;
        this.onDrag = throttle((event) => {
            if (!this.draggable) {
                return;
            }
            this.wasMoved = true;
            this.jodit.events.fire('hidePopup hideResizer');
            if (!this.draggable.parentNode) {
                this.jodit.ownerDocument.body.appendChild(this.draggable);
            }
            css_css(this.draggable, {
                left: event.clientX + 20,
                top: event.clientY + 20
            });
            this.jodit.selection.insertCursorAtPoint(event.clientX, event.clientY);
        }, this.jodit.defaultTimeout);
        this.onDragStart = (event) => {
            let target = event.target, last = null;
            if (!this.dragList.length) {
                return;
            }
            do {
                if (this.dragList.indexOf(target.nodeName.toLowerCase()) !== -1) {
                    if (!last ||
                        (target.firstChild === last && target.lastChild === last)) {
                        last = target;
                    }
                }
                target = target.parentNode;
            } while (target && target !== this.jodit.editor);
            if (!last) {
                return;
            }
            this.isCopyMode = ctrlKey(event);
            this.onDragEnd();
            this.timeout = this.jodit.async.setTimeout((lastNode) => {
                if (!lastNode) {
                    return;
                }
                this.draggable = lastNode.cloneNode(true);
                dataBind(this.draggable, 'target', lastNode);
                css_css(this.draggable, {
                    'z-index': 100000000000000,
                    'pointer-events': 'none',
                    position: 'fixed',
                    display: 'inlin-block',
                    left: event.clientX,
                    top: event.clientY,
                    width: lastNode.offsetWidth,
                    height: lastNode.offsetHeight
                });
            }, this.jodit.defaultTimeout, last);
            event.preventDefault();
        };
        this.onDragEnd = () => {
            if (this.isInDestruct) {
                return;
            }
            this.jodit.async.clearTimeout(this.timeout);
            if (this.draggable) {
                Dom_Dom.safeRemove(this.draggable);
                this.draggable = null;
                this.wasMoved = false;
            }
        };
        this.onDrop = () => {
            if (!this.draggable || !this.wasMoved) {
                this.onDragEnd();
                return;
            }
            let fragment = dataBind(this.draggable, 'target');
            this.onDragEnd();
            if (this.isCopyMode) {
                fragment = fragment.cloneNode(true);
            }
            this.jodit.selection.insertNode(fragment, true, false);
            if (fragment.nodeName === 'IMG' && this.jodit.events) {
                this.jodit.events.fire('afterInsertImage', fragment);
            }
            this.jodit.events.fire('synchro');
        };
    }
    afterInit() {
        this.dragList = this.jodit.options.draggableTags
            ? splitArray(this.jodit.options.draggableTags)
                .filter(item => item)
                .map((item) => item.toLowerCase())
            : [];
        if (!this.dragList.length) {
            return;
        }
        this.jodit.events
            .on(this.jodit.editor, 'mousemove touchmove', this.onDrag)
            .on(this.jodit.editor, 'mousedown touchstart dragstart', this.onDragStart)
            .on('mouseup touchend', this.onDrop)
            .on(window, 'mouseup touchend', this.onDragEnd);
    }
    beforeDestruct() {
        this.onDragEnd();
    }
}

// CONCATENATED MODULE: ./src/plugins/enter.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



const insertParagraph = (editor, fake, wrapperTag, style) => {
    const p = editor.create.inside.element(wrapperTag), helper_node = editor.create.inside.element('br');
    p.appendChild(helper_node);
    if (style && style.cssText) {
        p.setAttribute('style', style.cssText);
    }
    editor.selection.insertNode(p, false, false);
    editor.selection.setCursorBefore(helper_node);
    const range = editor.editorDocument.createRange();
    range.setStartBefore(wrapperTag.toLowerCase() !== 'br' ? helper_node : p);
    range.collapse(true);
    editor.selection.selectRange(range);
    Dom_Dom.safeRemove(fake);
    scrollIntoView(p, editor.editor, editor.editorDocument);
    editor.events && editor.events.fire('synchro');
    return p;
};
function enter_enter(editor) {
    if (!editor.options.enterBlock) {
        editor.options.enterBlock =
            editor.options.enter.toLowerCase() === 'br'
                ? PARAGRAPH
                : editor.options.enter.toLowerCase();
    }
    editor.events
        .off('keydown.enter')
        .on('keydown.enter', (event) => {
        if (event.which === KEY_ENTER) {
            const beforeEnter = editor.events.fire('beforeEnter', event);
            if (beforeEnter !== undefined) {
                return beforeEnter;
            }
            if (!editor.selection.isCollapsed()) {
                editor.execCommand('Delete');
            }
            editor.selection.focus();
            let current = editor.selection.current(false);
            const sel = editor.selection.sel;
            let range = editor.selection.range;
            if (!current || current === editor.editor) {
                editor.selection.current();
                current = editor.create.inside.text(INVISIBLE_SPACE);
                if (sel && sel.rangeCount) {
                    range.insertNode(current);
                }
                else {
                    editor.editor.appendChild(current);
                }
                range.selectNode(current);
                range.collapse(false);
                if (sel) {
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
            let currentBox = current
                ? Dom_Dom.up(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor)
                : false;
            const isLi = currentBox && currentBox.nodeName === 'LI';
            if (!isLi &&
                (editor.options.enter.toLowerCase() ===
                    BR.toLowerCase() ||
                    event.shiftKey ||
                    Dom_Dom.closest(current, 'PRE|BLOCKQUOTE', editor.editor))) {
                const br = editor.create.inside.element('br');
                editor.selection.insertNode(br, true);
                scrollIntoView(br, editor.editor, editor.editorDocument);
                return false;
            }
            if (!currentBox &&
                current &&
                !Dom_Dom.prev(current, (elm) => Dom_Dom.isBlock(elm, editor.editorWindow) ||
                    (!!elm && Dom_Dom.isImage(elm, editor.editorWindow)), editor.editor)) {
                let needWrap = current;
                Dom_Dom.up(needWrap, node => {
                    if (node &&
                        node.hasChildNodes() &&
                        node !== editor.editor) {
                        needWrap = node;
                    }
                }, editor.editor);
                currentBox = Dom_Dom.wrapInline(needWrap, editor.options.enter, editor);
                if (Dom_Dom.isEmpty(currentBox)) {
                    const helper_node = editor.create.inside.element('br');
                    currentBox.appendChild(helper_node);
                    editor.selection.setCursorBefore(helper_node);
                }
                range =
                    sel && sel.rangeCount
                        ? sel.getRangeAt(0)
                        : editor.editorDocument.createRange();
            }
            let fake = false, insertNew = false;
            if (currentBox) {
                if (!Dom_Dom.canSplitBlock(currentBox, editor.editorWindow)) {
                    const br = editor.create.inside.element('br');
                    editor.selection.insertNode(br, false);
                    editor.selection.setCursorAfter(br);
                    return false;
                }
                if (isLi) {
                    if (Dom_Dom.isEmpty(currentBox)) {
                        let fakeTextNode = false;
                        const ul = Dom_Dom.closest(currentBox, 'ol|ul', editor.editor);
                        if (!Dom_Dom.prev(currentBox, (elm) => elm && elm.nodeName === 'LI', ul)) {
                            fakeTextNode = editor.selection.setCursorBefore(ul);
                        }
                        else if (!Dom_Dom.next(currentBox, (elm) => elm && elm.nodeName === 'LI', ul)) {
                            fakeTextNode = editor.selection.setCursorAfter(ul);
                        }
                        else {
                            const leftRange = editor.editorDocument.createRange();
                            leftRange.setStartBefore(ul);
                            leftRange.setEndAfter(currentBox);
                            const fragment = leftRange.extractContents();
                            if (ul.parentNode) {
                                ul.parentNode.insertBefore(fragment, ul);
                            }
                            fakeTextNode = editor.selection.setCursorBefore(ul);
                        }
                        Dom_Dom.safeRemove(currentBox);
                        insertParagraph(editor, fakeTextNode, editor.options.enter);
                        if (!$$('li', ul).length) {
                            Dom_Dom.safeRemove(ul);
                        }
                        return false;
                    }
                }
                if (editor.selection.cursorInTheEdge(true, currentBox)) {
                    fake = editor.selection.setCursorBefore(currentBox);
                    insertParagraph(editor, fake, isLi ? 'li' : editor.options.enter, currentBox.style);
                    currentBox &&
                        editor.selection.setCursorIn(currentBox, true);
                    return false;
                }
                if (editor.selection.cursorInTheEdge(false, currentBox) ===
                    false) {
                    const leftRange = editor.editorDocument.createRange();
                    leftRange.setStartBefore(currentBox);
                    leftRange.setEnd(range.startContainer, range.startOffset);
                    const fragment = leftRange.extractContents();
                    if (currentBox.parentNode) {
                        currentBox.parentNode.insertBefore(fragment, currentBox);
                    }
                    editor.selection.setCursorIn(currentBox, true);
                }
                else {
                    fake = editor.selection.setCursorAfter(currentBox);
                }
            }
            else {
                insertNew = true;
            }
            if (insertNew || fake) {
                insertParagraph(editor, fake, isLi ? 'li' : editor.options.enter, currentBox ? currentBox.style : undefined);
            }
            return false;
        }
    });
}

// CONCATENATED MODULE: ./src/plugins/error-messages.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.showMessageErrors = true;
Config_Config.prototype.showMessageErrorTime = 3000;
Config_Config.prototype.showMessageErrorOffsetPx = 3;
function errorMessages(editor) {
    if (editor.options.showMessageErrors) {
        let height;
        const messagesBox = editor.create.div('jodit_error_box_for_messages'), recalcOffsets = () => {
            height = 5;
            Array.from((messagesBox.childNodes)).forEach((elm) => {
                css_css(messagesBox, 'bottom', height + 'px');
                height +=
                    elm.offsetWidth +
                        editor.options.showMessageErrorOffsetPx;
            });
        };
        editor.events
            .on('beforeDestruct', () => {
            Dom_Dom.safeRemove(messagesBox);
        })
            .on('errorMessage', (message, className, timeout) => {
            editor.workplace.appendChild(messagesBox);
            const newmessage = editor.create.div('active ' + (className || ''), message);
            messagesBox.appendChild(newmessage);
            recalcOffsets();
            editor.async.setTimeout(() => {
                newmessage.classList.remove('active');
                editor.async.setTimeout(() => {
                    Dom_Dom.safeRemove(newmessage);
                    recalcOffsets();
                }, 300);
            }, timeout || editor.options.showMessageErrorTime);
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/font.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.controls.fontsize = {
    command: 'fontSize',
    list: [
        '8',
        '9',
        '10',
        '11',
        '12',
        '14',
        '16',
        '18',
        '24',
        '30',
        '36',
        '48',
        '60',
        '72',
        '96'
    ],
    template: (editor, key, value) => value,
    tooltip: 'Font size',
    isActiveChild: (editor, control) => {
        const current = editor.selection.current();
        if (current) {
            const currentBpx = Dom_Dom.closest(current, elm => {
                return (Dom_Dom.isBlock(elm, editor.editorWindow) ||
                    (elm &&
                        Dom_Dom.isNode(elm, editor.editorWindow) &&
                        elm.nodeType === Node.ELEMENT_NODE));
            }, editor.editor) || editor.editor;
            const fontSize = css_css(currentBpx, 'font-size');
            return Boolean(fontSize &&
                control.args &&
                control.args[1].toString() === fontSize.toString());
        }
        return false;
    },
    isActive: (editor) => {
        const current = editor.selection.current();
        if (current) {
            const currentBpx = Dom_Dom.closest(current, elm => {
                return (Dom_Dom.isBlock(elm, editor.editorWindow) ||
                    (elm &&
                        Dom_Dom.isNode(elm, editor.editorWindow) &&
                        elm.nodeType === Node.ELEMENT_NODE));
            }, editor.editor) || editor.editor;
            return (css_css(currentBpx, 'font-size').toString() !==
                css_css(editor.editor, 'font-size').toString());
        }
        return false;
    }
};
Config_Config.prototype.controls.font = {
    command: 'fontname',
    exec: (editor, event, control) => {
        editor.execCommand(control.command, false, control.args ? control.args[0] : undefined);
    },
    list: {
        'Helvetica,sans-serif': 'Helvetica',
        'Arial,Helvetica,sans-serif': 'Arial',
        'Georgia,serif': 'Georgia',
        'Impact,Charcoal,sans-serif': 'Impact',
        'Tahoma,Geneva,sans-serif': 'Tahoma',
        "'Times New Roman',Times,serif": 'Times New Roman',
        'Verdana,Geneva,sans-serif': 'Verdana'
    },
    template: (editor, key, value) => {
        return `<span style="font-family: ${key}">${value}</span>`;
    },
    isActiveChild: (editor, control) => {
        const current = editor.selection.current(), normFonts = (fontValue) => {
            return fontValue
                .toLowerCase()
                .replace(/['"]+/g, '')
                .replace(/[^a-z0-9]+/g, ',');
        };
        if (current) {
            const currentBpx = Dom_Dom.closest(current, elm => {
                return (Dom_Dom.isBlock(elm, editor.editorWindow) ||
                    (elm &&
                        Dom_Dom.isNode(elm, editor.editorWindow) &&
                        elm.nodeType === Node.ELEMENT_NODE));
            }, editor.editor) || editor.editor;
            const fontFamily = css_css(currentBpx, 'font-family').toString();
            return Boolean(fontFamily &&
                control.args &&
                normFonts(control.args[0].toString()) ===
                    normFonts(fontFamily));
        }
        return false;
    },
    isActive: (editor) => {
        const current = editor.selection.current();
        if (current) {
            const currentBpx = Dom_Dom.closest(current, (elm) => {
                return (Dom_Dom.isBlock(elm, editor.editorWindow) ||
                    (Dom_Dom.isNode(elm, editor.editorWindow) &&
                        elm &&
                        elm.nodeType === Node.ELEMENT_NODE));
            }, editor.editor) || editor.editor;
            return (css_css(currentBpx, 'font-family').toString() !==
                css_css(editor.editor, 'font-family').toString());
        }
        return false;
    },
    tooltip: 'Font family'
};
function font_font(editor) {
    const callback = (command, second, third) => {
        switch (command) {
            case 'fontsize':
                editor.selection.applyCSS({
                    fontSize: normalizeSize(third)
                });
                break;
            case 'fontname':
                editor.selection.applyCSS({
                    fontFamily: third
                });
                break;
        }
        editor.events.fire('synchro');
        return false;
    };
    editor
        .registerCommand('fontsize', callback)
        .registerCommand('fontname', callback);
}

// CONCATENATED MODULE: ./src/plugins/format-block.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.controls.paragraph = {
    command: 'formatBlock',
    getLabel: (editor, btn, button) => {
        const current = editor.selection.current();
        if (current && editor.options.textIcons) {
            const currentBox = Dom_Dom.closest(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor) || editor.editor, currentValue = currentBox.nodeName.toLowerCase(), list = btn.list;
            if (button &&
                btn.data &&
                btn.data.currentValue !== currentValue &&
                btn.list &&
                list[currentValue]) {
                button.textBox.innerHTML = `<span>${editor.i18n(list[currentValue])}</span>`;
                button.textBox.firstChild.classList.add('jodit_icon');
                btn.data.currentValue = currentValue;
            }
        }
        return false;
    },
    exec: (editor, event, control) => {
        editor.execCommand(control.command, false, control.args ? control.args[0] : undefined);
    },
    data: {
        currentValue: 'left'
    },
    list: {
        p: 'Normal',
        h1: 'Heading 1',
        h2: 'Heading 2',
        h3: 'Heading 3',
        h4: 'Heading 4',
        blockquote: 'Quote'
    },
    isActiveChild: (editor, control) => {
        const current = editor.selection.current();
        if (current) {
            const currentBox = Dom_Dom.closest(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
            return (currentBox &&
                currentBox !== editor.editor &&
                control.args !== undefined &&
                currentBox.nodeName.toLowerCase() === control.args[0]);
        }
        return false;
    },
    isActive: (editor, control) => {
        const current = editor.selection.current();
        if (current) {
            const currentBpx = Dom_Dom.closest(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
            return (currentBpx &&
                currentBpx !== editor.editor &&
                control.list !== undefined &&
                currentBpx.nodeName.toLowerCase() !== 'p' &&
                control.list[currentBpx.nodeName.toLowerCase()] !== undefined);
        }
        return false;
    },
    template: (editor, key, value) => {
        return ('<' +
            key +
            ' class="jodit_list_element"><span>' +
            editor.i18n(value) +
            '</span></' +
            key +
            '></li>');
    },
    tooltip: 'Insert format block'
};
function formatBlock(editor) {
    editor.registerCommand('formatblock', (command, second, third) => {
        editor.selection.focus();
        let work = false;
        editor.selection.eachSelection((current) => {
            const selectionInfo = editor.selection.save();
            let currentBox = current
                ? Dom_Dom.up(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor)
                : false;
            if ((!currentBox || currentBox.nodeName === 'LI') && current) {
                currentBox = Dom_Dom.wrapInline(current, editor.options.enter, editor);
            }
            if (!currentBox) {
                editor.selection.restore(selectionInfo);
                return;
            }
            if (!currentBox.tagName.match(/TD|TH|TBODY|TABLE|THEAD/i)) {
                if (third === editor.options.enterBlock.toLowerCase() &&
                    currentBox.parentNode &&
                    currentBox.parentNode.nodeName === 'LI') {
                    Dom_Dom.unwrap(currentBox);
                }
                else {
                    Dom_Dom.replace(currentBox, third, true, false, editor.create.inside);
                }
            }
            else {
                if (!editor.selection.isCollapsed()) {
                    editor.selection.applyCSS({}, third);
                }
                else {
                    Dom_Dom.wrapInline(current, third, editor);
                }
            }
            work = true;
            editor.selection.restore(selectionInfo);
        });
        if (!work) {
            const currentBox = editor.create.inside.element(third);
            currentBox.innerHTML = INVISIBLE_SPACE;
            editor.selection.insertNode(currentBox, false);
            editor.selection.setCursorIn(currentBox);
        }
        editor.setEditorValue();
        return false;
    });
}

// CONCATENATED MODULE: ./src/plugins/fullsize.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.fullsize = false;
Config_Config.prototype.globalFullsize = true;
Config_Config.prototype.controls.fullsize = {
    exec: (editor) => {
        editor.toggleFullSize();
    },
    isActive: (editor) => editor.isFullSize(),
    getLabel: (editor, btn, button) => {
        const mode = editor.isFullSize() ? 'shrink' : 'fullsize';
        if (button) {
            button.textBox.innerHTML = !editor.options.textIcons
                ? ToolbarIcon.getIcon(mode)
                : `<span>${editor.i18n(mode)}</span>`;
            button.textBox.firstChild.classList.add('jodit_icon');
        }
    },
    tooltip: 'Open editor in fullsize',
    mode: MODE_SOURCE + MODE_WYSIWYG
};
function fullsize(editor) {
    let shown = false, oldHeight = 0, oldWidth = 0, wasToggled = false;
    const resize = () => {
        if (editor.events) {
            if (shown) {
                oldHeight = css_css(editor.container, 'height');
                oldWidth = css_css(editor.container, 'width');
                css_css(editor.container, {
                    height: editor.ownerWindow.innerHeight,
                    width: editor.ownerWindow.innerWidth
                });
                wasToggled = true;
            }
            else if (wasToggled) {
                css_css(editor.container, {
                    height: oldHeight || 'auto',
                    width: oldWidth || 'auto'
                });
            }
        }
    }, toggle = (enable) => {
        var _a, _b, _c;
        if (!editor.container) {
            return;
        }
        if (enable === undefined) {
            enable = !editor.container.classList.contains('jodit_fullsize');
        }
        editor.options.fullsize = enable;
        shown = enable;
        editor.container.classList.toggle('jodit_fullsize', enable);
        if (editor.toolbar) {
            if (!enable) {
                (_a = editor.toolbar.getParentContainer()) === null || _a === void 0 ? void 0 : _a.appendChild(editor.toolbar.container);
            }
            else {
                (_b = editor.container.querySelector('.jodit_toolbar_container')) === null || _b === void 0 ? void 0 : _b.appendChild(editor.toolbar.container);
            }
            css_css(editor.toolbar.container, 'width', 'auto');
        }
        if (editor.options.globalFullsize) {
            let node = editor.container.parentNode;
            while (node && node.nodeType !== Node.DOCUMENT_NODE) {
                node.classList.toggle('jodit_fullsize_box', enable);
                node = node.parentNode;
            }
            resize();
        }
        (_c = editor.events) === null || _c === void 0 ? void 0 : _c.fire('afterResize');
    };
    if (editor.options.globalFullsize) {
        editor.events.on(editor.ownerWindow, 'resize', resize);
    }
    editor.events
        .on('afterInit afterOpen', () => {
        var _a, _b;
        editor.toggleFullSize((_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.fullsize);
    })
        .on('toggleFullSize', toggle)
        .on('beforeDestruct beforeClose', () => {
        toggle(false);
    })
        .on('beforeDestruct', () => {
        editor.events &&
            editor.events.off(editor.ownerWindow, 'resize', resize);
    });
}

// CONCATENATED MODULE: ./src/plugins/hotkeys.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.commandToHotkeys = {
    removeFormat: ['ctrl+shift+m', 'cmd+shift+m'],
    insertOrderedList: ['ctrl+shift+7', 'cmd+shift+7'],
    insertUnorderedList: ['ctrl+shift+8, cmd+shift+8'],
    selectall: ['ctrl+a', 'cmd+a']
};
class hotkeys_hotkeys extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.onKeyPress = (event) => {
            const special = this.specialKeys[event.which], character = (event.key || String.fromCharCode(event.which)).toLowerCase();
            const modif = [special || character];
            ['alt', 'ctrl', 'shift', 'meta'].forEach(specialKey => {
                if (event[specialKey + 'Key'] && special !== specialKey) {
                    modif.push(specialKey);
                }
            });
            return normalizeKeyAliases(modif.join('+'));
        };
        this.specialKeys = {
            8: 'backspace',
            9: 'tab',
            10: 'return',
            13: 'return',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            19: 'pause',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'insert',
            46: 'del',
            59: ';',
            61: '=',
            91: 'meta',
            96: '0',
            97: '1',
            98: '2',
            99: '3',
            100: '4',
            101: '5',
            102: '6',
            103: '7',
            104: '8',
            105: '9',
            106: '*',
            107: '+',
            109: '-',
            110: '.',
            111: '/',
            112: 'f1',
            113: 'f2',
            114: 'f3',
            115: 'f4',
            116: 'f5',
            117: 'f6',
            118: 'f7',
            119: 'f8',
            120: 'f9',
            121: 'f10',
            122: 'f11',
            123: 'f12',
            144: 'numlock',
            145: 'scroll',
            173: '-',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: "'"
        };
    }
    afterInit(editor) {
        const commands = Object.keys(editor.options.commandToHotkeys);
        commands.forEach((commandName) => {
            const shortcuts = editor.options.commandToHotkeys[commandName];
            if (shortcuts) {
                editor.registerHotkeyToCommand(shortcuts, commandName);
            }
        });
        let itIsHotkey = false;
        editor.events
            .off('.hotkeys')
            .on('keydown.hotkeys', (event) => {
            const shortcut = this.onKeyPress(event);
            const resultOfFire = this.jodit.events.fire(shortcut + '.hotkey', event.type);
            if (resultOfFire === false) {
                itIsHotkey = true;
                editor.events.stopPropagation('keydown');
                return false;
            }
        }, undefined, undefined, true)
            .on('keyup.hotkeys', () => {
            if (itIsHotkey) {
                itIsHotkey = false;
                editor.events.stopPropagation('keyup');
                return false;
            }
        }, undefined, undefined, true);
    }
    beforeDestruct(jodit) {
        if (jodit.events) {
            jodit.events.off('.hotkeys');
        }
    }
}

// CONCATENATED MODULE: ./src/plugins/iframe.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */








Config_Config.prototype.iframeBaseUrl = '';
Config_Config.prototype.iframeTitle = 'Jodit Editor';
Config_Config.prototype.iframeDoctype = '<!DOCTYPE html>';
Config_Config.prototype.iframeDefaultSrc = 'about:blank';
Config_Config.prototype.iframeStyle =
    'html{' +
        'margin: 0px;' +
        'min-height: 100%;' +
        '}' +
        'body{' +
        'box-sizing: border-box;' +
        'font-size: 13px;' +
        '    line-height: 1.6;' +
        'padding:10px;' +
        'background:transparent;' +
        'color:#000;' +
        'position:' +
        'relative;' +
        'z-index: 2;' +
        'user-select:auto;' +
        'margin:0px;' +
        'overflow:auto;' +
        '}' +
        'table{' +
        'width:100%;' +
        'border: none;' +
        'border-collapse:collapse;' +
        'empty-cells: show;' +
        'max-width: 100%;' +
        '}' +
        'th,td{' +
        'padding: 2px 5px;' +
        'border:1px solid #ccc;' +
        '-webkit-user-select:text;' +
        '-moz-user-select:text;' +
        '-ms-user-select:text;' +
        'user-select:text' +
        '}' +
        'td[data-jodit-selected-cell],' +
        'th[data-jodit-selected-cell]{' +
        'border: 1px double #1e88e5' +
        '}' +
        'p{' +
        'margin-top:0;' +
        '}' +
        '.jodit_editor .jodit_iframe_wrapper{' +
        'display: block;' +
        'clear: both;' +
        'user-select: none;' +
        'position: relative;' +
        '}' +
        '.jodit_editor .jodit_iframe_wrapper:after {' +
        'position:absolute;' +
        'content:"";' +
        'z-index:1;' +
        'top:0;' +
        'left:0;' +
        'right: 0;' +
        'bottom: 0;' +
        'cursor: pointer;' +
        'display: block;' +
        'background: rgba(0, 0, 0, 0);' +
        '} ' +
        '.jodit_disabled{' +
        'user-select: none;' +
        '-o-user-select: none;' +
        '-moz-user-select: none;' +
        '-khtml-user-select: none;' +
        '-webkit-user-select: none;' +
        '-ms-user-select: none' +
        '}';
Config_Config.prototype.iframeCSSLinks = [];
Config_Config.prototype.editHTMLDocumentMode = false;
function iframe_iframe(editor) {
    const opt = editor.options;
    editor.events
        .on('afterSetMode', () => {
        if (editor.isEditorMode()) {
            editor.selection.focus();
        }
    })
        .on('generateDocumentStructure.iframe', (__doc, jodit) => {
        const doc = __doc ||
            jodit.iframe
                .contentWindow.document;
        doc.open();
        doc.write(`${opt.iframeDoctype}` +
            `<html dir="${opt.direction}" class="jodit" lang="${defaultLanguage_defaultLanguage(opt.language)}">
						<head>
							<title>${opt.iframeTitle}</title>
							${opt.iframeBaseUrl
                ? `<base href="${opt.iframeBaseUrl}"/>`
                : ''}
						</head>
						<body class="jodit_wysiwyg" style="outline:none"></body>
					</html>`);
        doc.close();
        if (opt.iframeCSSLinks) {
            opt.iframeCSSLinks.forEach(href => {
                const link = doc.createElement('link');
                link.setAttribute('rel', 'stylesheet');
                link.setAttribute('href', href);
                doc.head && doc.head.appendChild(link);
            });
        }
        if (opt.iframeStyle) {
            const style = doc.createElement('style');
            style.innerHTML = opt.iframeStyle;
            doc.head && doc.head.appendChild(style);
        }
    })
        .on('createEditor', () => {
        if (!opt.iframe) {
            return;
        }
        const iframe = editor.create.element('iframe');
        iframe.style.display = 'block';
        iframe.src = 'about:blank';
        iframe.className = 'jodit_wysiwyg_iframe';
        iframe.setAttribute('allowtransparency', 'true');
        iframe.setAttribute('tabindex', opt.tabIndex.toString());
        iframe.setAttribute('frameborder', '0');
        editor.workplace.appendChild(iframe);
        editor.iframe = iframe;
        const result = editor.events.fire('generateDocumentStructure.iframe', null, editor);
        const init = () => {
            if (!editor.iframe) {
                return;
            }
            const doc = editor.iframe.contentWindow.document;
            editor.editorWindow = editor.iframe.contentWindow;
            const docMode = opt.editHTMLDocumentMode;
            const toggleEditable = () => {
                Dom_Dom.toggleAttribute(doc.body, 'contenteditable', editor.getMode() !== MODE_SOURCE && !editor.getReadOnly());
            };
            const clearMarkers = (html) => {
                const bodyReg = /<body.*<\/body>/im, bodyMarker = '{%%BODY%%}', body = bodyReg.exec(html);
                if (body) {
                    html = html
                        .replace(bodyReg, bodyMarker)
                        .replace(/<span([^>]*?)>(.*?)<\/span>/gim, '')
                        .replace(/&lt;span([^&]*?)&gt;(.*?)&lt;\/span&gt;/gim, '')
                        .replace(bodyMarker, body[0].replace(/(<body[^>]+?)([\s]*["'])?contenteditable["'\s]*=[\s"']*true["']?/im, '$1'));
                }
                return html;
            };
            if (docMode) {
                const tag = editor.element.tagName;
                if (tag !== 'TEXTAREA' && tag !== 'INPUT') {
                    throw type_error('If enable `editHTMLDocumentMode` - source element should be INPUT or TEXTAREA');
                }
                editor.editor = doc.documentElement;
                editor.events
                    .on('beforeGetNativeEditorValue', () => clearMarkers(doc.documentElement.outerHTML))
                    .on('beforeSetNativeEditorValue', (value) => {
                    if (/<(html|body)/i.test(value)) {
                        const old = doc.documentElement.outerHTML;
                        if (old !== value) {
                            doc.open('text/html', 'replace');
                            doc.write(clearMarkers(value));
                            doc.close();
                            editor.editor = doc.documentElement;
                            toggleEditable();
                        }
                    }
                    else {
                        doc.body.innerHTML = value;
                    }
                    return true;
                });
            }
            else {
                editor.editor = doc.body;
            }
            editor.events.on('afterSetMode afterInit afterAddPlace', toggleEditable);
            if (opt.height === 'auto') {
                doc.documentElement &&
                    (doc.documentElement.style.overflowY = 'hidden');
                const resizeIframe = throttle(() => {
                    if (editor.editor &&
                        editor.iframe &&
                        opt.height === 'auto') {
                        css_css(editor.iframe, 'height', editor.editor.offsetHeight);
                    }
                }, editor.defaultTimeout / 2);
                editor.events
                    .on('change afterInit afterSetMode resize', resizeIframe)
                    .on([
                    editor.iframe,
                    editor.editorWindow,
                    doc.documentElement
                ], 'load', resizeIframe)
                    .on(doc, 'readystatechange DOMContentLoaded', resizeIframe);
            }
            (e => {
                e.matches || (e.matches = Element.prototype.matches);
            })(editor.editorWindow.Element.prototype);
            if (doc.documentElement) {
                editor.events
                    .on(doc.documentElement, 'mousedown touchend', () => {
                    if (!editor.selection.isFocused()) {
                        editor.selection.focus();
                        if (editor.editor === doc.body) {
                            editor.selection.setCursorIn(doc.body);
                        }
                    }
                })
                    .on(editor.editorWindow, 'mousedown touchstart keydown keyup touchend click mouseup mousemove scroll', (e) => {
                    var _a;
                    (_a = editor.events) === null || _a === void 0 ? void 0 : _a.fire(editor.ownerWindow, e);
                });
            }
        };
        if (isPromise(result)) {
            return result.then(init);
        }
        init();
        return false;
    });
}

// CONCATENATED MODULE: ./src/plugins/image-processor.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

const JODIT_IMAGE_PROCESSOR_BINDED = '__jodit_imageprocessor_binded';
function imageProcessor(editor) {
    editor.events.on('change afterInit changePlace', debounce(() => {
        if (editor.editor) {
            $$('img', editor.editor).forEach((elm) => {
                if (!elm[JODIT_IMAGE_PROCESSOR_BINDED]) {
                    elm[JODIT_IMAGE_PROCESSOR_BINDED] = true;
                    if (!elm.complete) {
                        elm.addEventListener('load', function ElementOnLoad() {
                            editor.events &&
                                editor.events.fire &&
                                editor.events.fire('resize');
                            elm.removeEventListener('load', ElementOnLoad);
                        });
                    }
                    editor.events.on(elm, 'mousedown touchstart', () => {
                        editor.selection.select(elm);
                    });
                }
            });
        }
    }, editor.defaultTimeout));
}

// CONCATENATED MODULE: ./src/plugins/image-properties.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






var image_properties_TabsWidget = Widget_Widget.TabsWidget;
var image_properties_FileSelectorWidget = Widget_Widget.FileSelectorWidget;

Config_Config.prototype.image = {
    openOnDblClick: true,
    editSrc: true,
    useImageEditor: true,
    editTitle: true,
    editAlt: true,
    editLink: true,
    editSize: true,
    editBorderRadius: true,
    editMargins: true,
    editClass: true,
    editStyle: true,
    editId: true,
    editAlign: true,
    showPreview: true,
    selectImageAfterClose: true
};
function imageProperties(editor) {
    const i18n = editor.i18n, gi = ToolbarIcon.getIcon.bind(ToolbarIcon), opt = editor.options, dom = editor.create.fromHTML.bind(editor.create);
    const open = function (e) {
        if (opt.readonly) {
            return;
        }
        e && e.stopImmediatePropagation();
        const image = this, dialog = new dialog_Dialog(editor), buttons = {
            check: dom(`<a href="javascript:void(0)" class="jodit_button  jodit_status_success">${gi('check')}<span>${i18n('Ok')}</span></a>`),
            cancel: dom(`<a href="javascript:void(0)" class="jodit_button  jodit_status_primary">${gi('cancel')}<span>${i18n('Cancel')}</span></a>`),
            remove: dom(`<a href="javascript:void(0)" class="jodit_button">${gi('bin')}<span>${i18n('Delete')}</span></a>`)
        }, prop = dom(`<form class="jodit_properties">
								<div class="jodit_grid">
									<div class="jodit_col-lg-2-5">
										<div class="jodit_properties_view_box">
											<div style="${!opt.image.showPreview
            ? 'display:none'
            : ''}" class="jodit_properties_image_view">
												<img class="imageViewSrc" src="" alt=""/>
											</div>
											<div style="${!opt.image.editSize
            ? 'display:none'
            : ''}" class="jodit_form_group jodit_properties_image_sizes">
												<input type="number" class="imageWidth jodit_input"/>
												<a class="jodit_lock_helper jodit_lock_size" href="javascript:void(0)">${gi('lock')}</a>
												<input type="number" class="imageHeight jodit_input"/>
											</div>
										</div>
									</div>
									<div class="jodit_col-lg-3-5 tabsbox"></div>
								</div>
							</form>`), positionTab = dom(`<div style="${!opt.image.editMargins ? 'display:none' : ''}" class="jodit_form_group">
								<label>${i18n('Margins')}</label>
								<div class="jodit_grid jodit_vertical_middle">
									<input class="jodit_col-lg-1-5 margins marginTop jodit_input" data-id="marginTop" type="text" placeholder="${i18n('top')}"/>
									<a style="text-align: center;" class="jodit_lock_helper jodit_lock_margin jodit_col-lg-1-5" href="javascript:void(0)">${gi('lock')}</a>
									<input disabled="true" class="jodit_col-lg-1-5 margins marginRight jodit_input" data-id="marginRight" type="text" placeholder="${i18n('right')}"/>
									<input disabled="true" class="jodit_col-lg-1-5 margins marginBottom jodit_input" data-id="marginBottom" type="text" placeholder="${i18n('bottom')}"/>
									<input disabled="true" class="jodit_col-lg-1-5 margins marginLeft jodit_input" data-id="marginLeft" type="text" placeholder="${i18n('left')}"/>
								</div>
							</div>
							<div style="${!opt.image.editStyle ? 'display:none' : ''}" class="jodit_form_group">
								<label>${i18n('Styles')}</label>
								<input type="text" class="style jodit_input"/>
							</div>
							<div style="${!opt.image.editClass ? 'display:none' : ''}" class="jodit_form_group">
								<label for="classes">${i18n('Classes')}</label>
								<input type="text" class="classes jodit_input"/>
							</div>
							<div style="${!opt.image.editId ? 'display:none' : ''}" class="jodit_form_group">
								<label for="id">Id</label>
								<input type="text" class="id jodit_input"/>
							</div>
							<div
								style="${!opt.image.editBorderRadius ? 'display:none' : ''}"
								class="jodit_form_group"
							>
								<label for="border_radius">${i18n('Border radius')}</label>
								<input type="number" class="border_radius jodit_input"/>
							</div>
							<div
								style="${!opt.image.editAlign ? 'display:none' : ''}"
								class="jodit_form_group"
							>
								<label for="align">${i18n('Align')}</label>
								<select class="select align jodit_select">
									<option value="">${i18n('--Not Set--')}</option>
									<option value="left">${i18n('Left')}</option>
									<option value="center">${i18n('Center')}</option>
									<option value="right">${i18n('Right')}</option>
								</select>
							</div>`), hasFbUrl = opt.filebrowser.ajax.url || opt.uploader.url, hasEditor = opt.image.useImageEditor, mainTab = dom(`<div style="${!opt.image.editSrc ? 'display:none' : ''}" class="jodit_form_group">
								<label>${i18n('Src')}</label>
								<div class="jodit_input_group">
									<input class="jodit_input imageSrc" type="text"/>
									<div
										class="jodit_input_group-buttons"
										style="${hasFbUrl ? '' : 'display: none'}"
									>
											<a class="jodit_button jodit_rechange" href="javascript:void(0)">${gi('image')}</a>
											<a
												class="jodit_button jodit_use_image_editor" href="javascript:void(0)"
												style="${hasEditor ? '' : 'display: none'}"
											>${gi('crop')}</a>
									</div>
								</div>
							</div>
							<div style="${!opt.image.editTitle ? 'display:none' : ''}" class="jodit_form_group">
								<label for="imageTitle">${i18n('Title')}</label>
								<input type="text" class="imageTitle jodit_input"/>
							</div>
							<div style="${!opt.image.editAlt ? 'display:none' : ''}" class="jodit_form_group">
								<label for="imageAlt">${i18n('Alternative')}</label>
								<input type="text" class="imageAlt jodit_input"/>
							</div>
							<div style="${!opt.image.editLink ? 'display:none' : ''}" class="jodit_form_group">
								<label for="imageLink">${i18n('Link')}</label>
								<input type="text" class="imageLink jodit_input"/>
							</div>
							<div style="${!opt.image.editLink ? 'display:none' : ''}" class="jodit_form_group">
								<label class="jodit_vertical_middle">
									<input type="checkbox" class="imageLinkOpenInNewTab jodit_checkbox"/>
									<span>${i18n('Open link in new tab')}</span>
								</label>
							</div>`), ratio = image.naturalWidth / image.naturalHeight || 1, $w = prop.querySelector('.imageWidth'), $h = prop.querySelector('.imageHeight'), updateAlign = () => {
            if (image.style.cssFloat &&
                ['left', 'right'].indexOf(image.style.cssFloat.toLowerCase()) !== -1) {
                val_val(prop, '.align', css_css(image, 'float'));
            }
            else {
                if (css_css(image, 'display') === 'block' &&
                    image.style.marginLeft === 'auto' &&
                    image.style.marginRight === 'auto') {
                    val_val(prop, '.align', 'center');
                }
            }
        }, updateBorderRadius = () => {
            val_val(prop, '.border_radius', (parseInt(image.style.borderRadius || '0', 10) || '0').toString());
        }, updateId = () => {
            val_val(prop, '.id', image.getAttribute('id') || '');
        }, updateStyle = () => {
            val_val(prop, '.style', image.getAttribute('style') || '');
        }, updateClasses = () => {
            val_val(prop, '.classes', (image.getAttribute('class') || '').replace(/jodit_focused_image[\s]*/, ''));
        }, updateMargins = () => {
            if (!opt.image.editMargins) {
                return;
            }
            let notequal = false;
            $$('.margins', prop).forEach((elm) => {
                const id = elm.getAttribute('data-id') || '';
                let value = image.style[id];
                if (!value) {
                    return;
                }
                if (/^[0-9]+(px)?$/.test(value)) {
                    value = parseInt(value, 10);
                }
                elm.value = value.toString() || '';
                if (!notequal &&
                    id !== 'marginTop' &&
                    elm.value !==
                        val_val(prop, '.marginTop')) {
                    notequal = true;
                }
            });
            lockMargin = !notequal;
            const lock_margin = prop.querySelector('.jodit_lock_margin');
            if (lock_margin) {
                lock_margin.innerHTML = gi(lockMargin ? 'lock' : 'unlock');
            }
            $$('.margins:not(.marginTop)', prop).forEach((elm) => !lockMargin
                ? elm.removeAttribute('disabled')
                : elm.setAttribute('disabled', 'true'));
        }, updateSizes = () => {
            $w.value = image.offsetWidth.toString();
            $h.value = image.offsetHeight.toString();
        }, updateText = () => {
            if (image.hasAttribute('title')) {
                val_val(prop, '.imageTitle', image.getAttribute('title') || '');
            }
            if (image.hasAttribute('alt')) {
                val_val(prop, '.imageAlt', image.getAttribute('alt') || '');
            }
            const a = Dom_Dom.closest(image, 'a', editor.editor);
            if (a) {
                val_val(prop, '.imageLink', a.getAttribute('href') || '');
                prop.querySelector('.imageLinkOpenInNewTab').checked =
                    a.getAttribute('target') === '_blank';
            }
        }, updateSrc = () => {
            val_val(prop, '.imageSrc', image.getAttribute('src') || '');
            const imageViewSrc = prop.querySelector('.imageViewSrc');
            if (imageViewSrc) {
                imageViewSrc.setAttribute('src', image.getAttribute('src') || '');
            }
        }, update = () => {
            updateSrc();
            updateText();
            updateSizes();
            updateMargins();
            updateClasses();
            updateId();
            updateBorderRadius();
            updateAlign();
            updateStyle();
        };
        let lockSize = true, lockMargin = true;
        const tabs = {}, tabsbox = prop.querySelector('.tabsbox');
        tabs['Image'] = mainTab;
        tabs['Advanced'] = positionTab;
        if (tabsbox) {
            tabsbox.appendChild(image_properties_TabsWidget(editor, tabs));
        }
        update();
        editor.events.on(dialog, 'afterClose', () => {
            dialog.destruct();
            if (image.parentNode && opt.image.selectImageAfterClose) {
                editor.selection.select(image);
            }
        });
        buttons.remove.addEventListener('click', () => {
            editor.selection.removeNode(image);
            dialog.close();
        });
        if (opt.image.useImageEditor) {
            $$('.jodit_use_image_editor', mainTab).forEach((btn) => {
                editor.events.on(btn, 'mousedown touchstart', () => {
                    const url = image.getAttribute('src') || '', a = editor.create.element('a'), loadExternal = () => {
                        if (a.host !== location.host) {
                            Confirm(i18n('You can only edit your own images. Download this image on the host?'), (yes) => {
                                if (yes && editor.uploader) {
                                    editor.uploader.uploadRemoteImage(a.href.toString(), (resp) => {
                                        Alert(i18n('The image has been successfully uploaded to the host!'), () => {
                                            if (typeof resp.newfilename ===
                                                'string') {
                                                image.setAttribute('src', resp.baseurl +
                                                    resp.newfilename);
                                                updateSrc();
                                            }
                                        });
                                    }, (error) => {
                                        Alert(i18n('There was an error loading %s', error.message));
                                    });
                                }
                            });
                            return;
                        }
                    };
                    a.href = url;
                    editor.getInstance('FileBrowser').dataProvider.getPathByUrl(a.href.toString(), (path, name, source) => {
                        editor.getInstance('FileBrowser').openImageEditor(a.href, name, path, source, () => {
                            const timestamp = new Date().getTime();
                            image.setAttribute('src', url +
                                (url.indexOf('?') !== -1
                                    ? ''
                                    : '?') +
                                '&_tmp=' +
                                timestamp.toString());
                            updateSrc();
                        }, (error) => {
                            Alert(error.message);
                        });
                    }, (error) => {
                        Alert(error.message, loadExternal);
                    });
                });
            });
        }
        $$('.jodit_rechange', mainTab).forEach((imagebtn) => {
            imagebtn.addEventListener('mousedown', (event) => {
                imagebtn.classList.toggle('active');
                const popup = new popup_Popup(editor, imagebtn);
                popup.open(image_properties_FileSelectorWidget(editor, {
                    upload: (data) => {
                        if (data.files && data.files.length) {
                            image.setAttribute('src', data.baseurl + data.files[0]);
                        }
                        update();
                        popup.close();
                    },
                    filebrowser: (data) => {
                        if (data &&
                            data.files &&
                            Array.isArray(data.files) &&
                            data.files.length) {
                            image.setAttribute('src', data.files[0]);
                            popup.close();
                            update();
                        }
                    }
                }, image, popup.close), true);
                event.stopPropagation();
            });
        });
        const jodit_lock_size = prop.querySelector('.jodit_lock_helper.jodit_lock_size'), jodit_lock_margin = prop.querySelector('.jodit_lock_helper.jodit_lock_margin');
        if (jodit_lock_size) {
            jodit_lock_size.addEventListener('click', function () {
                lockSize = !lockSize;
                this.innerHTML = gi(lockSize ? 'lock' : 'unlock');
                editor.events.fire($w, 'change');
            });
        }
        if (jodit_lock_margin) {
            jodit_lock_margin.addEventListener('click', function () {
                lockMargin = !lockMargin;
                this.innerHTML = gi(lockMargin ? 'lock' : 'unlock');
                if (!lockMargin) {
                    $$('.margins', prop).forEach(elm => {
                        if (!elm.matches('.marginTop')) {
                            elm.removeAttribute('disabled');
                        }
                    });
                }
                else {
                    $$('.margins', prop).forEach(elm => {
                        if (!elm.matches('.marginTop')) {
                            elm.setAttribute('disabled', 'true');
                        }
                    });
                }
            });
        }
        const changeSizes = (event) => {
            const w = parseInt($w.value, 10), h = parseInt($h.value, 10);
            if (event.target === $w) {
                $h.value = Math.round(w / ratio).toString();
            }
            else {
                $w.value = Math.round(h * ratio).toString();
            }
        };
        editor.events.on([$w, $h], 'change keydown mousedown paste', (event) => {
            if (!lockSize) {
                return;
            }
            editor.async.setTimeout(changeSizes.bind(this, event), {
                timeout: editor.defaultTimeout,
                label: 'image-properties-changeSize'
            });
        });
        dialog.setTitle(i18n('Image properties'));
        dialog.setContent(prop);
        buttons.check.addEventListener('click', () => {
            if (opt.image.editStyle) {
                if (val_val(prop, '.style')) {
                    image.setAttribute('style', val_val(prop, '.style'));
                }
                else {
                    image.removeAttribute('style');
                }
            }
            if (val_val(prop, '.imageSrc')) {
                image.setAttribute('src', val_val(prop, '.imageSrc'));
            }
            else {
                Dom_Dom.safeRemove(image);
                dialog.close();
                return;
            }
            if (val_val(prop, '.border_radius') !== '0' &&
                /^[0-9]+$/.test(val_val(prop, '.border_radius'))) {
                image.style.borderRadius = val_val(prop, '.border_radius') + 'px';
            }
            else {
                image.style.borderRadius = '';
            }
            if (val_val(prop, '.imageTitle')) {
                image.setAttribute('title', val_val(prop, '.imageTitle'));
            }
            else {
                image.removeAttribute('title');
            }
            if (val_val(prop, '.imageAlt')) {
                image.setAttribute('alt', val_val(prop, '.imageAlt'));
            }
            else {
                image.removeAttribute('alt');
            }
            let link = Dom_Dom.closest(image, 'a', editor.editor);
            if (val_val(prop, '.imageLink')) {
                if (!link) {
                    link = Dom_Dom.wrap(image, 'a', editor);
                }
                link.setAttribute('href', val_val(prop, '.imageLink'));
                if (prop.querySelector('.imageLinkOpenInNewTab').checked) {
                    link.setAttribute('target', '_blank');
                }
                else {
                    link.removeAttribute('target');
                }
            }
            else {
                if (link && link.parentNode) {
                    link.parentNode.replaceChild(image, link);
                }
            }
            const normalSize = (value) => {
                value = trim(value);
                return /^[0-9]+$/.test(value) ? value + 'px' : value;
            };
            if ($w.value !== image.offsetWidth.toString() ||
                $h.value !== image.offsetHeight.toString()) {
                css_css(image, {
                    width: trim($w.value) ? normalSize($w.value) : null,
                    height: trim($h.value) ? normalSize($h.value) : null
                });
            }
            if (opt.image.editMargins) {
                if (!lockMargin) {
                    $$('.margins', prop).forEach((margin) => {
                        const id = margin.getAttribute('data-id') || '';
                        css_css(image, id, normalSize(margin.value));
                    });
                }
                else {
                    css_css(image, 'margin', normalSize(val_val(prop, '.marginTop')));
                }
            }
            if (opt.image.editClass) {
                if (val_val(prop, '.classes')) {
                    image.setAttribute('class', val_val(prop, '.classes'));
                }
                else {
                    image.removeAttribute('class');
                }
            }
            if (opt.image.editId) {
                if (val_val(prop, '.id')) {
                    image.setAttribute('id', val_val(prop, '.id'));
                }
                else {
                    image.removeAttribute('id');
                }
            }
            if (opt.image.editAlign) {
                if (val_val(prop, '.align')) {
                    if (['right', 'left'].indexOf(val_val(prop, '.align').toLowerCase()) !== -1) {
                        css_css(image, 'float', val_val(prop, '.align'));
                        clearCenterAlign(image);
                    }
                    else {
                        css_css(image, 'float', '');
                        css_css(image, {
                            display: 'block',
                            'margin-left': 'auto',
                            'margin-right': 'auto'
                        });
                    }
                }
                else {
                    if (css_css(image, 'float') &&
                        ['right', 'left'].indexOf(css_css(image, 'float')
                            .toString()
                            .toLowerCase()) !== -1) {
                        css_css(image, 'float', '');
                    }
                    clearCenterAlign(image);
                }
            }
            if (!image.getAttribute('style')) {
                image.removeAttribute('style');
            }
            editor.setEditorValue();
            dialog.close();
        });
        buttons.cancel.addEventListener('click', () => dialog.close());
        dialog.setFooter([[buttons.cancel, buttons.remove], buttons.check]);
        dialog.setSize(500);
        dialog.open();
        if (e) {
            e.preventDefault();
        }
        return false;
    };
    editor.events
        .on('beforeDestruct', () => {
        editor.events.off(editor.editor, '.imageproperties');
    })
        .on('afterInit changePlace', () => {
        editor.events.off(editor.editor, '.imageproperties');
        if (opt.image.openOnDblClick) {
            editor.events.on(editor.editor, 'dblclick.imageproperties', open, 'img');
        }
        else {
            editor.events.on(editor.editor, 'dblclick.imageproperties', function (event) {
                event.stopImmediatePropagation();
                editor.selection.select(this);
            }, 'img');
        }
    })
        .on('openImageProperties', (image) => {
        open.call(image);
    });
}

// CONCATENATED MODULE: ./src/plugins/indent.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.controls.indent = {
    tooltip: 'Increase Indent'
};
Config_Config.prototype.controls.outdent = {
    isDisable: (editor) => {
        const current = editor.selection.current();
        if (current) {
            const currentBox = Dom_Dom.closest(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
            if (currentBox && currentBox.style && currentBox.style.marginLeft) {
                return parseInt(currentBox.style.marginLeft, 10) <= 0;
            }
        }
        return true;
    },
    tooltip: 'Decrease Indent'
};
Config_Config.prototype.indentMargin = 10;
function indent(editor) {
    const callback = (command) => {
        const indentedBoxes = [];
        editor.selection.eachSelection((current) => {
            const selectionInfo = editor.selection.save();
            let currentBox = current
                ? Dom_Dom.up(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor)
                : false;
            const enter = editor.options.enter;
            if (!currentBox && current) {
                currentBox = Dom_Dom.wrapInline(current, enter !== BR ? enter : PARAGRAPH, editor);
            }
            if (!currentBox) {
                editor.selection.restore(selectionInfo);
                return false;
            }
            const alreadyIndented = indentedBoxes.indexOf(currentBox) !== -1;
            if (currentBox && currentBox.style && !alreadyIndented) {
                indentedBoxes.push(currentBox);
                let marginLeft = currentBox.style.marginLeft
                    ? parseInt(currentBox.style.marginLeft, 10)
                    : 0;
                marginLeft +=
                    editor.options.indentMargin *
                        (command === 'outdent' ? -1 : 1);
                currentBox.style.marginLeft =
                    marginLeft > 0 ? marginLeft + 'px' : '';
                if (!currentBox.getAttribute('style')) {
                    currentBox.removeAttribute('style');
                }
            }
            editor.selection.restore(selectionInfo);
        });
        editor.setEditorValue();
        return false;
    };
    editor.registerCommand('indent', {
        exec: callback,
        hotkeys: ['ctrl+]', 'cmd+]']
    });
    editor.registerCommand('outdent', {
        exec: callback,
        hotkeys: ['ctrl+[', 'cmd+[']
    });
}

// CONCATENATED MODULE: ./src/modules/Table.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



class Table_Table {
    static addSelected(td) {
        td.setAttribute(JODIT_SELECTED_CELL_MARKER, '1');
    }
    static restoreSelection(td) {
        td.removeAttribute(JODIT_SELECTED_CELL_MARKER);
    }
    static getAllSelectedCells(table) {
        return table
            ? $$(`td[${JODIT_SELECTED_CELL_MARKER}],th[${JODIT_SELECTED_CELL_MARKER}]`, table)
            : [];
    }
    static getRowsCount(table) {
        return table.rows.length;
    }
    static getColumnsCount(table) {
        const matrix = Table_Table.formalMatrix(table);
        return matrix.reduce((max_count, cells) => {
            return Math.max(max_count, cells.length);
        }, 0);
    }
    static formalMatrix(table, callback) {
        const matrix = [[]];
        const rows = Array.prototype.slice.call(table.rows);
        const setCell = (cell, i) => {
            if (matrix[i] === undefined) {
                matrix[i] = [];
            }
            const colSpan = cell.colSpan, rowSpan = cell.rowSpan;
            let column, row, currentColumn = 0;
            while (matrix[i][currentColumn]) {
                currentColumn += 1;
            }
            for (row = 0; row < rowSpan; row += 1) {
                for (column = 0; column < colSpan; column += 1) {
                    if (matrix[i + row] === undefined) {
                        matrix[i + row] = [];
                    }
                    if (callback &&
                        callback(cell, i + row, currentColumn + column, colSpan, rowSpan) === false) {
                        return false;
                    }
                    matrix[i + row][currentColumn + column] = cell;
                }
            }
        };
        for (let i = 0, j; i < rows.length; i += 1) {
            const cells = Array.prototype.slice.call(rows[i].cells);
            for (j = 0; j < cells.length; j += 1) {
                if (setCell(cells[j], i) === false) {
                    return matrix;
                }
            }
        }
        return matrix;
    }
    static formalCoordinate(table, cell, max = false) {
        let i = 0, j = 0, width = 1, height = 1;
        Table_Table.formalMatrix(table, (td, ii, jj, colSpan, rowSpan) => {
            if (cell === td) {
                i = ii;
                j = jj;
                width = colSpan || 1;
                height = rowSpan || 1;
                if (max) {
                    j += (colSpan || 1) - 1;
                    i += (rowSpan || 1) - 1;
                }
                return false;
            }
        });
        return [i, j, width, height];
    }
    static appendRow(table, line, after, create) {
        const columnsCount = Table_Table.getColumnsCount(table), row = create.element('tr');
        for (let j = 0; j < columnsCount; j += 1) {
            row.appendChild(create.element('td'));
        }
        if (after && line && line.nextSibling) {
            line.parentNode &&
                line.parentNode.insertBefore(row, line.nextSibling);
        }
        else if (!after && line) {
            line.parentNode && line.parentNode.insertBefore(row, line);
        }
        else {
            ($$(':scope>tbody', table)[0] || table).appendChild(row);
        }
    }
    static removeRow(table, rowIndex) {
        const box = Table_Table.formalMatrix(table);
        let dec;
        const row = table.rows[rowIndex];
        each(box[rowIndex], (j, cell) => {
            dec = false;
            if (rowIndex - 1 >= 0 && box[rowIndex - 1][j] === cell) {
                dec = true;
            }
            else if (box[rowIndex + 1] && box[rowIndex + 1][j] === cell) {
                if (cell.parentNode === row &&
                    cell.parentNode.nextSibling) {
                    dec = true;
                    let nextCell = j + 1;
                    while (box[rowIndex + 1][nextCell] === cell) {
                        nextCell += 1;
                    }
                    const nextRow = Dom_Dom.next(cell.parentNode, (elm) => elm &&
                        elm.nodeType === Node.ELEMENT_NODE &&
                        elm.nodeName === 'TR', table);
                    if (box[rowIndex + 1][nextCell]) {
                        nextRow.insertBefore(cell, box[rowIndex + 1][nextCell]);
                    }
                    else {
                        nextRow.appendChild(cell);
                    }
                }
            }
            else {
                Dom_Dom.safeRemove(cell);
            }
            if (dec &&
                (cell.parentNode === row || cell !== box[rowIndex][j - 1])) {
                const rowSpan = cell.rowSpan;
                if (rowSpan - 1 > 1) {
                    cell.setAttribute('rowspan', (rowSpan - 1).toString());
                }
                else {
                    cell.removeAttribute('rowspan');
                }
            }
        });
        Dom_Dom.safeRemove(row);
    }
    static appendColumn(table, j, after, create) {
        const box = Table_Table.formalMatrix(table);
        let i;
        if (j === undefined || j < 0) {
            j = Table_Table.getColumnsCount(table) - 1;
        }
        for (i = 0; i < box.length; i += 1) {
            const cell = create.element('td');
            const td = box[i][j];
            let added = false;
            if (after) {
                if ((box[i] && td && j + 1 >= box[i].length) ||
                    td !== box[i][j + 1]) {
                    if (td.nextSibling) {
                        td.parentNode &&
                            td.parentNode.insertBefore(cell, td.nextSibling);
                    }
                    else {
                        td.parentNode && td.parentNode.appendChild(cell);
                    }
                    added = true;
                }
            }
            else {
                if (j - 1 < 0 ||
                    (box[i][j] !== box[i][j - 1] && box[i][j].parentNode)) {
                    td.parentNode &&
                        td.parentNode.insertBefore(cell, box[i][j]);
                    added = true;
                }
            }
            if (!added) {
                box[i][j].setAttribute('colspan', (parseInt(box[i][j].getAttribute('colspan') || '1', 10) +
                    1).toString());
            }
        }
    }
    static removeColumn(table, j) {
        const box = Table_Table.formalMatrix(table);
        let dec;
        each(box, (i, cells) => {
            const td = cells[j];
            dec = false;
            if (j - 1 >= 0 && box[i][j - 1] === td) {
                dec = true;
            }
            else if (j + 1 < cells.length && box[i][j + 1] === td) {
                dec = true;
            }
            else {
                Dom_Dom.safeRemove(td);
            }
            if (dec && (i - 1 < 0 || td !== box[i - 1][j])) {
                const colSpan = td.colSpan;
                if (colSpan - 1 > 1) {
                    td.setAttribute('colspan', (colSpan - 1).toString());
                }
                else {
                    td.removeAttribute('colspan');
                }
            }
        });
    }
    static getSelectedBound(table, selectedCells) {
        const bound = [
            [Infinity, Infinity],
            [0, 0]
        ];
        const box = Table_Table.formalMatrix(table);
        let i, j, k;
        for (i = 0; i < box.length; i += 1) {
            for (j = 0; j < box[i].length; j += 1) {
                if (selectedCells.indexOf(box[i][j]) !== -1) {
                    bound[0][0] = Math.min(i, bound[0][0]);
                    bound[0][1] = Math.min(j, bound[0][1]);
                    bound[1][0] = Math.max(i, bound[1][0]);
                    bound[1][1] = Math.max(j, bound[1][1]);
                }
            }
        }
        for (i = bound[0][0]; i <= bound[1][0]; i += 1) {
            for (k = 1, j = bound[0][1]; j <= bound[1][1]; j += 1) {
                while (box[i][j - k] && box[i][j] === box[i][j - k]) {
                    bound[0][1] = Math.min(j - k, bound[0][1]);
                    bound[1][1] = Math.max(j - k, bound[1][1]);
                    k += 1;
                }
                k = 1;
                while (box[i][j + k] && box[i][j] === box[i][j + k]) {
                    bound[0][1] = Math.min(j + k, bound[0][1]);
                    bound[1][1] = Math.max(j + k, bound[1][1]);
                    k += 1;
                }
                k = 1;
                while (box[i - k] && box[i][j] === box[i - k][j]) {
                    bound[0][0] = Math.min(i - k, bound[0][0]);
                    bound[1][0] = Math.max(i - k, bound[1][0]);
                    k += 1;
                }
                k = 1;
                while (box[i + k] && box[i][j] === box[i + k][j]) {
                    bound[0][0] = Math.min(i + k, bound[0][0]);
                    bound[1][0] = Math.max(i + k, bound[1][0]);
                    k += 1;
                }
            }
        }
        return bound;
    }
    static normalizeTable(table) {
        let i, j, min, not;
        const __marked = [], box = Table_Table.formalMatrix(table);
        for (j = 0; j < box[0].length; j += 1) {
            min = 1000000;
            not = false;
            for (i = 0; i < box.length; i += 1) {
                if (box[i][j] === undefined) {
                    continue;
                }
                if (box[i][j].colSpan < 2) {
                    not = true;
                    break;
                }
                min = Math.min(min, box[i][j].colSpan);
            }
            if (!not) {
                for (i = 0; i < box.length; i += 1) {
                    if (box[i][j] === undefined) {
                        continue;
                    }
                    Table_Table.__mark(box[i][j], 'colspan', box[i][j].colSpan - min + 1, __marked);
                }
            }
        }
        for (i = 0; i < box.length; i += 1) {
            min = 1000000;
            not = false;
            for (j = 0; j < box[i].length; j += 1) {
                if (box[i][j] === undefined) {
                    continue;
                }
                if (box[i][j].rowSpan < 2) {
                    not = true;
                    break;
                }
                min = Math.min(min, box[i][j].rowSpan);
            }
            if (!not) {
                for (j = 0; j < box[i].length; j += 1) {
                    if (box[i][j] === undefined) {
                        continue;
                    }
                    Table_Table.__mark(box[i][j], 'rowspan', box[i][j].rowSpan - min + 1, __marked);
                }
            }
        }
        for (i = 0; i < box.length; i += 1) {
            for (j = 0; j < box[i].length; j += 1) {
                if (box[i][j] === undefined) {
                    continue;
                }
                if (box[i][j].hasAttribute('rowspan') &&
                    box[i][j].rowSpan === 1) {
                    box[i][j].removeAttribute('rowspan');
                }
                if (box[i][j].hasAttribute('colspan') &&
                    box[i][j].colSpan === 1) {
                    box[i][j].removeAttribute('colspan');
                }
                if (box[i][j].hasAttribute('class') &&
                    !box[i][j].getAttribute('class')) {
                    box[i][j].removeAttribute('class');
                }
            }
        }
        Table_Table.__unmark(__marked);
    }
    static mergeSelected(table) {
        const html = [], bound = Table_Table.getSelectedBound(table, Table_Table.getAllSelectedCells(table));
        let w = 0, first = null, first_j = 0, td, cols = 0, rows = 0;
        const __marked = [];
        if (bound && (bound[0][0] - bound[1][0] || bound[0][1] - bound[1][1])) {
            Table_Table.formalMatrix(table, (cell, i, j, cs, rs) => {
                if (i >= bound[0][0] && i <= bound[1][0]) {
                    if (j >= bound[0][1] && j <= bound[1][1]) {
                        td = cell;
                        if (td.__i_am_already_was) {
                            return;
                        }
                        td.__i_am_already_was = true;
                        if (i === bound[0][0] && td.style.width) {
                            w += td.offsetWidth;
                        }
                        if (trim(cell.innerHTML.replace(/<br(\/)?>/g, '')) !== '') {
                            html.push(cell.innerHTML);
                        }
                        if (cs > 1) {
                            cols += cs - 1;
                        }
                        if (rs > 1) {
                            rows += rs - 1;
                        }
                        if (!first) {
                            first = cell;
                            first_j = j;
                        }
                        else {
                            Table_Table.__mark(td, 'remove', 1, __marked);
                        }
                    }
                }
            });
            cols = bound[1][1] - bound[0][1] + 1;
            rows = bound[1][0] - bound[0][0] + 1;
            if (first) {
                if (cols > 1) {
                    Table_Table.__mark(first, 'colspan', cols, __marked);
                }
                if (rows > 1) {
                    Table_Table.__mark(first, 'rowspan', rows, __marked);
                }
                if (w) {
                    Table_Table.__mark(first, 'width', ((w / table.offsetWidth) * 100).toFixed(ACCURACY) + '%', __marked);
                    if (first_j) {
                        Table_Table.setColumnWidthByDelta(table, first_j, 0, true, __marked);
                    }
                }
                first.innerHTML = html.join('<br/>');
                delete first.__i_am_already_was;
                Table_Table.__unmark(__marked);
                Table_Table.normalizeTable(table);
                each(Array.from(table.rows), (index, tr) => {
                    if (!tr.cells.length) {
                        Dom_Dom.safeRemove(tr);
                    }
                });
            }
        }
    }
    static splitHorizontal(table, create) {
        let coord, td, tr, parent, after;
        const __marked = [];
        Table_Table.getAllSelectedCells(table).forEach((cell) => {
            td = create.element('td');
            td.appendChild(create.element('br'));
            tr = create.element('tr');
            coord = Table_Table.formalCoordinate(table, cell);
            if (cell.rowSpan < 2) {
                Table_Table.formalMatrix(table, (tdElm, i, j) => {
                    if (coord[0] === i &&
                        coord[1] !== j &&
                        tdElm !== cell) {
                        Table_Table.__mark(tdElm, 'rowspan', tdElm.rowSpan + 1, __marked);
                    }
                });
                Dom_Dom.after(Dom_Dom.closest(cell, 'tr', table), tr);
                tr.appendChild(td);
            }
            else {
                Table_Table.__mark(cell, 'rowspan', cell.rowSpan - 1, __marked);
                Table_Table.formalMatrix(table, (tdElm, i, j) => {
                    if (i > coord[0] &&
                        i < coord[0] + cell.rowSpan &&
                        coord[1] > j &&
                        tdElm.parentNode
                            .rowIndex === i) {
                        after = tdElm;
                    }
                    if (coord[0] < i && tdElm === cell) {
                        parent = table.rows[i];
                    }
                });
                if (after) {
                    Dom_Dom.after(after, td);
                }
                else {
                    parent.insertBefore(td, parent.firstChild);
                }
            }
            if (cell.colSpan > 1) {
                Table_Table.__mark(td, 'colspan', cell.colSpan, __marked);
            }
            Table_Table.__unmark(__marked);
            Table_Table.restoreSelection(cell);
        });
        this.normalizeTable(table);
    }
    static splitVertical(table, create) {
        let coord, td, percentage;
        const __marked = [];
        Table_Table.getAllSelectedCells(table).forEach((cell) => {
            coord = Table_Table.formalCoordinate(table, cell);
            if (cell.colSpan < 2) {
                Table_Table.formalMatrix(table, (tdElm, i, j) => {
                    if (coord[1] === j &&
                        coord[0] !== i &&
                        tdElm !== cell) {
                        Table_Table.__mark(tdElm, 'colspan', tdElm.colSpan + 1, __marked);
                    }
                });
            }
            else {
                Table_Table.__mark(cell, 'colspan', cell.colSpan - 1, __marked);
            }
            td = create.element('td');
            td.appendChild(create.element('br'));
            if (cell.rowSpan > 1) {
                Table_Table.__mark(td, 'rowspan', cell.rowSpan, __marked);
            }
            const oldWidth = cell.offsetWidth;
            Dom_Dom.after(cell, td);
            percentage = oldWidth / table.offsetWidth / 2;
            Table_Table.__mark(cell, 'width', (percentage * 100).toFixed(ACCURACY) + '%', __marked);
            Table_Table.__mark(td, 'width', (percentage * 100).toFixed(ACCURACY) + '%', __marked);
            Table_Table.__unmark(__marked);
            Table_Table.restoreSelection(cell);
        });
        Table_Table.normalizeTable(table);
    }
    static setColumnWidthByDelta(table, j, delta, noUnmark, marked) {
        const box = Table_Table.formalMatrix(table);
        let i, w, percent;
        for (i = 0; i < box.length; i += 1) {
            w = box[i][j].offsetWidth;
            percent = ((w + delta) / table.offsetWidth) * 100;
            Table_Table.__mark(box[i][j], 'width', percent.toFixed(ACCURACY) + '%', marked);
        }
        if (!noUnmark) {
            Table_Table.__unmark(marked);
        }
    }
    static __mark(cell, key, value, marked) {
        marked.push(cell);
        if (!cell.__marked_value) {
            cell.__marked_value = {};
        }
        cell.__marked_value[key] = value === undefined ? 1 : value;
    }
    static __unmark(marked) {
        marked.forEach(cell => {
            if (cell.__marked_value) {
                each(cell.__marked_value, (key, value) => {
                    switch (key) {
                        case 'remove':
                            Dom_Dom.safeRemove(cell);
                            break;
                        case 'rowspan':
                            if (value > 1) {
                                cell.setAttribute('rowspan', value.toString());
                            }
                            else {
                                cell.removeAttribute('rowspan');
                            }
                            break;
                        case 'colspan':
                            if (value > 1) {
                                cell.setAttribute('colspan', value.toString());
                            }
                            else {
                                cell.removeAttribute('colspan');
                            }
                            break;
                        case 'width':
                            cell.style.width = value.toString();
                            break;
                    }
                    delete cell.__marked_value[key];
                });
                delete cell.__marked_value;
            }
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/inline-popup.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


var inline_popup_ColorPickerWidget = Widget_Widget.ColorPickerWidget;
var inline_popup_TabsWidget = Widget_Widget.TabsWidget;






Config_Config.prototype.toolbarInline = true;
Config_Config.prototype.toolbarInlineDisableFor = [];
Config_Config.prototype.popup = {
    a: [
        {
            name: 'eye',
            tooltip: 'Open link',
            exec: (editor, current) => {
                const href = current.getAttribute('href');
                if (current && href) {
                    editor.ownerWindow.open(href);
                }
            }
        },
        {
            name: 'link',
            tooltip: 'Edit link',
            icon: 'pencil'
        },
        'unlink',
        'brush',
        'file'
    ],
    jodit: [
        {
            name: 'bin',
            tooltip: 'Delete',
            exec: (editor, image) => {
                editor.selection.removeNode(image);
                editor.events.fire('hidePopup');
            }
        }
    ],
    'jodit-media': [
        {
            name: 'bin',
            tooltip: 'Delete',
            exec: (editor, image) => {
                editor.selection.removeNode(image);
                editor.events.fire('hidePopup');
            }
        }
    ],
    img: [
        {
            name: 'delete',
            icon: 'bin',
            tooltip: 'Delete',
            exec: (editor, image) => {
                editor.selection.removeNode(image);
                editor.events.fire('hidePopup');
            }
        },
        {
            name: 'pencil',
            exec(editor, current) {
                const tagName = current.tagName.toLowerCase();
                if (tagName === 'img') {
                    editor.events.fire('openImageProperties', current);
                }
            },
            tooltip: 'Edit'
        },
        {
            name: 'valign',
            list: ['Top', 'Middle', 'Bottom'],
            tooltip: 'Vertical align',
            exec: (editor, image, control) => {
                const tagName = image.tagName.toLowerCase();
                if (tagName !== 'img') {
                    return;
                }
                const command = control.args && typeof control.args[1] === 'string'
                    ? control.args[1].toLowerCase()
                    : '';
                css_css(image, 'vertical-align', command);
                editor.events.fire('recalcPositionPopup');
            }
        },
        {
            name: 'left',
            list: ['Left', 'Right', 'Center', 'Normal'],
            exec: (editor, image, control) => {
                const tagName = image.tagName.toLowerCase();
                if (tagName !== 'img') {
                    return;
                }
                const command = control.args && typeof control.args[1] === 'string'
                    ? control.args[1].toLowerCase()
                    : '';
                if (command !== 'normal') {
                    if (['right', 'left'].indexOf(command) !== -1) {
                        css_css(image, 'float', command);
                        clearCenterAlign(image);
                    }
                    else {
                        css_css(image, 'float', '');
                        css_css(image, {
                            display: 'block',
                            'margin-left': 'auto',
                            'margin-right': 'auto'
                        });
                    }
                }
                else {
                    if (css_css(image, 'float') &&
                        ['right', 'left'].indexOf(css_css(image, 'float').toLowerCase()) !== -1) {
                        css_css(image, 'float', '');
                    }
                    clearCenterAlign(image);
                }
                editor.events.fire('recalcPositionPopup');
            },
            tooltip: 'Horizontal align'
        }
    ],
    table: [
        {
            name: 'brush',
            popup: (editor, elm) => {
                const selected = Table_Table.getAllSelectedCells(elm);
                let $bg, $cl, $br, $tab, color, br_color, bg_color;
                if (!selected.length) {
                    return false;
                }
                color = css_css(selected[0], 'color');
                bg_color = css_css(selected[0], 'background-color');
                br_color = css_css(selected[0], 'border-color');
                $bg = inline_popup_ColorPickerWidget(editor, (value) => {
                    selected.forEach((cell) => {
                        css_css(cell, 'background-color', value);
                    });
                    editor.setEditorValue();
                }, bg_color);
                $cl = inline_popup_ColorPickerWidget(editor, (value) => {
                    selected.forEach((cell) => {
                        css_css(cell, 'color', value);
                    });
                    editor.setEditorValue();
                }, color);
                $br = inline_popup_ColorPickerWidget(editor, (value) => {
                    selected.forEach((cell) => {
                        css_css(cell, 'border-color', value);
                    });
                    editor.setEditorValue();
                }, br_color);
                $tab = inline_popup_TabsWidget(editor, {
                    Background: $bg,
                    Text: $cl,
                    Border: $br
                });
                return $tab;
            },
            tooltip: 'Background'
        },
        {
            name: 'valign',
            list: ['Top', 'Middle', 'Bottom'],
            exec: (editor, table, control) => {
                const command = control.args && typeof control.args[1] === 'string'
                    ? control.args[1].toLowerCase()
                    : '';
                Table_Table.getAllSelectedCells(table).forEach((cell) => {
                    css_css(cell, 'vertical-align', command);
                });
            },
            tooltip: 'Vertical align'
        },
        {
            name: 'splitv',
            list: {
                tablesplitv: 'Split vertical',
                tablesplitg: 'Split horizontal'
            },
            tooltip: 'Split'
        },
        {
            name: 'align',
            icon: 'left'
        },
        '\n',
        {
            name: 'merge',
            command: 'tablemerge',
            tooltip: 'Merge'
        },
        {
            name: 'addcolumn',
            list: {
                tableaddcolumnbefore: 'Insert column before',
                tableaddcolumnafter: 'Insert column after'
            },
            exec: (editor, table, control) => {
                const command = control.args && typeof control.args[0] === 'string'
                    ? control.args[0].toLowerCase()
                    : '';
                editor.execCommand(command, false, table);
            },
            tooltip: 'Add column'
        },
        {
            name: 'addrow',
            list: {
                tableaddrowbefore: 'Insert row above',
                tableaddrowafter: 'Insert row below'
            },
            exec: (editor, table, control) => {
                const command = control.args && typeof control.args[0] === 'string'
                    ? control.args[0].toLowerCase()
                    : '';
                editor.execCommand(command, false, table);
            },
            tooltip: 'Add row'
        },
        {
            name: 'delete',
            icon: 'bin',
            list: {
                tablebin: 'Delete table',
                tablebinrow: 'Delete row',
                tablebincolumn: 'Delete column',
                tableempty: 'Empty cell'
            },
            exec: (editor, table, control) => {
                const command = control.args && typeof control.args[0] === 'string'
                    ? control.args[0].toLowerCase()
                    : '';
                editor.execCommand(command, false, table);
                editor.events.fire('hidePopup');
            },
            tooltip: 'Delete'
        }
    ]
};
class inline_popup_inlinePopup extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this._hiddenClass = 'jodit_toolbar_popup-inline-target-hidden';
        this.isSelectionStarted = false;
        this.onSelectionEnd = debounce(() => {
            if (this.isDestructed || !this.jodit.isEditorMode()) {
                return;
            }
            if (this.isSelectionStarted) {
                if (!this.isTargetAction) {
                    this.onChangeSelection();
                }
            }
            this.isSelectionStarted = false;
            this.isTargetAction = false;
        }, this.jodit.defaultTimeout);
        this.isTargetAction = false;
        this.isSelectionPopup = false;
        this.calcWindSizes = () => {
            const win = this.jodit.ownerWindow;
            const docElement = this.jodit.ownerDocument
                .documentElement;
            if (!docElement) {
                return {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                };
            }
            const body = this.jodit.ownerDocument.body;
            const scrollTop = win.pageYOffset || docElement.scrollTop || body.scrollTop;
            const clientTop = docElement.clientTop || body.clientTop || 0;
            const scrollLeft = win.pageXOffset || docElement.scrollLeft || body.scrollLeft;
            const clientLeft = docElement.clientLeft || body.clientLeft || 0;
            const windWidth = docElement.clientWidth + scrollLeft - clientLeft;
            const windHeight = docElement.clientHeight + scrollTop - clientTop;
            return {
                left: clientLeft,
                top: clientTop,
                width: windWidth,
                height: windHeight
            };
        };
        this.calcPosition = (rect, windowSize) => {
            if (this.isDestructed) {
                return;
            }
            this.popup.target.classList.remove(this._hiddenClass);
            const selectionCenterLeft = rect.left + rect.width / 2;
            const workplacePosition = offset(this.jodit.workplace, this.jodit, this.jodit.ownerDocument, true);
            let targetTop = rect.top + rect.height + 10;
            const diff = 50;
            this.target.style.left = selectionCenterLeft + 'px';
            this.target.style.top = targetTop + 'px';
            if (this.jodit.isFullSize()) {
                this.target.style.zIndex = css_css(this.jodit.container, 'zIndex').toString();
            }
            const halfWidthPopup = this.container.offsetWidth / 2;
            let marginLeft = -halfWidthPopup;
            this.popup.container.classList.remove('jodit_toolbar_popup-inline-top');
            if (targetTop + this.container.offsetHeight > windowSize.height) {
                targetTop = rect.top - this.container.offsetHeight - 10;
                this.target.style.top = targetTop + 'px';
                this.popup.container.classList.add('jodit_toolbar_popup-inline-top');
            }
            if (selectionCenterLeft - halfWidthPopup < 0) {
                marginLeft = -(rect.width / 2 + rect.left);
            }
            if (selectionCenterLeft + halfWidthPopup > windowSize.width) {
                marginLeft = -(this.container.offsetWidth -
                    (windowSize.width - selectionCenterLeft));
            }
            this.container.style.marginLeft = marginLeft + 'px';
            if (workplacePosition.top - targetTop > diff ||
                targetTop - (workplacePosition.top + workplacePosition.height) >
                    diff) {
                this.popup.target.classList.add(this._hiddenClass);
            }
        };
        this.reCalcPosition = () => {
            if (this.__getRect) {
                this.calcPosition(this.__getRect(), this.calcWindSizes());
            }
        };
        this.showPopup = (rect, type, elm) => {
            if (!this.jodit.options.toolbarInline ||
                !this.jodit.options.popup[type.toLowerCase()]) {
                return false;
            }
            if (this.isExcludedTarget(type)) {
                return true;
            }
            this.isOpened = true;
            this.isTargetAction = true;
            const windSize = this.calcWindSizes();
            this.targetContainer.parentNode ||
                this.jodit.ownerDocument.body.appendChild(this.targetContainer);
            this.toolbar.build(this.jodit.options.popup[type.toLowerCase()], this.container, elm);
            this.popup.open(this.container, false, true);
            this.__getRect = rect;
            this.calcPosition(rect(), windSize);
            return true;
        };
        this.hidePopup = (root) => {
            if (this.isDestructed) {
                return;
            }
            if (root &&
                (Dom_Dom.isNode(root, this.jodit.editorWindow || window) ||
                    root instanceof popup_Popup) &&
                Dom_Dom.isOrContains(this.target, root instanceof popup_Popup ? root.target : root)) {
                return;
            }
            this.isTargetAction = false;
            this.isOpened = false;
            this.popup.close();
            Dom_Dom.safeRemove(this.targetContainer);
        };
        this.onSelectionStart = (event) => {
            if (this.isDestructed || !this.jodit.isEditorMode()) {
                return;
            }
            this.isTargetAction = false;
            this.isSelectionPopup = false;
            if (!this.isSelectionStarted) {
                const elements = Object.keys(this.jodit.options.popup).join('|'), target = event.target.nodeName === 'IMG'
                    ? event.target
                    : Dom_Dom.closest(event.target, elements, this.jodit.editor);
                if (!target ||
                    !this.showPopup(() => offset(target, this.jodit, this.jodit.editorDocument), target.nodeName, target)) {
                    this.isSelectionStarted = true;
                }
            }
        };
        this.checkIsTargetEvent = () => {
            if (!this.isTargetAction) {
                this.hidePopup();
            }
            else {
                this.isTargetAction = false;
            }
        };
        this.isOpened = false;
        this.onChangeSelection = () => {
            if (!this.jodit.options.toolbarInline || !this.jodit.isEditorMode()) {
                return;
            }
            if (this.hideIfCollapsed()) {
                return;
            }
            if (this.jodit.options.popup.selection !== undefined) {
                const sel = this.jodit.selection.sel;
                if (sel && sel.rangeCount) {
                    this.isSelectionPopup = true;
                    const range = sel.getRangeAt(0);
                    this.showPopup(() => offset(range, this.jodit, this.jodit.editorDocument), 'selection');
                }
            }
        };
    }
    isExcludedTarget(type) {
        return (splitArray(this.jodit.options.toolbarInlineDisableFor)
            .map(a => a.toLowerCase())
            .indexOf(type.toLowerCase()) !== -1);
    }
    hideIfCollapsed() {
        if (this.jodit.selection.isCollapsed()) {
            this.hidePopup();
            return true;
        }
        return false;
    }
    afterInit(jodit) { }
    init(editor) {
        this.toolbar = joditToolbarCollection_JoditToolbarCollection.makeCollection(editor);
        this.target = editor.create.div('jodit_toolbar_popup-inline-target');
        this.targetContainer = editor.create.div('jodit_toolbar_popup-inline-container', this.target);
        this.container = editor.create.div();
        this.popup = new popup_Popup(editor, this.target, undefined, 'jodit_toolbar_popup-inline');
        editor.events
            .on(this.target, 'mousedown keydown touchstart', (e) => {
            e.stopPropagation();
        })
            .on('beforeOpenPopup hidePopup afterSetMode blur', this.hidePopup)
            .on('recalcPositionPopup', this.reCalcPosition)
            .on('getDiffButtons.mobile', (_toolbar) => {
            if (this.toolbar === _toolbar) {
                return splitArray(editor.options.buttons)
                    .filter(name => name !== '|' && name !== '\n')
                    .filter((name) => {
                    return (this.toolbar.getButtonsList().indexOf(name) < 0);
                });
            }
        })
            .on('selectionchange', this.onChangeSelection)
            .on('afterCommand afterExec', () => {
            if (this.isOpened && this.isSelectionPopup) {
                this.onChangeSelection();
            }
        })
            .on('showPopup', (elm, rect) => {
            const elementName = (typeof elm === 'string'
                ? elm
                : elm.nodeName).toLowerCase();
            this.isSelectionPopup = false;
            this.showPopup(rect, elementName, typeof elm === 'string' ? undefined : elm);
        })
            .on('mousedown keydown touchstart', this.onSelectionStart);
        editor.events.on('afterInit changePlace', () => {
            editor.events
                .off('.inlinePopup')
                .on([editor.ownerWindow, editor.editor], 'scroll.inlinePopup resize.inlinePopup', this.reCalcPosition)
                .on([editor.ownerWindow], 'mouseup.inlinePopup keyup.inlinePopup touchend.inlinePopup', this.onSelectionEnd)
                .on([editor.ownerWindow], 'mousedown.inlinePopup keydown.inlinePopup touchstart.inlinePopup', this.checkIsTargetEvent);
        });
    }
    beforeDestruct(editor) {
        this.popup && this.popup.destruct();
        delete this.popup;
        this.toolbar && this.toolbar.destruct();
        delete this.toolbar;
        Dom_Dom.safeRemove(this.target);
        Dom_Dom.safeRemove(this.container);
        editor.events &&
            editor.events
                .off([editor.ownerWindow], 'scroll resize', this.reCalcPosition)
                .off([editor.ownerWindow], 'mouseup keyup touchend', this.onSelectionEnd)
                .off([editor.ownerWindow], 'mousedown keydown touchstart', this.checkIsTargetEvent);
    }
}

// CONCATENATED MODULE: ./src/plugins/justify.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.controls.align = {
    name: 'left',
    tooltip: 'Align',
    getLabel: (editor, btn, button) => {
        const current = editor.selection.current();
        if (current) {
            const currentBox = Dom_Dom.closest(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor) || editor.editor;
            let currentValue = css_css(currentBox, 'text-align').toString();
            if (btn.defaultValue &&
                btn.defaultValue.indexOf(currentValue) !== -1) {
                currentValue = 'left';
            }
            if (button &&
                btn.data &&
                btn.data.currentValue !== currentValue &&
                btn.list &&
                btn.list.indexOf(currentValue) !== -1) {
                button.textBox.innerHTML = !editor.options.textIcons
                    ? ToolbarIcon.getIcon(currentValue, '')
                    : `<span>${currentValue}</span>`;
                button.textBox.firstChild.classList.add('jodit_icon');
                btn.data.currentValue = currentValue;
            }
        }
        return false;
    },
    isActive: (editor, btn) => {
        const current = editor.selection.current();
        if (current && btn.defaultValue) {
            const currentBox = Dom_Dom.closest(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor) || editor.editor;
            return (btn.defaultValue.indexOf(css_css(currentBox, 'text-align').toString()) === -1);
        }
        return false;
    },
    defaultValue: ['left', 'start', 'inherit'],
    data: {
        currentValue: 'left'
    },
    list: ['center', 'left', 'right', 'justify']
};
Config_Config.prototype.controls.center = {
    command: 'justifyCenter',
    css: {
        'text-align': 'center'
    },
    tooltip: 'Align Center'
};
Config_Config.prototype.controls.justify = {
    command: 'justifyFull',
    css: {
        'text-align': 'justify'
    },
    tooltip: 'Align Justify'
};
Config_Config.prototype.controls.left = {
    command: 'justifyLeft',
    css: {
        'text-align': 'left'
    },
    tooltip: 'Align Left'
};
Config_Config.prototype.controls.right = {
    command: 'justifyRight',
    css: {
        'text-align': 'right'
    },
    tooltip: 'Align Right'
};
function justify(editor) {
    const callback = (command) => {
        const justifyElm = (box) => {
            if (box instanceof editor.editorWindow.HTMLElement) {
                switch (command.toLowerCase()) {
                    case 'justifyfull':
                        box.style.textAlign = 'justify';
                        break;
                    case 'justifyright':
                        box.style.textAlign = 'right';
                        break;
                    case 'justifyleft':
                        box.style.textAlign = 'left';
                        break;
                    case 'justifycenter':
                        box.style.textAlign = 'center';
                        break;
                }
            }
        };
        editor.selection.focus();
        editor.selection.eachSelection((current) => {
            if (!current) {
                if (editor.editor.querySelector('.jodit_selected_cell')) {
                    $$('.jodit_selected_cell', editor.editor).forEach(justifyElm);
                    return false;
                }
            }
            if (!(current instanceof editor.editorWindow.Node)) {
                return;
            }
            let currentBox = current
                ? Dom_Dom.up(current, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor)
                : false;
            if (!currentBox && current) {
                currentBox = Dom_Dom.wrapInline(current, editor.options.enterBlock, editor);
            }
            justifyElm(currentBox);
        });
        return false;
    };
    editor.registerCommand('justifyfull', callback);
    editor.registerCommand('justifyright', callback);
    editor.registerCommand('justifyleft', callback);
    editor.registerCommand('justifycenter', callback);
}

// CONCATENATED MODULE: ./src/plugins/limit.ts




Config_Config.prototype.limitWords = false;
Config_Config.prototype.limitChars = false;
Config_Config.prototype.limitHTML = false;
function limit(jodit) {
    if (jodit && (jodit.options.limitWords || jodit.options.limitChars)) {
        const callback = (event, inputText = '') => {
            const text = inputText ||
                (jodit.options.limitHTML ? jodit.value : jodit.text);
            const words = text
                .replace(INVISIBLE_SPACE_REG_EXP, '')
                .split(SPACE_REG_EXP)
                .filter((e) => e.length);
            if (event && COMMAND_KEYS.indexOf(event.which) !== -1) {
                return;
            }
            if (jodit.options.limitWords &&
                jodit.options.limitWords <= words.length) {
                return jodit.options.limitWords === words.length;
            }
            if (jodit.options.limitChars &&
                jodit.options.limitChars <= words.join('').length) {
                return jodit.options.limitChars === words.join('').length;
            }
            return;
        };
        let snapshot = null;
        jodit.events
            .off('.limit')
            .on('beforePaste.limit', () => {
            snapshot = jodit.observer.snapshot.make();
        })
            .on('keydown.limit keyup.limit beforeEnter.limit beforePaste.limit', (event) => {
            if (callback(event) !== undefined) {
                return false;
            }
        })
            .on('change.limit', debounce((newValue, oldValue) => {
            if (callback(null, jodit.options.limitHTML
                ? newValue
                : stripTags(newValue)) === false) {
                jodit.value = oldValue;
            }
        }, jodit.defaultTimeout))
            .on('afterPaste.limit', () => {
            if (callback(null) === false && snapshot) {
                jodit.observer.snapshot.restore(snapshot);
                return false;
            }
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/link.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.link = {
    followOnDblClick: true,
    processVideoLink: true,
    processPastedLink: true,
    removeLinkAfterFormat: true,
    noFollowCheckbox: true,
    openInNewTabCheckbox: true
};
Config_Config.prototype.controls.unlink = {
    exec: (editor, current) => {
        const anchor = Dom_Dom.closest(current, 'A', editor.editor);
        if (anchor) {
            Dom_Dom.unwrap(anchor);
        }
        editor.events.fire('hidePopup');
    },
    tooltip: 'Unlink'
};
Config_Config.prototype.controls.link = {
    isActive: (editor) => {
        const current = editor.selection.current();
        return current && Dom_Dom.closest(current, 'a', editor.editor) !== false;
    },
    popup: (editor, current, self, close) => {
        const i18n = editor.i18n.bind(editor), { openInNewTabCheckbox, noFollowCheckbox } = editor.options.link, form = editor.create.fromHTML(`<form class="jodit_form">
						<div class="jodit_form_group">
							<input ref="url_input" class="jodit_input" required type="text" name="url" placeholder="http://" type="text"/>
						</div>
						<div ref="content_input_box" class="jodit_form_group">
							<input ref="content_input" class="jodit_input" name="text" placeholder="${i18n('Text')}" type="text"/>
						</div>
						<label ref="target_checkbox_box">
							<input ref="target_checkbox" class="jodit_checkbox" name="target" type="checkbox"/>
							<span>${i18n('Open in new tab')}</span>
						</label>
						<label ref="nofollow_checkbox_box">
							<input ref="nofollow_checkbox" class="jodit_checkbox" name="nofollow" type="checkbox"/>
							<span>${i18n('No follow')}</span>
						</label>
						<div class="jodit_buttons">
							<button ref="unlink" class="jodit_button jodit_unlink_button" type="button">${i18n('Unlink')}</button>
							<button ref="insert" class="jodit_button jodit_link_insert_button" type="submit">${i18n('Insert')}</button>
						</div>
					<form/>`, {
            target_checkbox_box: openInNewTabCheckbox,
            nofollow_checkbox_box: noFollowCheckbox
        });
        const elements = refs(form), { insert, unlink, content_input_box } = elements, { target_checkbox, nofollow_checkbox, url_input, content_input } = elements, currentElement = current, isImageContent = Dom_Dom.isImage(currentElement, editor.editorWindow);
        if (isImageContent) {
            Dom_Dom.hide(content_input_box);
        }
        if (!isImageContent && current) {
            content_input.value = current.textContent || '';
        }
        if (current && Dom_Dom.closest(current, 'A', editor.editor)) {
            current = Dom_Dom.closest(current, 'A', editor.editor);
        }
        else {
            current = false;
        }
        if (current) {
            url_input.value = current.getAttribute('href') || '';
            if (openInNewTabCheckbox) {
                target_checkbox.checked =
                    current.getAttribute('target') === '_blank';
            }
            if (noFollowCheckbox) {
                nofollow_checkbox.checked =
                    current.getAttribute('rel') === 'nofollow';
            }
            insert.textContent = i18n('Update');
        }
        else {
            Dom_Dom.hide(unlink);
        }
        const selInfo = editor.selection.save();
        if (unlink) {
            editor.events.on(unlink, 'click', (e) => {
                if (current) {
                    Dom_Dom.unwrap(current);
                }
                editor.selection.restore(selInfo);
                close();
                e.preventDefault();
            });
        }
        editor.events.on(form, 'submit', (event) => {
            event.preventDefault();
            const a = current ||
                editor.create.inside.element('a');
            if (!url_input.value.trim().length) {
                url_input.focus();
                url_input.classList.add('jodit_error');
                return false;
            }
            a.setAttribute('href', url_input.value);
            if (!isImageContent) {
                a.textContent = content_input.value;
            }
            if (openInNewTabCheckbox) {
                if (target_checkbox.checked) {
                    a.setAttribute('target', '_blank');
                }
                else {
                    a.removeAttribute('target');
                }
            }
            if (noFollowCheckbox) {
                if (nofollow_checkbox.checked) {
                    a.setAttribute('rel', 'nofollow');
                }
                else {
                    a.removeAttribute('rel');
                }
            }
            if (!current) {
                if (!isImageContent) {
                    editor.selection.restore(selInfo);
                    editor.selection.insertNode(a);
                }
                else {
                    currentElement && Dom_Dom.wrap(currentElement, a, editor);
                    editor.selection.restore(selInfo);
                }
            }
            close();
            return false;
        });
        return form;
    },
    tags: ['a'],
    tooltip: 'Insert link'
};
function link_link(jodit) {
    if (jodit.options.link.followOnDblClick) {
        jodit.events.on('afterInit changePlace', () => {
            jodit.events
                .off('dblclick.link')
                .on(jodit.editor, 'dblclick.link', function (e) {
                const href = this.getAttribute('href');
                if (href) {
                    location.href = href;
                    e.preventDefault();
                }
            }, 'a');
        });
    }
    if (jodit.options.link.processPastedLink) {
        jodit.events.on('processPaste.link', (event, html) => {
            if (isURL(html)) {
                if (jodit.options.link.processVideoLink) {
                    const embed = convertMediaURLToVideoEmbed(html);
                    if (embed !== html) {
                        return jodit.create.inside.fromHTML(embed);
                    }
                }
                const a = jodit.create.inside.element('a');
                a.setAttribute('href', html);
                a.textContent = html;
                return a;
            }
        });
    }
    if (jodit.options.link.removeLinkAfterFormat) {
        jodit.events.on('afterCommand.link', (command) => {
            const sel = jodit.selection;
            let newtag, node;
            if (command === 'removeFormat') {
                node = sel.current();
                if (node && node.nodeName !== 'A') {
                    node = Dom_Dom.closest(node, 'A', jodit.editor);
                }
                if (node && node.nodeName === 'A') {
                    if (node.innerHTML ===
                        node.textContent) {
                        newtag = jodit.editorDocument.createTextNode(node.innerHTML);
                    }
                    else {
                        newtag = jodit.create.inside.element('span');
                        newtag.innerHTML = node.innerHTML;
                    }
                    if (node.parentNode) {
                        node.parentNode.replaceChild(newtag, node);
                        jodit.selection.setCursorIn(newtag, true);
                    }
                }
            }
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/media.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.mediaFakeTag = 'jodit-media';
Config_Config.prototype.mediaInFakeBlock = true;
Config_Config.prototype.mediaBlocks = ['video', 'audio'];
function media(editor) {
    const keyFake = 'jodit_fake_wrapper';
    const { mediaFakeTag, mediaBlocks, mediaInFakeBlock } = editor.options;
    const wrap = (element) => {
        if (element.parentNode &&
            element.parentNode.getAttribute('data-jodit_iframe_wrapper')) {
            element = element.parentNode;
        }
        else {
            let wrapper;
            wrapper = editor.create.inside.fromHTML(`<${mediaFakeTag} data-jodit-temp="1" contenteditable="false" draggable="true" data-${keyFake}="1"></${mediaFakeTag}>`);
            wrapper.style.display =
                element.style.display === 'inline-block'
                    ? 'inline-block'
                    : 'block';
            wrapper.style.width = element.offsetWidth + 'px';
            wrapper.style.height = element.offsetHeight + 'px';
            if (element.parentNode) {
                element.parentNode.insertBefore(wrapper, element);
            }
            wrapper.appendChild(element);
            element = wrapper;
        }
        editor.events
            .off(element, 'mousedown.select touchstart.select')
            .on(element, 'mousedown.select touchstart.select', () => {
            editor.selection.setCursorAfter(element);
        });
    };
    if (mediaInFakeBlock) {
        editor.events
            .on('afterGetValueFromEditor', (data) => {
            const rxp = new RegExp(`<${mediaFakeTag}[^>]+data-${keyFake}[^>]+>(.+?)</${mediaFakeTag}>`, 'ig');
            if (rxp.test(data.value)) {
                data.value = data.value.replace(rxp, '$1');
            }
        })
            .on('change afterInit afterSetMode changePlace', debounce(() => {
            if (!editor.isDestructed &&
                editor.getMode() !== MODE_SOURCE) {
                $$(mediaBlocks.join(','), editor.editor).forEach((elm) => {
                    if (!elm['__' + keyFake]) {
                        elm['__' + keyFake] = true;
                        wrap(elm);
                    }
                });
            }
        }, editor.defaultTimeout));
    }
}

// CONCATENATED MODULE: ./src/plugins/mobile.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.mobileTapTimeout = 300;
Config_Config.prototype.toolbarAdaptive = true;
Config_Config.prototype.controls.dots = {
    mode: MODE_SOURCE + MODE_WYSIWYG,
    popup: (editor, current, control, close, button) => {
        let store = control.data;
        if (store === undefined) {
            store = {
                container: editor.create.div(),
                toolbar: joditToolbarCollection_JoditToolbarCollection.makeCollection(editor),
                rebuild: () => {
                    if (button) {
                        const buttons = editor.events.fire('getDiffButtons.mobile', button.parentToolbar);
                        if (buttons && store) {
                            store.toolbar.build(splitArray(buttons), store.container);
                        }
                    }
                }
            };
            let w = 32;
            const size = editor.options.toolbarButtonSize;
            if (size === 'large') {
                w = 36;
            }
            else if (size === 'small') {
                w = 24;
            }
            store.container.style.width = w * 3 + 'px';
            control.data = store;
        }
        store.rebuild();
        return store.container;
    }
};
function mobile(editor) {
    let timeout = 0, now, store = splitArray(editor.options.buttons);
    editor.events
        .on('touchend', (e) => {
        if (e.changedTouches && e.changedTouches.length) {
            now = new Date().getTime();
            if (now - timeout > editor.options.mobileTapTimeout) {
                timeout = now;
                editor.selection.insertCursorAtPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }
        }
    })
        .on('getDiffButtons.mobile', (toolbar) => {
        if (toolbar === editor.toolbar) {
            return splitArray(editor.options.buttons).filter((i) => {
                return store.indexOf(i) < 0;
            });
        }
    });
    if (editor.options.toolbarAdaptive) {
        editor.events
            .on('resize afterInit recalcAdaptive changePlace afterAddPlace', () => {
            if (!editor.options.toolbar) {
                return;
            }
            const width = editor.container.offsetWidth;
            let newStore = [];
            if (width >= editor.options.sizeLG) {
                newStore = splitArray(editor.options.buttons);
            }
            else if (width >= editor.options.sizeMD) {
                newStore = splitArray(editor.options.buttonsMD);
            }
            else if (width >= editor.options.sizeSM) {
                newStore = splitArray(editor.options.buttonsSM);
            }
            else {
                newStore = splitArray(editor.options.buttonsXS);
            }
            if (newStore.toString() !== store.toString()) {
                store = newStore;
                editor.toolbar.build(store.concat(editor.options.extraButtons), editor.toolbar.container.parentElement ||
                    editor.toolbar.getParentContainer());
            }
        })
            .on(editor.ownerWindow, 'load', () => editor.events.fire('recalcAdaptive'));
    }
}

// CONCATENATED MODULE: ./src/plugins/orderedlist.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


Config_Config.prototype.controls.ul = {
    command: 'insertUnorderedList',
    controlName: 'ul',
    tags: ['ul'],
    tooltip: 'Insert Unordered List'
};
Config_Config.prototype.controls.ol = {
    command: 'insertOrderedList',
    controlName: 'ol',
    tags: ['ol'],
    tooltip: 'Insert Ordered List'
};
function orderedlist(editor) {
    editor.events.on('afterCommand', (command) => {
        if (/insert(un)?orderedlist/i.test(command)) {
            const ul = Dom_Dom.up(editor.selection.current(), (tag) => tag && /^UL|OL$/i.test(tag.nodeName), editor.editor);
            if (ul && ul.parentNode && ul.parentNode.nodeName === 'P') {
                const selection = editor.selection.save();
                Dom_Dom.unwrap(ul.parentNode);
                Array.from(ul.childNodes).forEach((li) => {
                    if (li.lastChild &&
                        li.lastChild.nodeType === Node.ELEMENT_NODE &&
                        li.lastChild.nodeName === 'BR') {
                        Dom_Dom.safeRemove(li.lastChild);
                    }
                });
                editor.selection.restore(selection);
            }
            editor.setEditorValue();
        }
    });
}

// CONCATENATED MODULE: ./src/plugins/placeholder.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





Config_Config.prototype.showPlaceholder = true;
Config_Config.prototype.useInputsPlaceholder = true;
Config_Config.prototype.placeholder = 'Type something';
function placeholder_placeholder(editor) {
    if (!editor.options.showPlaceholder) {
        return;
    }
    const show = () => {
        if (editor.options.readonly) {
            return;
        }
        let marginTop = 0, marginLeft = 0;
        const style = editor.editorWindow.getComputedStyle(editor.editor);
        editor.workplace.appendChild(placeholderElm);
        if (editor.editor.firstChild &&
            editor.editor.firstChild.nodeType === Node.ELEMENT_NODE) {
            const style2 = editor.editorWindow.getComputedStyle(editor.editor.firstChild);
            marginTop = parseInt(style2.getPropertyValue('margin-top'), 10);
            marginLeft = parseInt(style2.getPropertyValue('margin-left'), 10);
            placeholderElm.style.fontSize =
                parseInt(style2.getPropertyValue('font-size'), 10) + 'px';
            placeholderElm.style.lineHeight = style2.getPropertyValue('line-height');
        }
        else {
            placeholderElm.style.fontSize =
                parseInt(style.getPropertyValue('font-size'), 10) + 'px';
            placeholderElm.style.lineHeight = style.getPropertyValue('line-height');
        }
        css_css(placeholderElm, {
            display: 'block',
            marginTop: Math.max(parseInt(style.getPropertyValue('margin-top'), 10), marginTop),
            marginLeft: Math.max(parseInt(style.getPropertyValue('margin-left'), 10), marginLeft)
        });
    }, hide = () => {
        Dom_Dom.safeRemove(placeholderElm);
    }, toggle = debounce(() => {
        if (!editor.editor || editor.isInDestruct) {
            return;
        }
        if (editor.getRealMode() !== MODE_WYSIWYG) {
            hide();
            return;
        }
        const value = editor.value;
        if (value.trim().length &&
            !/^<(p|div|h[1-6])><\/\1>$/.test(value)) {
            hide();
        }
        else {
            show();
        }
    }, editor.defaultTimeout / 10);
    const placeholderElm = editor.create.fromHTML('<span style="display: none;" class="jodit_placeholder">' +
        editor.i18n(editor.options.placeholder) +
        '</span>');
    if (editor.options.direction === 'rtl') {
        placeholderElm.style.right = '0px';
        placeholderElm.style.direction = 'rtl';
    }
    editor.events
        .on('readonly', (isReadOnly) => {
        if (isReadOnly) {
            hide();
        }
        else {
            toggle();
        }
    })
        .on('beforeDestruct', () => {
        Dom_Dom.safeRemove(placeholderElm);
        editor.events.off('.placeholder').off(window, 'load', toggle);
    })
        .on('afterInit changePlace', () => {
        if (editor.options.useInputsPlaceholder &&
            editor.element.hasAttribute('placeholder')) {
            placeholderElm.innerHTML =
                editor.element.getAttribute('placeholder') || '';
        }
        toggle();
        editor.events.fire('placeholder', placeholderElm.innerHTML);
        editor.events
            .off('.placeholder')
            .on('change.placeholder keyup.placeholder mouseup.placeholder keydown.placeholder ' +
            'mousedown.placeholder afterSetMode.placeholder', toggle)
            .on(window, 'load', toggle);
    });
}

// CONCATENATED MODULE: ./src/plugins/redoundo.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.controls.redo = {
    mode: MODE_SPLIT,
    isDisable: (editor) => !editor.observer.stack.canRedo(),
    tooltip: 'Redo'
};
Config_Config.prototype.controls.undo = {
    mode: MODE_SPLIT,
    isDisable: (editor) => !editor.observer.stack.canUndo(),
    tooltip: 'Undo'
};
class redoundo_redoundo extends Plugin_Plugin {
    beforeDestruct() {
    }
    afterInit(editor) {
        const callback = (command) => {
            if (editor.getRealMode() === MODE_WYSIWYG) {
                editor.observer[command]();
            }
            return false;
        };
        editor.registerCommand('redo', {
            exec: callback,
            hotkeys: ['ctrl+y', 'ctrl+shift+z', 'cmd+y', 'cmd+shift+z']
        });
        editor.registerCommand('undo', {
            exec: callback,
            hotkeys: ['ctrl+z', 'cmd+z']
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/resizer.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */








Config_Config.prototype.useIframeResizer = true;
Config_Config.prototype.useTableResizer = true;
Config_Config.prototype.useImageResizer = true;
Config_Config.prototype.resizer = {
    showSize: true,
    hideSizeTimeout: 1000,
    min_width: 10,
    min_height: 10
};
function resizer(editor) {
    const LOCK_KEY = 'resizer';
    let handle, currentElement, resizeElementClicked = false, isResizing = false, start_x, start_y, width, height, ratio, new_h, new_w, diff_x, diff_y, resizerIsVisible = false;
    const resizerElm = editor.create.fromHTML(`<div style="display:none" class="jodit_resizer">
				<i class="jodit_resizer-topleft"></i>
				<i class="jodit_resizer-topright"></i>
				<i class="jodit_resizer-bottomright"></i>
				<i class="jodit_resizer-bottomleft"></i>
				<span>100x100</span>
			</div>`), sizeViewer = resizerElm.getElementsByTagName('span')[0], hideResizer = () => {
        isResizing = false;
        resizerIsVisible = false;
        currentElement = null;
        resizerElm.style.display = 'none';
    }, hideSizeViewer = () => {
        sizeViewer.style.opacity = '0';
    }, showSizeViewer = (w, h) => {
        if (!editor.options.resizer.showSize) {
            return;
        }
        if (w < sizeViewer.offsetWidth || h < sizeViewer.offsetHeight) {
            hideSizeViewer();
            return;
        }
        sizeViewer.style.opacity = '1';
        sizeViewer.innerHTML = `${w} x ${h}`;
        editor.async.setTimeout(hideSizeViewer, {
            timeout: editor.options.resizer.hideSizeTimeout,
            label: 'hideSizeViewer'
        });
    }, updateSize = () => {
        if (editor.isInDestruct) {
            return;
        }
        if (resizerIsVisible && currentElement && resizerElm) {
            const workplacePosition = offset((resizerElm.parentNode ||
                editor.ownerDocument
                    .documentElement), editor, editor.ownerDocument, true), pos = offset(currentElement, editor, editor.editorDocument), left = parseInt(resizerElm.style.left || '0', 10), top = parseInt(resizerElm.style.top || '0', 10), w = resizerElm.offsetWidth, h = resizerElm.offsetHeight;
            const newTop = pos.top - 1 - workplacePosition.top, newLeft = pos.left - 1 - workplacePosition.left;
            if (top !== newTop ||
                left !== newLeft ||
                w !== currentElement.offsetWidth ||
                h !== currentElement.offsetHeight) {
                resizerElm.style.top = newTop + 'px';
                resizerElm.style.left = newLeft + 'px';
                resizerElm.style.width = currentElement.offsetWidth + 'px';
                resizerElm.style.height =
                    currentElement.offsetHeight + 'px';
                if (editor.events) {
                    editor.events.fire(currentElement, 'changesize');
                    if (!isNaN(left)) {
                        editor.events.fire('resize');
                    }
                }
            }
        }
    }, showResizer = () => {
        if (editor.options.readonly) {
            return;
        }
        if (!resizerElm.parentNode) {
            editor.markOwner(resizerElm);
            editor.workplace.appendChild(resizerElm);
        }
        resizerIsVisible = true;
        resizerElm.style.display = 'block';
        if (editor.isFullSize()) {
            resizerElm.style.zIndex = css_css(editor.container, 'zIndex').toString();
        }
        updateSize();
    }, bind = (element) => {
        let wrapper;
        if (element.tagName === 'IFRAME') {
            const iframe = element;
            if (element.parentNode &&
                element.parentNode.getAttribute('data-jodit_iframe_wrapper')) {
                element = element.parentNode;
            }
            else {
                wrapper = editor.create.inside.fromHTML('<jodit ' +
                    'data-jodit-temp="1" ' +
                    'contenteditable="false" ' +
                    'draggable="true" ' +
                    'data-jodit_iframe_wrapper="1"' +
                    '></jodit>');
                wrapper.style.display =
                    element.style.display === 'inline-block'
                        ? 'inline-block'
                        : 'block';
                wrapper.style.width = element.offsetWidth + 'px';
                wrapper.style.height = element.offsetHeight + 'px';
                if (element.parentNode) {
                    element.parentNode.insertBefore(wrapper, element);
                }
                wrapper.appendChild(element);
                element = wrapper;
            }
            editor.events
                .off(element, 'mousedown.select touchstart.select')
                .on(element, 'mousedown.select touchstart.select', () => {
                editor.selection.select(element);
            });
            editor.events
                .off(element, 'changesize')
                .on(element, 'changesize', () => {
                iframe.setAttribute('width', element.offsetWidth + 'px');
                iframe.setAttribute('height', element.offsetHeight + 'px');
            });
        }
        let timer;
        editor.events
            .on(element, 'dragstart', hideResizer)
            .on(element, 'mousedown', (event) => {
            if (IS_IE && element.nodeName === 'IMG') {
                event.preventDefault();
            }
        })
            .on(element, 'mousedown touchstart', () => {
            if (!resizeElementClicked) {
                resizeElementClicked = true;
                currentElement = element;
                showResizer();
                if (currentElement.tagName === 'IMG' &&
                    !currentElement.complete) {
                    currentElement.addEventListener('load', function ElementOnLoad() {
                        updateSize();
                        if (currentElement) {
                            currentElement.removeEventListener('load', ElementOnLoad);
                        }
                    });
                }
                editor.async.clearTimeout(timer);
            }
            timer = editor.async.setTimeout(() => {
                resizeElementClicked = false;
            }, 400);
        });
    };
    $$('i', resizerElm).forEach((resizeHandle) => {
        editor.events.on(resizeHandle, 'mousedown touchstart', (e) => {
            if (!currentElement || !currentElement.parentNode) {
                hideResizer();
                return false;
            }
            handle = resizeHandle;
            e.preventDefault();
            e.stopImmediatePropagation();
            width = currentElement.offsetWidth;
            height = currentElement.offsetHeight;
            ratio = width / height;
            isResizing = true;
            start_x = e.clientX;
            start_y = e.clientY;
            editor.events.fire('hidePopup');
            editor.lock(LOCK_KEY);
        });
    });
    editor.events
        .on('readonly', (isReadOnly) => {
        if (isReadOnly) {
            hideResizer();
        }
    })
        .on('beforeDestruct', () => {
        Dom_Dom.safeRemove(resizerElm);
    })
        .on('afterInit changePlace', () => {
        editor.events
            .off(editor.editor, '.resizer')
            .off(editor.ownerWindow, '.resizer')
            .on(editor.editor, 'keydown.resizer', (e) => {
            if (resizerIsVisible &&
                e.which === KEY_DELETE &&
                currentElement &&
                currentElement.tagName.toLowerCase() !== 'table') {
                if (currentElement.tagName !== 'JODIT') {
                    editor.selection.select(currentElement);
                }
                else {
                    Dom_Dom.safeRemove(currentElement);
                    hideResizer();
                    e.preventDefault();
                }
            }
        })
            .on(editor.ownerWindow, 'mousemove.resizer touchmove.resizer', (e) => {
            if (isResizing) {
                diff_x = e.clientX - start_x;
                diff_y = e.clientY - start_y;
                if (!currentElement) {
                    return;
                }
                const className = handle.className;
                if ('IMG' === currentElement.tagName) {
                    if (diff_x) {
                        new_w =
                            width +
                                (className.match(/left/) ? -1 : 1) *
                                    diff_x;
                        new_h = Math.round(new_w / ratio);
                    }
                    else {
                        new_h =
                            height +
                                (className.match(/top/) ? -1 : 1) *
                                    diff_y;
                        new_w = Math.round(new_h * ratio);
                    }
                    if (new_w >
                        innerWidth_innerWidth(editor.editor, editor.ownerWindow)) {
                        new_w = innerWidth_innerWidth(editor.editor, editor.ownerWindow);
                        new_h = Math.round(new_w / ratio);
                    }
                }
                else {
                    new_w =
                        width +
                            (className.match(/left/) ? -1 : 1) * diff_x;
                    new_h =
                        height +
                            (className.match(/top/) ? -1 : 1) * diff_y;
                }
                if (new_w > editor.options.resizer.min_width) {
                    if (new_w <
                        resizerElm.parentNode
                            .offsetWidth) {
                        currentElement.style.width = new_w + 'px';
                    }
                    else {
                        currentElement.style.width = '100%';
                    }
                }
                if (new_h > editor.options.resizer.min_height) {
                    currentElement.style.height = new_h + 'px';
                }
                updateSize();
                showSizeViewer(currentElement.offsetWidth, currentElement.offsetHeight);
                e.stopImmediatePropagation();
            }
        })
            .on(editor.ownerWindow, 'resize.resizer', () => {
            if (resizerIsVisible) {
                updateSize();
            }
        })
            .on(editor.ownerWindow, 'mouseup.resizer keydown.resizer touchend.resizer', (e) => {
            if (resizerIsVisible && !resizeElementClicked) {
                if (isResizing) {
                    editor.unlock();
                    isResizing = false;
                    editor.setEditorValue();
                    e.stopImmediatePropagation();
                }
                else {
                    hideResizer();
                }
            }
        })
            .on([editor.ownerWindow, editor.editor], 'scroll.resizer', () => {
            if (resizerIsVisible && !isResizing) {
                hideResizer();
            }
        });
    })
        .on('afterGetValueFromEditor.resizer', (data) => {
        const rgx = /<jodit[^>]+data-jodit_iframe_wrapper[^>]+>(.*?<iframe[^>]+>[\s\n\r]*<\/iframe>.*?)<\/jodit>/gi;
        if (rgx.test(data.value)) {
            data.value = data.value.replace(rgx, '$1');
        }
    })
        .on('hideResizer', hideResizer)
        .on('change afterInit afterSetMode', debounce(() => {
        if (resizerIsVisible) {
            if (!currentElement || !currentElement.parentNode) {
                hideResizer();
            }
            else {
                updateSize();
            }
        }
        if (!editor.isDestructed) {
            $$('img, table, iframe', editor.editor).forEach((elm) => {
                if (editor.getMode() === MODE_SOURCE) {
                    return;
                }
                if (!elm.__jodit_resizer_binded &&
                    ((elm.tagName === 'IFRAME' &&
                        editor.options.useIframeResizer) ||
                        (elm.tagName === 'IMG' &&
                            editor.options.useImageResizer) ||
                        (elm.tagName === 'TABLE' &&
                            editor.options.useTableResizer))) {
                    elm.__jodit_resizer_binded = true;
                    bind(elm);
                }
            });
        }
    }, editor.defaultTimeout));
}

// CONCATENATED MODULE: ./src/plugins/search.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */








Config_Config.prototype.useSearch = true;
class search_search extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.template = `<div class="jodit_search">
			<div class="jodit_search_box">
				<div class="jodit_search_inputs">
					<input tabindex="0" class="jodit_search-query" placeholder="${this.jodit.i18n('Search for')}" type="text"/>
					<input tabindex="0" class="jodit_search-replace" placeholder="${this.jodit.i18n('Replace with')}" type="text"/>
				</div>
				<div class="jodit_search_counts">
					<span>0/0</span>
				</div>
				<div class="jodit_search_buttons">
					<button tabindex="0" type="button" class="jodit_search_buttons-next">${ToolbarIcon.getIcon('angle-down')}</button>
					<button tabindex="0" type="button" class="jodit_search_buttons-prev">${ToolbarIcon.getIcon('angle-up')}</button>
					<button tabindex="0" type="button" class="jodit_search_buttons-cancel">${ToolbarIcon.getIcon('cancel')}</button>
					<button tabindex="0" type="button" class="jodit_search_buttons-replace">${this.jodit.i18n('Replace')}</button>
				</div>
			</div>
		</div>`;
        this.isOpened = false;
        this.selInfo = null;
        this.current = false;
        this.eachMap = (node, callback, next) => {
            Dom_Dom.findWithCurrent(node, (child) => {
                return !!child && callback(child);
            }, this.jodit.editor, next ? 'nextSibling' : 'previousSibling', next ? 'firstChild' : 'lastChild');
        };
        this.updateCounters = () => {
            if (!this.isOpened) {
                return;
            }
            this.counterBox.style.display = this.queryInput.value.length
                ? 'inline-block'
                : 'none';
            const range = this.jodit.selection.range, counts = this.calcCounts(this.queryInput.value, range);
            this.counterBox.textContent = counts.join('/');
        };
        this.calcCounts = (query, current = false) => {
            const bounds = [];
            let currentIndex = 0, count = 0, bound = false, start = this.jodit.editor.firstChild;
            while (start && query.length) {
                bound = this.find(start, query, true, 0, bound || this.jodit.editorDocument.createRange());
                if (bound) {
                    if (this.boundAlreadyWas(bound, bounds)) {
                        break;
                    }
                    bounds.push(bound);
                    start = bound.startContainer;
                    count += 1;
                    if (current && this.boundAlreadyWas(current, [bound])) {
                        currentIndex = count;
                    }
                }
                else {
                    start = null;
                }
            }
            return [currentIndex, count];
        };
        this.findAndReplace = (start, query) => {
            const range = this.jodit.selection.range, bound = this.find(start, query, true, 0, range);
            if (bound && bound.startContainer && bound.endContainer) {
                const rng = this.jodit.editorDocument.createRange();
                try {
                    if (bound && bound.startContainer && bound.endContainer) {
                        rng.setStart(bound.startContainer, bound.startOffset);
                        rng.setEnd(bound.endContainer, bound.endOffset);
                        rng.deleteContents();
                        const textNode = this.jodit.editorDocument.createTextNode(this.replaceInput.value);
                        rng.insertNode(textNode);
                        this.jodit.selection.select(textNode);
                        this.tryScrollToElement(textNode);
                    }
                }
                catch (_a) { }
                return true;
            }
            return false;
        };
        this.findAndSelect = (start, query, next) => {
            const range = this.jodit.selection.range, bound = this.find(start, query, next, 0, range);
            if (bound && bound.startContainer && bound.endContainer) {
                const rng = this.jodit.editorDocument.createRange();
                try {
                    rng.setStart(bound.startContainer, bound.startOffset);
                    rng.setEnd(bound.endContainer, bound.endOffset);
                    this.jodit.selection.selectRange(rng);
                }
                catch (e) { }
                this.tryScrollToElement(bound.startContainer);
                this.current = bound.startContainer;
                this.updateCounters();
                return true;
            }
            return false;
        };
        this.find = (start, query, next, deep, range) => {
            if (start && query.length) {
                let sentence = '', bound = {
                    startContainer: null,
                    startOffset: null,
                    endContainer: null,
                    endOffset: null
                };
                this.eachMap(start, (elm) => {
                    if (elm.nodeType === Node.TEXT_NODE &&
                        elm.nodeValue !== null &&
                        elm.nodeValue.length) {
                        let value = elm.nodeValue;
                        if (!next && elm === range.startContainer) {
                            value = !deep
                                ? value.substr(0, range.startOffset)
                                : value.substr(range.endOffset);
                        }
                        else if (next && elm === range.endContainer) {
                            value = !deep
                                ? value.substr(range.endOffset)
                                : value.substr(0, range.startOffset);
                        }
                        const tmpSentence = next
                            ? sentence + value
                            : value + sentence;
                        const part = search_search.findSomePartOfString(query, tmpSentence, next);
                        if (part !== false) {
                            let currentPart = search_search.findSomePartOfString(query, value, next);
                            if (currentPart === true) {
                                currentPart = trim(query);
                            }
                            else if (currentPart === false) {
                                currentPart = search_search.findSomePartOfString(value, query, next);
                                if (currentPart === true) {
                                    currentPart = trim(value);
                                }
                            }
                            let currentPartIndex = search_search.getSomePartOfStringIndex(query, value, next) || 0;
                            if (((next && !deep) || (!next && deep)) &&
                                elm.nodeValue.length - value.length > 0) {
                                currentPartIndex +=
                                    elm.nodeValue.length - value.length;
                            }
                            if (bound.startContainer === null) {
                                bound.startContainer = elm;
                                bound.startOffset = currentPartIndex;
                            }
                            if (part !== true) {
                                sentence = tmpSentence;
                            }
                            else {
                                bound.endContainer = elm;
                                bound.endOffset = currentPartIndex;
                                bound.endOffset += currentPart.length;
                                return true;
                            }
                        }
                        else {
                            sentence = '';
                            bound = {
                                startContainer: null,
                                startOffset: null,
                                endContainer: null,
                                endOffset: null
                            };
                        }
                    }
                    else if (Dom_Dom.isBlock(elm, this.jodit.editorWindow) &&
                        sentence !== '') {
                        sentence = next ? sentence + ' ' : ' ' + sentence;
                    }
                    return false;
                }, next);
                if (bound.startContainer && bound.endContainer) {
                    return bound;
                }
                if (!deep) {
                    this.current = next
                        ? this.jodit.editor.firstChild
                        : this.jodit.editor.lastChild;
                    return this.find(this.current, query, next, deep + 1, range);
                }
            }
            return false;
        };
        this.open = (searchAndReplace = false) => {
            if (!this.isOpened) {
                this.searchBox.classList.add('jodit_search-active');
                this.isOpened = true;
            }
            this.jodit.events.fire('hidePopup');
            this.searchBox.classList.toggle('jodit_search-and-replace', searchAndReplace);
            this.current = this.jodit.selection.current();
            this.selInfo = this.jodit.selection.save();
            const selStr = (this.jodit.selection.sel || '').toString();
            if (selStr) {
                this.queryInput.value = selStr;
            }
            this.updateCounters();
            if (selStr) {
                this.queryInput.select();
            }
            else {
                this.queryInput.focus();
            }
        };
        this.close = () => {
            if (!this.isOpened) {
                return;
            }
            if (this.selInfo) {
                this.jodit.selection.restore(this.selInfo);
                this.selInfo = null;
            }
            this.searchBox.classList.remove('jodit_search-active');
            this.isOpened = false;
        };
    }
    static getSomePartOfStringIndex(needle, haystack, start = true) {
        return this.findSomePartOfString(needle, haystack, start, true);
    }
    static findSomePartOfString(needle, haystack, start = true, getIndex = false) {
        needle = trim(needle.toLowerCase().replace(SPACE_REG_EXP, ' '));
        haystack = haystack.toLowerCase();
        let i = start ? 0 : haystack.length - 1, needleStart = start ? 0 : needle.length - 1, tmpEqualLength = 0, startAtIndex = null;
        const inc = start ? 1 : -1, tmp = [];
        for (; haystack[i] !== undefined; i += inc) {
            const some = needle[needleStart] === haystack[i];
            if (some ||
                (startAtIndex !== null &&
                    SPACE_REG_EXP.test(haystack[i]))) {
                if (startAtIndex === null || !start) {
                    startAtIndex = i;
                }
                tmp.push(haystack[i]);
                if (some) {
                    tmpEqualLength += 1;
                    needleStart += inc;
                }
            }
            else {
                startAtIndex = null;
                tmp.length = 0;
                tmpEqualLength = 0;
                needleStart = start ? 0 : needle.length - 1;
            }
            if (tmpEqualLength === needle.length) {
                return getIndex ? startAtIndex : true;
            }
        }
        if (getIndex) {
            return (startAtIndex !== null && startAtIndex !== void 0 ? startAtIndex : false);
        }
        if (tmp.length) {
            return start ? tmp.join('') : tmp.reverse().join('');
        }
        return false;
    }
    boundAlreadyWas(current, bounds) {
        return bounds.some((bound) => {
            return (bound.startContainer === current.startContainer &&
                bound.endContainer === current.endContainer &&
                bound.startOffset === current.startOffset &&
                bound.endOffset === current.endOffset);
        }, false);
    }
    tryScrollToElement(startContainer) {
        let parentBox = Dom_Dom.closest(startContainer, elm => elm && elm.nodeType === Node.ELEMENT_NODE, this.jodit.editor);
        if (!parentBox) {
            parentBox = Dom_Dom.prev(startContainer, (elm) => elm && elm.nodeType === Node.ELEMENT_NODE, this.jodit.editor);
        }
        parentBox &&
            parentBox !== this.jodit.editor &&
            parentBox.scrollIntoView();
    }
    afterInit(editor) {
        if (editor.options.useSearch) {
            const self = this;
            self.searchBox = editor.create.fromHTML(self.template);
            const qs = self.searchBox.querySelector.bind(self.searchBox);
            self.queryInput = qs('input.jodit_search-query');
            self.replaceInput = qs('input.jodit_search-replace');
            self.closeButton = qs('.jodit_search_buttons-cancel');
            self.nextButton = qs('.jodit_search_buttons-next');
            self.prevButton = qs('.jodit_search_buttons-prev');
            self.replaceButton = qs('.jodit_search_buttons-replace');
            self.counterBox = qs('.jodit_search_counts span');
            const onInit = () => {
                editor.workplace.appendChild(this.searchBox);
                editor.events
                    .off(this.jodit.container, 'keydown.search')
                    .on(this.jodit.container, 'keydown.search', (e) => {
                    if (editor.getRealMode() !== MODE_WYSIWYG) {
                        return;
                    }
                    switch (e.which) {
                        case KEY_ESC:
                            this.close();
                            break;
                        case KEY_F3:
                            if (self.queryInput.value) {
                                editor.events.fire(!e.shiftKey
                                    ? 'searchNext'
                                    : 'searchPrevious');
                                e.preventDefault();
                            }
                            break;
                    }
                });
            };
            onInit();
            editor.events
                .on('changePlace', onInit)
                .on(self.closeButton, 'click', this.close)
                .on(self.queryInput, 'mousedown', () => {
                if (editor.selection.isFocused()) {
                    editor.selection.removeMarkers();
                    self.selInfo = editor.selection.save();
                }
            })
                .on(self.replaceButton, 'click', (e) => {
                self.findAndReplace(editor.selection.current() || editor.editor.firstChild, self.queryInput.value);
                this.updateCounters();
                e.preventDefault();
                e.stopImmediatePropagation();
            })
                .on([self.nextButton, self.prevButton], 'click', function (e) {
                editor.events.fire(self.nextButton === this
                    ? 'searchNext'
                    : 'searchPrevious');
                e.preventDefault();
                e.stopImmediatePropagation();
            })
                .on(this.queryInput, 'keydown', debounce((e) => {
                switch (e.which) {
                    case KEY_ENTER:
                        e.preventDefault();
                        e.stopImmediatePropagation();
                        if (editor.events.fire('searchNext')) {
                            this.close();
                        }
                        break;
                    default:
                        this.updateCounters();
                        break;
                }
            }, this.jodit.defaultTimeout))
                .on('beforeSetMode.search', () => {
                this.close();
            })
                .on('keydown.search mousedown.search', () => {
                if (this.selInfo) {
                    editor.selection.removeMarkers();
                    this.selInfo = null;
                }
                if (this.isOpened) {
                    this.current = this.jodit.selection.current();
                    this.updateCounters();
                }
            })
                .on('searchNext.search searchPrevious.search', () => {
                return self.findAndSelect(editor.selection.current() || editor.editor.firstChild, self.queryInput.value, editor.events.current[editor.events.current.length - 1] === 'searchNext');
            })
                .on('search.search', (value, next = true) => {
                editor.execCommand('search', value, next);
            });
            editor.registerCommand('search', {
                exec: (command, value, next = true) => {
                    self.findAndSelect(editor.selection.current() || editor.editor.firstChild, value || '', next);
                    return false;
                }
            });
            editor.registerCommand('openSearchDialog', {
                exec: () => {
                    self.open();
                    return false;
                },
                hotkeys: ['ctrl+f', 'cmd+f']
            });
            editor.registerCommand('openReplaceDialog', {
                exec: () => {
                    if (!editor.options.readonly) {
                        self.open(true);
                    }
                    return false;
                },
                hotkeys: ['ctrl+h', 'cmd+h']
            });
        }
    }
    beforeDestruct(jodit) {
        var _a;
        Dom_Dom.safeRemove(this.searchBox);
        (_a = jodit.events) === null || _a === void 0 ? void 0 : _a.off('.search');
    }
}

// CONCATENATED MODULE: ./src/plugins/size.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.allowResizeX = false;
Config_Config.prototype.allowResizeY = true;
function size_size(editor) {
    const setHeight = (height) => {
        css_css(editor.container, 'height', height);
        if (editor.options.saveHeightInStorage) {
            editor.storage.set('height', height);
        }
    };
    const setWidth = (width) => css_css(editor.container, 'width', width);
    const setHeightWorkPlace = (height) => css_css(editor.workplace, 'height', height);
    if (editor.options.height !== 'auto' &&
        (editor.options.allowResizeX || editor.options.allowResizeY)) {
        const handle = editor.create.div('jodit_editor_resize', '<a tabindex="-1" href="javascript:void(0)"></a>'), start = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        };
        let isResized = false;
        editor.events
            .on(handle, 'mousedown touchstart', (e) => {
            isResized = true;
            start.x = e.clientX;
            start.y = e.clientY;
            start.w = editor.container.offsetWidth;
            start.h = editor.container.offsetHeight;
            editor.lock();
            e.preventDefault();
        })
            .on(editor.ownerWindow, 'mousemove touchmove', throttle((e) => {
            if (isResized) {
                if (editor.options.allowResizeY) {
                    setHeight(start.h + e.clientY - start.y);
                }
                if (editor.options.allowResizeX) {
                    setWidth(start.w + e.clientX - start.x);
                }
                resizeWorkspaceImd();
                editor.events.fire('resize');
            }
        }, editor.defaultTimeout / 10))
            .on(editor.ownerWindow, 'mouseup touchsend', () => {
            if (isResized) {
                isResized = false;
                editor.unlock();
            }
        })
            .on('afterInit', () => {
            editor.container.appendChild(handle);
        })
            .on('toggleFullSize', (fullsize) => {
            handle.style.display = fullsize ? 'none' : 'block';
        });
    }
    const getNotWorkHeight = () => (editor.options.toolbar ? editor.toolbar.container.offsetHeight : 0) +
        (editor.statusbar ? editor.statusbar.getHeight() : 0);
    const calcMinHeightWorkspace = () => {
        if (!editor.container || !editor.container.parentNode) {
            return;
        }
        const minHeight = css_css(editor.container, 'minHeight') - getNotWorkHeight();
        [editor.workplace, editor.iframe, editor.editor].map(elm => {
            const minHeightD = elm === editor.editor ? minHeight - 2 : minHeight;
            elm && css_css(elm, 'minHeight', minHeightD);
            editor.events.fire('setMinHeight', minHeightD);
        });
    };
    const resizeWorkspaceImd = () => {
        if (!editor ||
            editor.isDestructed ||
            !editor.options ||
            editor.options.inline) {
            return;
        }
        calcMinHeightWorkspace();
        if (editor.container &&
            (editor.options.height !== 'auto' || editor.isFullSize())) {
            setHeightWorkPlace(editor.container.offsetHeight - getNotWorkHeight());
        }
    };
    const resizeWorkspace = debounce(resizeWorkspaceImd, editor.defaultTimeout);
    editor.events
        .on('toggleFullSize', (fullsize) => {
        if (!fullsize && editor.options.height === 'auto') {
            setHeightWorkPlace('auto');
            calcMinHeightWorkspace();
        }
    })
        .on('afterInit changePlace', () => {
        if (!editor.options.inline) {
            css_css(editor.editor, {
                minHeight: '100%'
            });
            css_css(editor.container, {
                minHeight: editor.options.minHeight,
                minWidth: editor.options.minWidth,
                maxWidth: editor.options.maxWidth
            });
        }
        let height = editor.options.height;
        if (editor.options.saveHeightInStorage && height !== 'auto') {
            const localHeight = editor.storage.get('height');
            if (localHeight) {
                height = localHeight;
            }
        }
        if (!editor.options.inline) {
            setHeight(height);
            setWidth(editor.options.width);
        }
        resizeWorkspaceImd();
    }, undefined, undefined, true)
        .on(window, 'load', resizeWorkspace)
        .on('afterInit resize updateToolbar scroll afterResize', resizeWorkspace);
}

// CONCATENATED MODULE: ./src/plugins/source/config.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


Config_Config.prototype.beautifyHTML = true;
Config_Config.prototype.useAceEditor = true;
Config_Config.prototype.sourceEditor = 'ace';
Config_Config.prototype.sourceEditorNativeOptions = {
    showGutter: true,
    theme: 'ace/theme/idle_fingers',
    mode: 'ace/mode/html',
    wrap: true,
    highlightActiveLine: true
};
Config_Config.prototype.sourceEditorCDNUrlsJS = [
    'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.7/ace.js'
];
Config_Config.prototype.beautifyHTMLCDNUrlsJS = [
    'https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.10.2/beautify.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/js-beautify/1.10.2/beautify-html.min.js',
];
Config_Config.prototype.controls.source = {
    mode: MODE_SPLIT,
    exec: (editor) => {
        editor.toggleMode();
    },
    isActive: (editor) => {
        return editor.getRealMode() === MODE_SOURCE;
    },
    tooltip: 'Change mode'
};

// CONCATENATED MODULE: ./src/plugins/source/editor/SourceEditor.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
class SourceEditor {
    constructor(jodit, container, toWYSIWYG, fromWYSIWYG) {
        this.jodit = jodit;
        this.container = container;
        this.toWYSIWYG = toWYSIWYG;
        this.fromWYSIWYG = fromWYSIWYG;
        this.className = '';
        this.isReady = false;
    }
    onReady() {
        this.isReady = true;
        this.jodit.events.fire(this, 'ready');
    }
    onReadyAlways(onReady) {
        var _a;
        if (!this.isReady) {
            (_a = this.jodit.events) === null || _a === void 0 ? void 0 : _a.on(this, 'ready', onReady);
        }
        else {
            onReady();
        }
    }
}

// CONCATENATED MODULE: ./src/plugins/source/editor/engines/area.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class area_TextAreaEditor extends SourceEditor {
    constructor() {
        super(...arguments);
        this.autosize = debounce(() => {
            this.instance.style.height = 'auto';
            this.instance.style.height = this.instance.scrollHeight + 'px';
        }, this.jodit.defaultTimeout);
    }
    init(editor) {
        this.instance = editor.create.element('textarea', {
            class: 'jodit_source_mirror'
        });
        this.container.appendChild(this.instance);
        editor.events
            .on(this.instance, 'mousedown keydown touchstart input', debounce(this.toWYSIWYG, editor.defaultTimeout))
            .on('setMinHeight.source', (minHeightD) => {
            css_css(this.instance, 'minHeight', minHeightD);
        })
            .on(this.instance, 'change keydown mousedown touchstart input', this.autosize)
            .on('afterSetMode.source', this.autosize)
            .on(this.instance, 'mousedown focus', (e) => {
            editor.events.fire(e.type, e);
        });
        this.autosize();
        this.onReady();
    }
    destruct() {
        Dom_Dom.safeRemove(this.instance);
    }
    getValue() {
        return this.instance.value;
    }
    setValue(raw) {
        this.instance.value = raw;
    }
    insertRaw(raw) {
        const value = this.getValue();
        if (this.getSelectionStart() >= 0) {
            const startPos = this.getSelectionStart(), endPos = this.getSelectionEnd();
            this.setValue(value.substring(0, startPos) +
                raw +
                value.substring(endPos, value.length));
        }
        else {
            this.setValue(value + raw);
        }
    }
    getSelectionStart() {
        return this.instance.selectionStart;
    }
    getSelectionEnd() {
        return this.instance.selectionEnd;
    }
    setSelectionRange(start, end) {
        this.instance.setSelectionRange(start, end);
    }
    focus() {
        this.instance.focus();
    }
    setPlaceHolder(title) {
        this.instance.setAttribute('placeholder', title);
    }
    setReadOnly(isReadOnly) {
        if (isReadOnly) {
            this.instance.setAttribute('readonly', 'true');
        }
        else {
            this.instance.removeAttribute('readonly');
        }
    }
    selectAll() {
        this.instance.select();
    }
}

// CONCATENATED MODULE: ./src/plugins/source/editor/engines/ace.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



class ace_AceEditor extends SourceEditor {
    constructor() {
        super(...arguments);
        this.className = 'jodit_ace_editor';
        this.proxyOnFocus = (e) => {
            this.jodit.events.fire('focus', e);
        };
        this.proxyOnMouseDown = (e) => {
            this.jodit.events.fire('mousedown', e);
        };
    }
    aceExists() {
        return this.jodit.ownerWindow.ace !== undefined;
    }
    get undoManager() {
        return this.instance
            ? this.instance.getSession().getUndoManager()
            : null;
    }
    updateButtons() {
        if (this.undoManager &&
            this.jodit.getRealMode() === MODE_SOURCE) {
            this.jodit.events.fire('canRedo', this.undoManager.hasRedo());
            this.jodit.events.fire('canUndo', this.undoManager.hasUndo());
        }
    }
    getLastColumnIndex(row) {
        return this.instance.session.getLine(row).length;
    }
    getLastColumnIndices() {
        const rows = this.instance.session.getLength();
        const lastColumnIndices = [];
        let lastColIndex = 0;
        for (let i = 0; i < rows; i++) {
            lastColIndex += this.getLastColumnIndex(i);
            if (i > 0) {
                lastColIndex += 1;
            }
            lastColumnIndices[i] = lastColIndex;
        }
        return lastColumnIndices;
    }
    getRowColumnIndices(characterIndex) {
        const lastColumnIndices = this.getLastColumnIndices();
        if (characterIndex <= lastColumnIndices[0]) {
            return { row: 0, column: characterIndex };
        }
        let row = 1;
        for (let i = 1; i < lastColumnIndices.length; i++) {
            if (characterIndex > lastColumnIndices[i]) {
                row = i + 1;
            }
        }
        const column = characterIndex - lastColumnIndices[row - 1] - 1;
        return { row, column };
    }
    setSelectionRangeIndices(start, end) {
        const startRowColumn = this.getRowColumnIndices(start);
        const endRowColumn = this.getRowColumnIndices(end);
        this.instance.getSelection().setSelectionRange({
            start: startRowColumn,
            end: endRowColumn
        });
    }
    getIndexByRowColumn(row, column) {
        const lastColumnIndices = this.getLastColumnIndices();
        return lastColumnIndices[row] - this.getLastColumnIndex(row) + column;
    }
    init(editor) {
        const tryInitAceEditor = () => {
            if (this.instance !== undefined || !this.aceExists()) {
                return;
            }
            const fakeMirror = this.jodit.create.div('jodit_source_mirror-fake');
            this.container.appendChild(fakeMirror);
            this.instance = editor.ownerWindow
                .ace.edit(fakeMirror);
            this.instance.setTheme(editor.options.sourceEditorNativeOptions.theme);
            this.instance.renderer.setShowGutter(editor.options.sourceEditorNativeOptions.showGutter);
            this.instance
                .getSession()
                .setMode(editor.options.sourceEditorNativeOptions.mode);
            this.instance.setHighlightActiveLine(editor.options.sourceEditorNativeOptions.highlightActiveLine);
            this.instance.getSession().setUseWrapMode(true);
            this.instance.setOption('indentedSoftWrap', false);
            this.instance.setOption('wrap', editor.options.sourceEditorNativeOptions.wrap);
            this.instance.getSession().setUseWorker(false);
            this.instance.$blockScrolling = Infinity;
            this.instance.setOptions({
                maxLines: Infinity
            });
            this.instance.on('change', this.toWYSIWYG);
            this.instance.on('focus', this.proxyOnFocus);
            this.instance.on('mousedown', this.proxyOnMouseDown);
            if (editor.getRealMode() !== MODE_WYSIWYG) {
                this.setValue(this.getValue());
            }
            editor.events
                .on('afterResize', () => {
                this.instance.resize();
            });
            this.onReady();
        };
        editor.events
            .on('afterSetMode', () => {
            if (editor.getRealMode() !== MODE_SOURCE &&
                editor.getMode() !== MODE_SPLIT) {
                return;
            }
            this.fromWYSIWYG();
            tryInitAceEditor();
        })
            .on('beforeCommand', (command) => {
            if (editor.getRealMode() !== MODE_WYSIWYG &&
                (command === 'redo' || command === 'undo') &&
                this.undoManager) {
                if (this.undoManager['has' +
                    command.substr(0, 1).toUpperCase() +
                    command.substr(1)]) {
                    this.instance[command]();
                }
                this.updateButtons();
                return false;
            }
        });
        tryInitAceEditor();
        if (!this.aceExists()) {
            loadNext(editor, editor.options.sourceEditorCDNUrlsJS).then(() => {
                if (!editor.isInDestruct) {
                    tryInitAceEditor();
                }
            });
        }
    }
    destruct() {
        var _a, _b;
        this.instance.off('change', this.toWYSIWYG);
        this.instance.off('focus', this.proxyOnFocus);
        this.instance.off('mousedown', this.proxyOnMouseDown);
        this.instance.destroy();
        (_b = (_a = this.jodit) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.off('aceInited.source');
    }
    setValue(value) {
        if (this.jodit.options.beautifyHTML) {
            const html = this.jodit.events.fire('beautifyHTML', value);
            if (isString(html)) {
                value = html;
            }
        }
        this.instance.setValue(value);
        this.instance.clearSelection();
        this.updateButtons();
    }
    getValue() {
        return this.instance.getValue();
    }
    setReadOnly(isReadOnly) {
        this.instance.setReadOnly(isReadOnly);
    }
    focus() {
        this.instance.focus();
    }
    getSelectionStart() {
        const range = this.instance.selection.getRange();
        return this.getIndexByRowColumn(range.start.row, range.start.column);
    }
    getSelectionEnd() {
        const range = this.instance.selection.getRange();
        return this.getIndexByRowColumn(range.end.row, range.end.column);
    }
    selectAll() {
        this.instance.selection.selectAll();
    }
    insertRaw(html) {
        const start = this.instance.selection.getCursor(), end = this.instance.session.insert(start, html);
        this.instance.selection.setRange({
            start,
            end
        }, false);
    }
    setSelectionRange(start, end) {
        this.setSelectionRangeIndices(start, end);
    }
    setPlaceHolder(title) {
    }
}

// CONCATENATED MODULE: ./src/plugins/source/editor/engines/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



// CONCATENATED MODULE: ./src/plugins/source/editor/factory.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

function createSourceEditor(type, editor, container, toWYSIWYG, fromWYSIWYG) {
    let sourceEditor;
    switch (type) {
        case 'ace':
            sourceEditor = new ace_AceEditor(editor, container, toWYSIWYG, fromWYSIWYG);
            break;
        default:
            sourceEditor = new area_TextAreaEditor(editor, container, toWYSIWYG, fromWYSIWYG);
    }
    sourceEditor.init(editor);
    sourceEditor.onReadyAlways(() => {
        sourceEditor.setReadOnly(editor.options.readonly);
    });
    return sourceEditor;
}

// CONCATENATED MODULE: ./src/plugins/source/source.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






class source_source extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.__lock = false;
        this.__oldMirrorValue = '';
        this.tempMarkerStart = '{start-jodit-selection}';
        this.tempMarkerStartReg = /{start-jodit-selection}/g;
        this.tempMarkerEnd = '{end-jodit-selection}';
        this.tempMarkerEndReg = /{end-jodit-selection}/g;
        this.selInfo = [];
        this.insertHTML = (html) => {
            this.sourceEditor.insertRaw(html);
            this.toWYSIWYG();
        };
        this.fromWYSIWYG = (force = false) => {
            if (!this.__lock || force === true) {
                this.__lock = true;
                const new_value = this.jodit.getEditorValue(false);
                if (new_value !== this.getMirrorValue()) {
                    this.setMirrorValue(new_value);
                }
                this.__lock = false;
            }
        };
        this.toWYSIWYG = () => {
            if (this.__lock) {
                return;
            }
            const value = this.getMirrorValue();
            if (value === this.__oldMirrorValue) {
                return;
            }
            this.__lock = true;
            this.jodit.setEditorValue(value);
            this.__lock = false;
            this.__oldMirrorValue = value;
        };
        this.getNormalPosition = (pos, str) => {
            let start = pos;
            while (start > 0) {
                start--;
                if (str[start] === '<' &&
                    str[start + 1] !== undefined &&
                    str[start + 1].match(/[\w\/]+/i)) {
                    return start;
                }
                if (str[start] === '>') {
                    return pos;
                }
            }
            return pos;
        };
        this.__clear = (str) => str.replace(INVISIBLE_SPACE_REG_EXP, '');
        this.selectAll = () => {
            this.sourceEditor.selectAll();
        };
        this.onSelectAll = (command) => {
            if (command.toLowerCase() === 'selectall' &&
                this.jodit.getRealMode() === MODE_SOURCE) {
                this.selectAll();
                return false;
            }
        };
        this.getSelectionStart = () => {
            return this.sourceEditor.getSelectionStart();
        };
        this.getSelectionEnd = () => {
            return this.sourceEditor.getSelectionEnd();
        };
        this.saveSelection = () => {
            if (this.jodit.getRealMode() === MODE_WYSIWYG) {
                this.selInfo = this.jodit.selection.save() || [];
                this.jodit.setEditorValue();
                this.fromWYSIWYG(true);
            }
            else {
                this.selInfo.length = 0;
                const value = this.getMirrorValue();
                if (this.getSelectionStart() === this.getSelectionEnd()) {
                    const marker = this.jodit.selection.marker(true);
                    this.selInfo[0] = {
                        startId: marker.id,
                        collapsed: true,
                        startMarker: marker.outerHTML
                    };
                    const selectionStart = this.getNormalPosition(this.getSelectionStart(), this.getMirrorValue());
                    this.setMirrorValue(value.substr(0, selectionStart) +
                        this.__clear(this.selInfo[0].startMarker) +
                        value.substr(selectionStart));
                }
                else {
                    const markerStart = this.jodit.selection.marker(true);
                    const markerEnd = this.jodit.selection.marker(false);
                    this.selInfo[0] = {
                        startId: markerStart.id,
                        endId: markerEnd.id,
                        collapsed: false,
                        startMarker: this.__clear(markerStart.outerHTML),
                        endMarker: this.__clear(markerEnd.outerHTML)
                    };
                    const selectionStart = this.getNormalPosition(this.getSelectionStart(), value);
                    const selectionEnd = this.getNormalPosition(this.getSelectionEnd(), value);
                    this.setMirrorValue(value.substr(0, selectionStart) +
                        this.selInfo[0].startMarker +
                        value.substr(selectionStart, selectionEnd - selectionStart) +
                        this.selInfo[0].endMarker +
                        value.substr(selectionEnd));
                }
                this.toWYSIWYG();
            }
        };
        this.restoreSelection = () => {
            if (!this.selInfo.length) {
                return;
            }
            if (this.jodit.getRealMode() === MODE_WYSIWYG) {
                this.__lock = true;
                this.jodit.selection.restore(this.selInfo);
                this.__lock = false;
                return;
            }
            let value = this.getMirrorValue();
            let selectionStart = 0, selectionEnd = 0;
            try {
                if (this.selInfo[0].startMarker) {
                    value = value.replace(/<span[^>]+data-jodit_selection_marker="start"[^>]*>[<>]*?<\/span>/gim, this.tempMarkerStart);
                }
                if (this.selInfo[0].endMarker) {
                    value = value.replace(/<span[^>]+data-jodit_selection_marker="end"[^>]*>[<>]*?<\/span>/gim, this.tempMarkerEnd);
                }
                if (this.jodit.options.beautifyHTML) {
                    const html = this.jodit.events.fire('beautifyHTML', value);
                    if (isString(html)) {
                        value = html;
                    }
                }
                selectionStart = value.indexOf(this.tempMarkerStart);
                selectionEnd = selectionStart;
                value = value.replace(this.tempMarkerStartReg, '');
                if (!this.selInfo[0].collapsed || selectionStart === -1) {
                    selectionEnd = value.indexOf(this.tempMarkerEnd);
                    if (selectionStart === -1) {
                        selectionStart = selectionEnd;
                    }
                }
                value = value.replace(this.tempMarkerEndReg, '');
            }
            finally {
                value = value
                    .replace(this.tempMarkerEndReg, '')
                    .replace(this.tempMarkerStartReg, '');
            }
            this.setMirrorValue(value);
            this.setMirrorSelectionRange(selectionStart, selectionEnd);
            this.toWYSIWYG();
            this.setFocusToMirror();
        };
        this.setMirrorSelectionRange = (start, end) => {
            this.sourceEditor.setSelectionRange(start, end);
        };
        this.onReadonlyReact = () => {
            this.sourceEditor.setReadOnly(this.jodit.options.readonly);
        };
    }
    getMirrorValue() {
        return this.sourceEditor.getValue();
    }
    setMirrorValue(value) {
        this.sourceEditor.setValue(value);
    }
    setFocusToMirror() {
        this.sourceEditor.focus();
    }
    initSourceEditor(editor) {
        if (editor.options.sourceEditor !== 'area') {
            const sourceEditor = createSourceEditor(editor.options.sourceEditor, editor, this.mirrorContainer, this.toWYSIWYG, this.fromWYSIWYG);
            sourceEditor.onReadyAlways(() => {
                var _a, _b;
                (_a = this.sourceEditor) === null || _a === void 0 ? void 0 : _a.destruct();
                this.sourceEditor = sourceEditor;
                (_b = editor.events) === null || _b === void 0 ? void 0 : _b.fire('sourceEditorReady', editor);
            });
        }
        else {
            this.sourceEditor.onReadyAlways(() => {
                var _a;
                (_a = editor.events) === null || _a === void 0 ? void 0 : _a.fire('sourceEditorReady', editor);
            });
        }
    }
    afterInit(editor) {
        this.mirrorContainer = editor.create.div('jodit_source');
        editor.workplace.appendChild(this.mirrorContainer);
        editor.events.on('afterAddPlace changePlace afterInit', () => {
            editor.workplace.appendChild(this.mirrorContainer);
        });
        this.sourceEditor = createSourceEditor('area', editor, this.mirrorContainer, this.toWYSIWYG, this.fromWYSIWYG);
        const addListeners = () => {
            editor.events
                .off('beforeSetMode.source afterSetMode.source')
                .on('beforeSetMode.source', this.saveSelection)
                .on('afterSetMode.source', this.restoreSelection);
        };
        addListeners();
        this.onReadonlyReact();
        editor.events
            .on('insertHTML.source', (html) => {
            if (!editor.options.readonly && !this.jodit.isEditorMode()) {
                this.insertHTML(html);
                return false;
            }
        })
            .on('readonly.source', this.onReadonlyReact)
            .on('placeholder.source', (text) => {
            this.sourceEditor.setPlaceHolder(text);
        })
            .on('beforeCommand.source', this.onSelectAll)
            .on('change.source', this.fromWYSIWYG);
        editor.events.on('beautifyHTML', (html) => html);
        if (editor.options.beautifyHTML) {
            const addEventListener = () => {
                var _a, _b;
                const html_beautify = editor.ownerWindow.html_beautify;
                if (html_beautify && !editor.isInDestruct) {
                    (_b = (_a = editor.events) === null || _a === void 0 ? void 0 : _a.off('beautifyHTML')) === null || _b === void 0 ? void 0 : _b.on('beautifyHTML', (html) => html_beautify(html));
                    return true;
                }
                return false;
            };
            if (!addEventListener()) {
                loadNext(editor, editor.options.beautifyHTMLCDNUrlsJS).then(addEventListener);
            }
        }
        this.fromWYSIWYG();
        this.initSourceEditor(editor);
    }
    beforeDestruct(jodit) {
        if (this.sourceEditor) {
            this.sourceEditor.destruct();
            delete this.sourceEditor;
        }
        Dom_Dom.safeRemove(this.mirrorContainer);
    }
}

// CONCATENATED MODULE: ./src/plugins/source/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



// CONCATENATED MODULE: ./src/plugins/stat.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





Config_Config.prototype.showCharsCounter = true;
Config_Config.prototype.showWordsCounter = true;
class stat_stat extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.reInit = () => {
            if (this.jodit.options.showCharsCounter) {
                this.jodit.statusbar.append(this.charCounter, true);
            }
            if (this.jodit.options.showWordsCounter) {
                this.jodit.statusbar.append(this.wordCounter, true);
            }
            this.jodit.events
                .off('change keyup', this.calc)
                .on('change keyup', this.calc);
            this.calc();
        };
        this.calc = throttle(() => {
            const text = this.jodit.text;
            if (this.jodit.options.showCharsCounter) {
                this.charCounter.textContent = this.jodit.i18n('Chars: %d', text.replace(SPACE_REG_EXP, '').length);
            }
            if (this.jodit.options.showWordsCounter) {
                this.wordCounter.textContent = this.jodit.i18n('Words: %d', text
                    .replace(INVISIBLE_SPACE_REG_EXP, '')
                    .split(SPACE_REG_EXP)
                    .filter((e) => e.length).length);
            }
        }, this.jodit.defaultTimeout);
    }
    afterInit() {
        this.charCounter = this.jodit.create.span();
        this.wordCounter = this.jodit.create.span();
        this.jodit.events.on('afterInit changePlace afterAddPlace', this.reInit);
        this.reInit();
    }
    beforeDestruct() {
        Dom_Dom.safeRemove(this.charCounter);
        Dom_Dom.safeRemove(this.wordCounter);
        this.jodit.events.off('afterInit changePlace afterAddPlace', this.reInit);
        delete this.charCounter;
        delete this.wordCounter;
    }
}

// CONCATENATED MODULE: ./src/plugins/sticky.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






Config_Config.prototype.toolbarSticky = true;
Config_Config.prototype.toolbarDisableStickyForMobile = true;
Config_Config.prototype.toolbarStickyOffset = 0;
class sticky_sticky extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.isToolbarSticked = false;
        this.createDummy = (toolbar) => {
            if (IS_IE && !this.dummyBox) {
                this.dummyBox = this.jodit.create.div();
                this.dummyBox.classList.add('jodit_sticky-dummy_toolbar');
                this.jodit.container.insertBefore(this.dummyBox, toolbar);
            }
        };
        this.addSticky = (toolbar) => {
            if (!this.isToolbarSticked) {
                this.createDummy(toolbar);
                this.jodit.container.classList.add('jodit_sticky');
                this.isToolbarSticked = true;
            }
            css_css(toolbar, {
                top: this.jodit.options.toolbarStickyOffset,
                width: this.jodit.container.offsetWidth
            });
            if (IS_IE && this.dummyBox) {
                css_css(this.dummyBox, {
                    height: toolbar.offsetHeight
                });
            }
        };
        this.removeSticky = (toolbar) => {
            if (this.isToolbarSticked) {
                css_css(toolbar, {
                    width: '',
                    top: ''
                });
                this.jodit.container.classList.remove('jodit_sticky');
                this.isToolbarSticked = false;
            }
        };
    }
    isMobile() {
        return (this.jodit &&
            this.jodit.options &&
            this.jodit.container &&
            this.jodit.options.sizeSM >= this.jodit.container.offsetWidth);
    }
    afterInit(jodit) {
        jodit.events.on(jodit.ownerWindow, 'scroll wheel mousewheel resize', () => {
            const scrollWindowTop = jodit.ownerWindow.pageYOffset ||
                (jodit.ownerDocument.documentElement &&
                    jodit.ownerDocument.documentElement.scrollTop) ||
                0, offsetEditor = offset(jodit.container, jodit, jodit.ownerDocument, true), doSticky = jodit.getMode() === MODE_WYSIWYG &&
                (scrollWindowTop + jodit.options.toolbarStickyOffset >
                    offsetEditor.top &&
                    scrollWindowTop +
                        jodit.options.toolbarStickyOffset <
                        offsetEditor.top + offsetEditor.height) &&
                !(jodit.options.toolbarDisableStickyForMobile &&
                    this.isMobile());
            if (jodit.options.toolbarSticky && jodit.options.toolbar === true) {
                doSticky
                    ? this.addSticky(jodit.toolbar.getParentContainer())
                    : this.removeSticky(jodit.toolbar.getParentContainer());
            }
            jodit.events.fire('toggleSticky', doSticky);
        });
    }
    beforeDestruct(jodit) {
        this.dummyBox && Dom_Dom.safeRemove(this.dummyBox);
    }
}

// CONCATENATED MODULE: ./src/plugins/symbols.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



Config_Config.prototype.usePopupForSpecialCharacters = false;
Config_Config.prototype.specialCharacters = [
    '!',
    '&quot;',
    '#',
    '$',
    '%',
    '&amp;',
    "'",
    '(',
    ')',
    '*',
    '+',
    '-',
    '.',
    '/',
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    ':',
    ';',
    '&lt;',
    '=',
    '&gt;',
    '?',
    '@',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F',
    'G',
    'H',
    'I',
    'J',
    'K',
    'L',
    'M',
    'N',
    'O',
    'P',
    'Q',
    'R',
    'S',
    'T',
    'U',
    'V',
    'W',
    'X',
    'Y',
    'Z',
    '[',
    ']',
    '^',
    '_',
    '`',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'g',
    'h',
    'i',
    'j',
    'k',
    'l',
    'm',
    'n',
    'o',
    'p',
    'q',
    'r',
    's',
    't',
    'u',
    'v',
    'w',
    'x',
    'y',
    'z',
    '{',
    '|',
    '}',
    '~',
    '&euro;',
    '&lsquo;',
    '&rsquo;',
    '&ldquo;',
    '&rdquo;',
    '&ndash;',
    '&mdash;',
    '&iexcl;',
    '&cent;',
    '&pound;',
    '&curren;',
    '&yen;',
    '&brvbar;',
    '&sect;',
    '&uml;',
    '&copy;',
    '&ordf;',
    '&laquo;',
    '&raquo;',
    '&not;',
    '&reg;',
    '&macr;',
    '&deg;',
    '&sup2;',
    '&sup3;',
    '&acute;',
    '&micro;',
    '&para;',
    '&middot;',
    '&cedil;',
    '&sup1;',
    '&ordm;',
    '&frac14;',
    '&frac12;',
    '&frac34;',
    '&iquest;',
    '&Agrave;',
    '&Aacute;',
    '&Acirc;',
    '&Atilde;',
    '&Auml;',
    '&Aring;',
    '&AElig;',
    '&Ccedil;',
    '&Egrave;',
    '&Eacute;',
    '&Ecirc;',
    '&Euml;',
    '&Igrave;',
    '&Iacute;',
    '&Icirc;',
    '&Iuml;',
    '&ETH;',
    '&Ntilde;',
    '&Ograve;',
    '&Oacute;',
    '&Ocirc;',
    '&Otilde;',
    '&Ouml;',
    '&times;',
    '&Oslash;',
    '&Ugrave;',
    '&Uacute;',
    '&Ucirc;',
    '&Uuml;',
    '&Yacute;',
    '&THORN;',
    '&szlig;',
    '&agrave;',
    '&aacute;',
    '&acirc;',
    '&atilde;',
    '&auml;',
    '&aring;',
    '&aelig;',
    '&ccedil;',
    '&egrave;',
    '&eacute;',
    '&ecirc;',
    '&euml;',
    '&igrave;',
    '&iacute;',
    '&icirc;',
    '&iuml;',
    '&eth;',
    '&ntilde;',
    '&ograve;',
    '&oacute;',
    '&ocirc;',
    '&otilde;',
    '&ouml;',
    '&divide;',
    '&oslash;',
    '&ugrave;',
    '&uacute;',
    '&ucirc;',
    '&uuml;',
    '&yacute;',
    '&thorn;',
    '&yuml;',
    '&OElig;',
    '&oelig;',
    '&#372;',
    '&#374',
    '&#373',
    '&#375;',
    '&sbquo;',
    '&#8219;',
    '&bdquo;',
    '&hellip;',
    '&trade;',
    '&#9658;',
    '&bull;',
    '&rarr;',
    '&rArr;',
    '&hArr;',
    '&diams;',
    '&asymp;'
];
Config_Config.prototype.controls.symbol = {
    icon: 'omega',
    hotkeys: ['ctrl+shift+i', 'cmd+shift+i'],
    tooltip: 'Insert Special Character',
    popup: (editor, current, control, close) => {
        const container = editor.events.fire('generateSpecialCharactersTable.symbols');
        if (container) {
            if (editor.options.usePopupForSpecialCharacters) {
                const box = editor.create.div();
                box.classList.add('jodit_symbols');
                box.appendChild(container);
                editor.events.on(container, 'close_dialog', close);
                return box;
            }
            else {
                const dialog = Alert(container, editor.i18n('Select Special Character'), undefined, 'jodit_symbols');
                const a = container.querySelector('a');
                a && a.focus();
                editor.events.on('beforeDestruct', () => {
                    dialog && dialog.close();
                });
            }
        }
    }
};
class symbols_symbols {
    constructor(editor) {
        this.countInRow = 17;
        editor.events.on('generateSpecialCharactersTable.symbols', () => {
            const container = editor.create.fromHTML('<div class="jodit_symbols-container">' +
                '<div class="jodit_symbols-container_table"><table><tbody></tbody></table></div>' +
                '<div class="jodit_symbols-container_preview"><div class="jodit_symbols-preview"></div></div>' +
                '</div>'), preview = container.querySelector('.jodit_symbols-preview'), table = container.querySelector('table'), body = table.tBodies[0], chars = [];
            for (let i = 0; i < editor.options.specialCharacters.length;) {
                const tr = editor.create.element('tr');
                for (let j = 0; j < this.countInRow &&
                    i < editor.options.specialCharacters.length; j += 1, i += 1) {
                    const td = editor.create.element('td'), a = editor.create.fromHTML(`<a
                                    data-index="${i}"
                                    data-index-j="${j}"
                                    href="javascript:void(0)"
                                    role="option"
                                    tabindex="-1"
                                >${editor.options.specialCharacters[i]}</a>`);
                    chars.push(a);
                    td.appendChild(a);
                    tr.appendChild(td);
                }
                body.appendChild(tr);
            }
            const self = this;
            editor.events
                .on(chars, 'focus', function () {
                preview.innerHTML = this.innerHTML;
            })
                .on(chars, 'mousedown', function (e) {
                if (this && this.nodeName === 'A') {
                    editor.selection.focus();
                    editor.selection.insertHTML(this.innerHTML);
                    editor.events.fire(this, 'close_dialog');
                    e && e.preventDefault();
                    e && e.stopImmediatePropagation();
                }
            })
                .on(chars, 'mouseenter', function () {
                if (this && this.nodeName === 'A') {
                    this.focus();
                }
            })
                .on(chars, 'keydown', (e) => {
                const target = e.target;
                if (target && target.nodeName === 'A') {
                    const index = parseInt(target.getAttribute('data-index') || '0', 10), jIndex = parseInt(target.getAttribute('data-index-j') || '0', 10);
                    let newIndex;
                    switch (e.which) {
                        case KEY_UP:
                        case KEY_DOWN:
                            newIndex =
                                e.which === KEY_UP
                                    ? index - self.countInRow
                                    : index + self.countInRow;
                            if (chars[newIndex] === undefined) {
                                newIndex =
                                    e.which === KEY_UP
                                        ? Math.floor(chars.length /
                                            self.countInRow) *
                                            self.countInRow +
                                            jIndex
                                        : jIndex;
                                if (newIndex > chars.length - 1) {
                                    newIndex -= self.countInRow;
                                }
                            }
                            chars[newIndex] && chars[newIndex].focus();
                            break;
                        case KEY_RIGHT:
                        case KEY_LEFT:
                            newIndex =
                                e.which === KEY_LEFT
                                    ? index - 1
                                    : index + 1;
                            if (chars[newIndex] === undefined) {
                                newIndex =
                                    e.which === KEY_LEFT
                                        ? chars.length - 1
                                        : 0;
                            }
                            chars[newIndex] && chars[newIndex].focus();
                            break;
                        case KEY_ENTER:
                            editor.events.fire(target, 'mousedown');
                            e.stopImmediatePropagation();
                            e.preventDefault();
                            break;
                    }
                }
            });
            return container;
        });
    }
}

// CONCATENATED MODULE: ./src/plugins/table-keyboard-navigation.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



function tableKeyboardNavigation(editor) {
    editor.events
        .off('.tableKeyboardNavigation')
        .on('keydown.tableKeyboardNavigation', (event) => {
        let current, block;
        if (event.which === KEY_TAB ||
            event.which === KEY_LEFT ||
            event.which === KEY_RIGHT ||
            event.which === KEY_UP ||
            event.which === KEY_DOWN) {
            current = editor.selection.current();
            block = Dom_Dom.up(current, (elm) => elm && elm.nodeName && /^td|th$/i.test(elm.nodeName), editor.editor);
            if (!block) {
                return;
            }
            const range = editor.selection.range;
            if (event.which !== KEY_TAB && current !== block) {
                if (((event.which === KEY_LEFT ||
                    event.which === KEY_UP) &&
                    (Dom_Dom.prev(current, (elm) => event.which === KEY_UP
                        ? elm && elm.nodeName === 'BR'
                        : !!elm, block) ||
                        (event.which !== KEY_UP &&
                            current.nodeType === Node.TEXT_NODE &&
                            range.startOffset !== 0))) ||
                    ((event.which === KEY_RIGHT ||
                        event.which === KEY_DOWN) &&
                        (Dom_Dom.next(current, (elm) => event.which === KEY_DOWN
                            ? elm && elm.nodeName === 'BR'
                            : !!elm, block) ||
                            (event.which !== KEY_DOWN &&
                                current.nodeType === Node.TEXT_NODE &&
                                current.nodeValue &&
                                range.startOffset !==
                                    current.nodeValue.length)))) {
                    return;
                }
            }
        }
        else {
            return;
        }
        const table = Dom_Dom.up(block, (elm) => elm && /^table$/i.test(elm.nodeName), editor.editor);
        let next = null;
        switch (event.which) {
            case KEY_TAB:
            case KEY_LEFT:
                const sibling = event.which === KEY_LEFT || event.shiftKey
                    ? 'prev'
                    : 'next';
                next = Dom_Dom[sibling](block, (elm) => elm &&
                    /^td|th$/i.test(elm.tagName), table);
                if (!next) {
                    Table_Table.appendRow(table, sibling === 'next'
                        ? false
                        : table.querySelector('tr'), sibling === 'next', editor.create.inside);
                    next = Dom_Dom[sibling](block, (elm) => elm && Dom_Dom.isCell(elm, editor.editorWindow), table);
                }
                break;
            case KEY_UP:
            case KEY_DOWN:
                {
                    let i = 0, j = 0;
                    const matrix = Table_Table.formalMatrix(table, (elm, _i, _j) => {
                        if (elm === block) {
                            i = _i;
                            j = _j;
                        }
                    });
                    if (event.which === KEY_UP) {
                        if (matrix[i - 1] !== undefined) {
                            next = matrix[i - 1][j];
                        }
                    }
                    else {
                        if (matrix[i + 1] !== undefined) {
                            next = matrix[i + 1][j];
                        }
                    }
                }
                break;
        }
        if (next) {
            if (!next.firstChild) {
                const first = editor.create.inside.element('br');
                next.appendChild(first);
                editor.selection.setCursorBefore(first);
            }
            else {
                if (event.which === KEY_TAB) {
                    editor.selection.select(next, true);
                }
                else {
                    editor.selection.setCursorIn(next, event.which === KEY_RIGHT ||
                        event.which === KEY_DOWN);
                }
            }
            return false;
        }
    });
}

// CONCATENATED MODULE: ./src/plugins/table.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






Config_Config.prototype.useTableProcessor = true;
Config_Config.prototype.useExtraClassesOptions = true;
Config_Config.prototype.controls.table = {
    data: {
        cols: 10,
        rows: 10,
        classList: {
            'table table-bordered': 'Bootstrap Bordered',
            'table table-striped': 'Bootstrap Striped',
            'table table-dark': 'Bootstrap Dark'
        }
    },
    popup: (editor, current, control, close, button) => {
        const default_rows_count = control.data && control.data.rows ? control.data.rows : 10, default_cols_count = control.data && control.data.cols ? control.data.cols : 10;
        const generateExtraClasses = () => {
            if (!editor.options.useExtraClassesOptions) {
                return '';
            }
            const out = [];
            if (control.data) {
                const classList = control.data.classList;
                Object.keys(classList).forEach((classes) => {
                    out.push(`<label class="jodit_vertical_middle"><input class="jodit_checkbox" value="${classes}" type="checkbox"/>${classList[classes]}</label>`);
                });
            }
            return out.join('');
        };
        const form = editor.create.fromHTML('<form class="jodit_form jodit_form_inserter">' +
            '<label class="jodit_form_center">' +
            '<span>1</span> &times; <span>1</span>' +
            '</label>' +
            '<div class="jodit_form-table-creator-box">' +
            '<div class="jodit_form-container"></div>' +
            '<div class="jodit_form-options">' +
            generateExtraClasses() +
            '</div>' +
            '</div>' +
            '</form>'), rows = form.querySelectorAll('span')[0], cols = form.querySelectorAll('span')[1], blocksContainer = form.querySelector('.jodit_form-container'), mainBox = form.querySelector('.jodit_form-table-creator-box'), options = form.querySelector('.jodit_form-options'), cells = [];
        const generateRows = (need_rows) => {
            const cnt = need_rows * default_cols_count;
            if (cells.length > cnt) {
                for (let i = cnt; i < cells.length; i += 1) {
                    Dom_Dom.safeRemove(cells[i]);
                    delete cells[i];
                }
                cells.length = cnt;
            }
            for (let i = 0; i < cnt; i += 1) {
                if (!cells[i]) {
                    const div = editor.create.div();
                    div.setAttribute('data-index', i.toString());
                    cells.push(div);
                }
            }
            cells.forEach((cell) => {
                blocksContainer.appendChild(cell);
            });
            const width = (cells[0].offsetWidth || 18) * default_cols_count;
            blocksContainer.style.width = width + 'px';
            mainBox.style.width = width + options.offsetWidth + 1 + 'px';
        };
        const mouseenter = (e, index) => {
            const dv = e.target;
            if (!dv || dv.tagName !== 'DIV') {
                return;
            }
            let k = index === undefined || isNaN(index)
                ? parseInt(dv.getAttribute('data-index') || '0', 10)
                : index || 0;
            const rows_count = Math.ceil((k + 1) / default_cols_count), cols_count = (k % default_cols_count) + 1;
            for (let i = 0; i < cells.length; i += 1) {
                if (cols_count >= (i % default_cols_count) + 1 &&
                    rows_count >= Math.ceil((i + 1) / default_cols_count)) {
                    cells[i].className = 'hovered';
                }
                else {
                    cells[i].className = '';
                }
            }
            cols.textContent = cols_count.toString();
            rows.textContent = rows_count.toString();
        };
        blocksContainer.addEventListener('mousemove', mouseenter);
        editor.events.on(blocksContainer, 'touchstart mousedown', (e) => {
            const dv = e.target;
            e.preventDefault();
            e.stopImmediatePropagation();
            if (dv.tagName !== 'DIV') {
                return;
            }
            let k = parseInt(dv.getAttribute('data-index') || '0', 10);
            const rows_count = Math.ceil((k + 1) / default_cols_count), cols_count = (k % default_cols_count) + 1;
            const crt = editor.create.inside, tbody = crt.element('tbody'), table = crt.element('table');
            table.appendChild(tbody);
            table.style.width = '100%';
            let first_td = null, tr, td;
            for (let i = 1; i <= rows_count; i += 1) {
                tr = crt.element('tr');
                for (let j = 1; j <= cols_count; j += 1) {
                    td = crt.element('td');
                    if (!first_td) {
                        first_td = td;
                    }
                    td.appendChild(crt.element('br'));
                    tr.appendChild(crt.text('\n'));
                    tr.appendChild(crt.text('\t'));
                    tr.appendChild(td);
                }
                tbody.appendChild(crt.text('\n'));
                tbody.appendChild(tr);
            }
            const crnt = editor.selection.current();
            if (crnt && editor.selection.isCollapsed()) {
                const block = Dom_Dom.closest(crnt, node => Dom_Dom.isBlock(node, editor.editorWindow), editor.editor);
                if (block &&
                    block !== editor.editor &&
                    !block.nodeName.match(/^TD|TH|TBODY|TABLE|THEADER|TFOOTER$/)) {
                    editor.selection.setCursorAfter(block);
                }
            }
            $$('input[type=checkbox]:checked', options).forEach((input) => {
                input.value
                    .split(/[\s]+/)
                    .forEach((className) => {
                    table.classList.add(className);
                });
            });
            editor.selection.insertNode(crt.text('\n'));
            editor.selection.insertNode(table, false);
            if (first_td) {
                editor.selection.setCursorIn(first_td);
                scrollIntoView(first_td, editor.editor, editor.editorDocument);
            }
            close();
        });
        if (button && button.parentToolbar) {
            editor.events
                .off(button.parentToolbar.container, 'afterOpenPopup.tableGenerator')
                .on(button.parentToolbar.container, 'afterOpenPopup.tableGenerator', () => {
                generateRows(default_rows_count);
                if (cells[0]) {
                    cells[0].className = 'hovered';
                }
            }, '', true);
        }
        return form;
    },
    tooltip: 'Insert table'
};
class table_TableProcessor extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.__key = 'table_processor_observer';
        this.__selectMode = false;
        this.__resizerDelta = 0;
        this.__drag = false;
        this.__addResizer = () => {
            if (!this.__resizerHandler) {
                this.__resizerHandler = this.jodit.container.querySelector('.jodit_table_resizer');
                if (!this.__resizerHandler) {
                    this.__resizerHandler = this.jodit.create.div('jodit_table_resizer');
                    let startX = 0;
                    this.jodit.events
                        .on(this.__resizerHandler, 'mousedown.table touchstart.table', (event) => {
                        this.__drag = true;
                        startX = event.clientX;
                        this.jodit.lock(this.__key);
                        this.__resizerHandler.classList.add('jodit_table_resizer-moved');
                        let box, tableBox = this.__workTable.getBoundingClientRect();
                        this.__minX = 0;
                        this.__maxX = 1000000;
                        if (this.__wholeTable !== null) {
                            tableBox = this.__workTable
                                .parentNode.getBoundingClientRect();
                            this.__minX = tableBox.left;
                            this.__maxX = tableBox.left + tableBox.width;
                        }
                        else {
                            const coordinate = Table_Table.formalCoordinate(this.__workTable, this.__workCell, true);
                            Table_Table.formalMatrix(this.__workTable, (td, i, j) => {
                                if (coordinate[1] === j) {
                                    box = td.getBoundingClientRect();
                                    this.__minX = Math.max(box.left + NEARBY / 2, this.__minX);
                                }
                                if (coordinate[1] + 1 === j) {
                                    box = td.getBoundingClientRect();
                                    this.__maxX = Math.min(box.left +
                                        box.width -
                                        NEARBY / 2, this.__maxX);
                                }
                            });
                        }
                        return false;
                    })
                        .on(this.__resizerHandler, 'mouseenter.table', () => {
                        this.jodit.async.clearTimeout(this.hideTimeout);
                    })
                        .on(this.jodit.editorWindow, 'mousemove.table touchmove.table', (event) => {
                        if (this.__drag) {
                            let x = event.clientX;
                            const workplacePosition = offset((this.__resizerHandler.parentNode ||
                                this.jodit.ownerDocument
                                    .documentElement), this.jodit, this.jodit.ownerDocument, true);
                            if (x < this.__minX) {
                                x = this.__minX;
                            }
                            if (x > this.__maxX) {
                                x = this.__maxX;
                            }
                            this.__resizerDelta =
                                x -
                                    startX +
                                    (!this.jodit.options.iframe
                                        ? 0
                                        : workplacePosition.left);
                            this.__resizerHandler.style.left =
                                x -
                                    (this.jodit.options.iframe
                                        ? 0
                                        : workplacePosition.left) +
                                    'px';
                            const sel = this.jodit.selection.sel;
                            sel && sel.removeAllRanges();
                            if (event.preventDefault) {
                                event.preventDefault();
                            }
                        }
                    });
                    this.jodit.workplace.appendChild(this.__resizerHandler);
                }
            }
        };
        this.onExecCommand = (command) => {
            if (/table(splitv|splitg|merge|empty|bin|binrow|bincolumn|addcolumn|addrow)/.test(command)) {
                command = command.replace('table', '');
                const cells = Table_Table.getAllSelectedCells(this.jodit.editor);
                if (cells.length) {
                    const cell = cells.shift();
                    if (!cell) {
                        return;
                    }
                    const table = Dom_Dom.closest(cell, 'table', this.jodit.editor);
                    switch (command) {
                        case 'splitv':
                            Table_Table.splitVertical(table, this.jodit.create.inside);
                            break;
                        case 'splitg':
                            Table_Table.splitHorizontal(table, this.jodit.create.inside);
                            break;
                        case 'merge':
                            Table_Table.mergeSelected(table);
                            break;
                        case 'empty':
                            Table_Table.getAllSelectedCells(this.jodit.editor).forEach(td => (td.innerHTML = ''));
                            break;
                        case 'bin':
                            Dom_Dom.safeRemove(table);
                            break;
                        case 'binrow':
                            Table_Table.removeRow(table, cell.parentNode.rowIndex);
                            break;
                        case 'bincolumn':
                            Table_Table.removeColumn(table, cell.cellIndex);
                            break;
                        case 'addcolumnafter':
                        case 'addcolumnbefore':
                            Table_Table.appendColumn(table, cell.cellIndex, command === 'addcolumnafter', this.jodit.create.inside);
                            break;
                        case 'addrowafter':
                        case 'addrowbefore':
                            Table_Table.appendRow(table, cell.parentNode, command === 'addrowafter', this.jodit.create.inside);
                            break;
                    }
                }
                return false;
            }
        };
    }
    static isCell(tag) {
        return !!tag && /^TD|TH$/i.test(tag.nodeName);
    }
    showResizer() {
        this.jodit.async.clearTimeout(this.hideTimeout);
        this.__resizerHandler.style.display = 'block';
    }
    hideResizer() {
        this.hideTimeout = this.jodit.async.setTimeout(() => {
            this.__resizerHandler.style.display = 'none';
        }, {
            timeout: this.jodit.defaultTimeout,
            label: 'hideResizer'
        });
    }
    __deSelectAll(table, currentCell) {
        const cells = table
            ? Table_Table.getAllSelectedCells(table)
            : Table_Table.getAllSelectedCells(this.jodit.editor);
        if (cells.length) {
            cells.forEach((cell) => {
                if (!currentCell || currentCell !== cell) {
                    Table_Table.restoreSelection(cell);
                }
            });
        }
    }
    __setWorkCell(cell, wholeTable = null) {
        this.__wholeTable = wholeTable;
        this.__workCell = cell;
        this.__workTable = Dom_Dom.up(cell, (elm) => elm && elm.nodeName === 'TABLE', this.jodit.editor);
    }
    __calcResizerPosition(table, cell, offsetX = 0, delta = 0) {
        const box = offset(cell, this.jodit, this.jodit.editorDocument);
        if (offsetX <= NEARBY || box.width - offsetX <= NEARBY) {
            const workplacePosition = offset((this.__resizerHandler.parentNode ||
                this.jodit.ownerDocument
                    .documentElement), this.jodit, this.jodit.ownerDocument, true), parentBox = offset(table, this.jodit, this.jodit.editorDocument);
            this.__resizerHandler.style.left =
                (offsetX <= NEARBY ? box.left : box.left + box.width) -
                    workplacePosition.left +
                    delta +
                    'px';
            this.__resizerHandler.style.height = parentBox.height + 'px';
            this.__resizerHandler.style.top =
                parentBox.top - workplacePosition.top + 'px';
            this.showResizer();
            if (offsetX <= NEARBY) {
                const prevTD = Dom_Dom.prev(cell, table_TableProcessor.isCell, cell.parentNode);
                if (prevTD) {
                    this.__setWorkCell(prevTD);
                }
                else {
                    this.__setWorkCell(cell, true);
                }
            }
            else {
                const nextTD = Dom_Dom.next(cell, table_TableProcessor.isCell, cell.parentNode);
                this.__setWorkCell(cell, !nextTD ? false : null);
            }
        }
        else {
            this.hideResizer();
        }
    }
    observe(table) {
        table[this.__key] = true;
        let start;
        this.jodit.events
            .on(table, 'mousedown.table touchstart.table', (event) => {
            if (this.jodit.options.readonly) {
                return;
            }
            const cell = Dom_Dom.up(event.target, table_TableProcessor.isCell, table);
            if (cell &&
                cell instanceof
                    this.jodit.editorWindow.HTMLElement) {
                if (!cell.firstChild) {
                    cell.appendChild(this.jodit.create.inside.element('br'));
                }
                start = cell;
                Table_Table.addSelected(cell);
                this.__selectMode = true;
            }
        })
            .on(table, 'mouseleave.table', (e) => {
            if (this.__resizerHandler &&
                this.__resizerHandler !== e.relatedTarget) {
                this.hideResizer();
            }
        })
            .on(table, 'mousemove.table touchmove.table', (event) => {
            if (this.jodit.options.readonly) {
                return;
            }
            if (this.__drag || this.jodit.isLockedNotBy(this.__key)) {
                return;
            }
            const cell = Dom_Dom.up(event.target, table_TableProcessor.isCell, table);
            if (cell) {
                if (this.__selectMode) {
                    if (cell !== start) {
                        this.jodit.lock(this.__key);
                        const sel = this.jodit.selection.sel;
                        sel && sel.removeAllRanges();
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                    }
                    this.__deSelectAll(table);
                    const bound = Table_Table.getSelectedBound(table, [
                        cell,
                        start
                    ]), box = Table_Table.formalMatrix(table);
                    for (let i = bound[0][0]; i <= bound[1][0]; i += 1) {
                        for (let j = bound[0][1]; j <= bound[1][1]; j += 1) {
                            Table_Table.addSelected(box[i][j]);
                        }
                    }
                    const max = box[bound[1][0]][bound[1][1]], min = box[bound[0][0]][bound[0][1]];
                    this.jodit.events.fire('showPopup', table, () => {
                        const minOffset = offset(min, this.jodit, this.jodit.editorDocument);
                        const maxOffset = offset(max, this.jodit, this.jodit.editorDocument);
                        return {
                            left: minOffset.left,
                            top: minOffset.top,
                            width: maxOffset.left -
                                minOffset.left +
                                maxOffset.width,
                            height: maxOffset.top -
                                minOffset.top +
                                maxOffset.height
                        };
                    });
                    event.stopPropagation();
                }
                else {
                    this.__calcResizerPosition(table, cell, event.offsetX);
                }
            }
        });
        this.__addResizer();
    }
    afterInit(editor) {
        if (!editor.options.useTableProcessor) {
            return;
        }
        editor.events
            .off(this.jodit.ownerWindow, '.table')
            .off('.table')
            .on(this.jodit.ownerWindow, 'mouseup.table touchend.table', () => {
            if (this.__selectMode || this.__drag) {
                this.__selectMode = false;
                this.jodit.unlock();
            }
            if (this.__resizerHandler && this.__drag) {
                this.__drag = false;
                this.__resizerHandler.classList.remove('jodit_table_resizer-moved');
                if (this.__wholeTable === null) {
                    const __marked = [];
                    Table_Table.setColumnWidthByDelta(this.__workTable, Table_Table.formalCoordinate(this.__workTable, this.__workCell, true)[1], this.__resizerDelta, true, __marked);
                    const nextTD = Dom_Dom.next(this.__workCell, table_TableProcessor.isCell, this.__workCell.parentNode);
                    Table_Table.setColumnWidthByDelta(this.__workTable, Table_Table.formalCoordinate(this.__workTable, nextTD)[1], -this.__resizerDelta, false, __marked);
                }
                else {
                    const width = this.__workTable.offsetWidth, parentWidth = getContentWidth(this.__workTable.parentNode, this.jodit.editorWindow);
                    if (!this.__wholeTable) {
                        this.__workTable.style.width =
                            ((width + this.__resizerDelta) / parentWidth) *
                                100 +
                                '%';
                    }
                    else {
                        const margin = parseInt(this.jodit.editorWindow.getComputedStyle(this.__workTable).marginLeft || '0', 10);
                        this.__workTable.style.width =
                            ((width - this.__resizerDelta) / parentWidth) *
                                100 +
                                '%';
                        this.__workTable.style.marginLeft =
                            ((margin + this.__resizerDelta) / parentWidth) *
                                100 +
                                '%';
                    }
                }
                editor.setEditorValue();
                editor.selection.focus();
            }
        })
            .on(this.jodit.ownerWindow, 'scroll.table', () => {
            if (this.__drag) {
                const parent = Dom_Dom.up(this.__workCell, (elm) => elm && elm.nodeName === 'TABLE', editor.editor);
                if (parent) {
                    const parentBox = parent.getBoundingClientRect();
                    this.__resizerHandler.style.top = parentBox.top + 'px';
                }
            }
        })
            .on(this.jodit.ownerWindow, 'mousedown.table touchend.table', (event) => {
            const current_cell = Dom_Dom.closest(event.originalEvent.target, 'TD|TH', this.jodit.editor);
            let table = null;
            if (current_cell instanceof
                this.jodit.editorWindow.HTMLTableCellElement) {
                table = Dom_Dom.closest(current_cell, 'table', this.jodit.editor);
            }
            if (table) {
                this.__deSelectAll(table, current_cell instanceof
                    this.jodit.editorWindow
                        .HTMLTableCellElement
                    ? current_cell
                    : false);
            }
            else {
                this.__deSelectAll();
            }
        })
            .on('afterGetValueFromEditor.table', (data) => {
            const rxp = new RegExp(`([\s]*)${JODIT_SELECTED_CELL_MARKER}="1"`, 'g');
            if (rxp.test(data.value)) {
                data.value = data.value.replace(rxp, '');
            }
        })
            .on('change.table afterCommand.table afterSetMode.table', () => {
            $$('table', editor.editor).forEach((table) => {
                if (!table[this.__key]) {
                    this.observe(table);
                }
            });
        })
            .on('beforeSetMode.table', () => {
            Table_Table.getAllSelectedCells(editor.editor).forEach(td => {
                Table_Table.restoreSelection(td);
                Table_Table.normalizeTable(Dom_Dom.closest(td, 'table', editor.editor));
            });
        })
            .on('keydown.table', (event) => {
            if (event.which === KEY_TAB) {
                $$('table', editor.editor).forEach((table) => {
                    this.__deSelectAll(table);
                });
            }
        })
            .on('beforeCommand.table', this.onExecCommand.bind(this));
    }
    beforeDestruct(jodit) {
        if (jodit.events) {
            jodit.events.off(this.jodit.ownerWindow, '.table');
            jodit.events.off('.table');
        }
    }
}

// CONCATENATED MODULE: ./src/plugins/tooltip.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




class tooltip_tooltip extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.isOpened = false;
    }
    afterInit(jodit) {
        this.container = jodit.create.div('jodit_tooltip');
        this.jodit.ownerDocument.body.appendChild(this.container);
        let timeout = 0;
        jodit.events
            .off('.tooltip')
            .on('showTooltip.tooltip', (target, content) => {
            jodit.async.clearTimeout(timeout);
            this.open(target, content);
        })
            .on('hideTooltip.tooltip change.tooltip updateToolbar.tooltip scroll.tooltip changePlace.tooltip hidePopup.tooltip closeAllPopups.tooltip', () => {
            timeout = jodit.async.setTimeout(() => this.close(), this.jodit.defaultTimeout);
        });
    }
    beforeDestruct(jodit) {
        var _a;
        (_a = jodit) === null || _a === void 0 ? void 0 : _a.events.off('.tooltip');
        this.close();
        Dom_Dom.safeRemove(this.container);
    }
    open(target, content) {
        this.container.classList.add('jodit_tooltip_visible');
        this.container.innerHTML = content;
        this.isOpened = true;
        this.calcPosition(target);
    }
    calcPosition(target) {
        const bound = offset(target, this.jodit, this.jodit.ownerDocument, true);
        css_css(this.container, {
            left: bound.left - this.container.offsetWidth / 2 + bound.width / 2,
            top: bound.top + bound.height,
            position: null
        });
    }
    close() {
        if (this.isOpened) {
            this.isOpened = false;
            this.container.classList.remove('jodit_tooltip_visible');
            css_css(this.container, {
                left: -5000,
                position: 'fixed'
            });
        }
    }
}

// CONCATENATED MODULE: ./src/plugins/xpath.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */









Config_Config.prototype.controls.selectall = {
    icon: 'select-all',
    command: 'selectall',
    tooltip: 'Select all'
};
Config_Config.prototype.showXPathInStatusbar = true;
class xpath_xpath extends Plugin_Plugin {
    constructor() {
        super(...arguments);
        this.onContext = (bindElement, event) => {
            if (!this.menu) {
                this.menu = new ContextMenu_ContextMenu(this.jodit);
            }
            this.menu.show(event.clientX, event.clientY, [
                {
                    icon: 'bin',
                    title: bindElement === this.jodit.editor ? 'Clear' : 'Remove',
                    exec: () => {
                        if (bindElement !== this.jodit.editor) {
                            Dom_Dom.safeRemove(bindElement);
                        }
                        else {
                            this.jodit.value = '';
                        }
                        this.jodit.setEditorValue();
                    }
                },
                {
                    icon: 'select-all',
                    title: 'Select',
                    exec: () => {
                        this.jodit.selection.select(bindElement);
                    }
                }
            ]);
            return false;
        };
        this.onSelectPath = (bindElement, event) => {
            this.jodit.selection.focus();
            const path = event.target.getAttribute('data-path') || '/';
            if (path === '/') {
                this.jodit.execCommand('selectall');
                return false;
            }
            try {
                const elm = this.jodit.editorDocument
                    .evaluate(path, this.jodit.editor, null, XPathResult.ANY_TYPE, null)
                    .iterateNext();
                if (elm) {
                    this.jodit.selection.select(elm);
                    return false;
                }
            }
            catch (_a) { }
            this.jodit.selection.select(bindElement);
            return false;
        };
        this.tpl = (bindElement, path, name, title) => {
            const li = this.jodit.create.fromHTML(`<li><a role="button" data-path="${path}" href="javascript:void(0)" title="${title}" tabindex="-1"'>${trim(name)}</a></li>`);
            const a = li.firstChild;
            this.jodit.events
                .on(a, 'click', this.onSelectPath.bind(this, bindElement))
                .on(a, 'contextmenu', this.onContext.bind(this, bindElement));
            return li;
        };
        this.removeSelectAll = () => {
            if (this.selectAllButton) {
                this.selectAllButton.destruct();
                delete this.selectAllButton;
            }
        };
        this.appendSelectAll = () => {
            this.removeSelectAll();
            this.selectAllButton = new button_ToolbarButton(this.jodit, {
                name: 'selectall',
                ...this.jodit.options.controls.selectall
            });
            this.container &&
                this.container.insertBefore(this.selectAllButton.container, this.container.firstChild);
        };
        this.calcPathImd = () => {
            if (this.isDestructed) {
                return;
            }
            const current = this.jodit.selection.current();
            if (this.container) {
                this.container.innerHTML = INVISIBLE_SPACE;
            }
            if (current) {
                let name, xpth, li;
                Dom_Dom.up(current, (elm) => {
                    if (elm &&
                        this.jodit.editor !== elm &&
                        elm.nodeType !== Node.TEXT_NODE) {
                        name = elm.nodeName.toLowerCase();
                        xpth = getXPathByElement(elm, this.jodit.editor).replace(/^\//, '');
                        li = this.tpl(elm, xpth, name, this.jodit.i18n('Select %s', name));
                        this.container &&
                            this.container.insertBefore(li, this.container.firstChild);
                    }
                }, this.jodit.editor);
            }
            this.appendSelectAll();
        };
        this.calcPath = debounce(this.calcPathImd, this.jodit.defaultTimeout * 2);
        this.menu = null;
    }
    afterInit() {
        if (this.jodit.options.showXPathInStatusbar) {
            this.container = this.jodit.create.element('ul');
            this.container.classList.add('jodit_xpath');
            this.jodit.events
                .off('.xpath')
                .on('mouseup.xpath change.xpath keydown.xpath changeSelection.xpath', this.calcPath)
                .on('afterSetMode.xpath afterInit.xpath changePlace.xpath', () => {
                this.jodit.statusbar.append(this.container);
                if (this.jodit.getRealMode() === MODE_WYSIWYG) {
                    this.calcPath();
                }
                else {
                    if (this.container) {
                        this.container.innerHTML = INVISIBLE_SPACE;
                    }
                    this.appendSelectAll();
                }
            });
            this.calcPath();
        }
    }
    beforeDestruct() {
        if (this.jodit && this.jodit.events) {
            this.jodit.events.off('.xpath');
        }
        this.removeSelectAll();
        this.menu && this.menu.destruct();
        Dom_Dom.safeRemove(this.container);
        delete this.menu;
        delete this.container;
    }
}

// CONCATENATED MODULE: ./src/plugins/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */








































// CONCATENATED MODULE: ./src/modules/dialog/dialog.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */




Config_Config.prototype.dialog = {
    extraButtons: [],
    resizable: true,
    draggable: true,
    buttons: ['dialog.close'],
    removeButtons: []
};
Config_Config.prototype.controls.dialog = {
    close: {
        icon: 'cancel',
        exec: dialog => {
            dialog.close();
        }
    },
    fullsize: {
        icon: 'fullsize',
        getLabel: (editor, btn, button) => {
            if (Config_Config.prototype.controls.fullsize &&
                Config_Config.prototype.controls.fullsize.getLabel &&
                typeof Config_Config.prototype.controls.fullsize.getLabel ===
                    'function') {
                return Config_Config.prototype.controls.fullsize.getLabel(editor, btn, button);
            }
            return;
        },
        exec: dialog => {
            dialog.toggleFullSize();
        }
    }
};
class dialog_Dialog extends viewWithToolbar_ViewWithToolbar {
    constructor(jodit, options = Config_Config.prototype.dialog) {
        super(jodit, options);
        this.destination = document.body;
        this.destroyAfterClose = false;
        this.moved = false;
        this.iSetMaximization = false;
        this.resizable = false;
        this.draggable = false;
        this.startX = 0;
        this.startY = 0;
        this.startPoint = { x: 0, y: 0, w: 0, h: 0 };
        this.lockSelect = () => {
            this.container.classList.add('jodit_dialog_box-moved');
        };
        this.unlockSelect = () => {
            this.container.classList.remove('jodit_dialog_box-moved');
        };
        this.onMouseUp = () => {
            if (this.draggable || this.resizable) {
                this.draggable = false;
                this.resizable = false;
                this.unlockSelect();
                if (this.jodit && this.jodit.events) {
                    this.jodit.events.fire(this, 'endResize endMove');
                }
            }
        };
        this.onHeaderMouseDown = (e) => {
            const target = e.target;
            if (!this.options.draggable ||
                (target && target.nodeName.match(/^(INPUT|SELECT)$/))) {
                return;
            }
            this.draggable = true;
            this.startX = e.clientX;
            this.startY = e.clientY;
            this.startPoint.x = css_css(this.dialog, 'left');
            this.startPoint.y = css_css(this.dialog, 'top');
            this.setMaxZIndex();
            e.preventDefault();
            this.lockSelect();
            if (this.jodit && this.jodit.events) {
                this.jodit.events.fire(this, 'startMove');
            }
        };
        this.onMouseMove = (e) => {
            if (this.draggable && this.options.draggable) {
                this.setPosition(this.startPoint.x + e.clientX - this.startX, this.startPoint.y + e.clientY - this.startY);
                if (this.jodit && this.jodit.events) {
                    this.jodit.events.fire(this, 'move', e.clientX - this.startX, e.clientY - this.startY);
                }
                e.stopImmediatePropagation();
                e.preventDefault();
            }
            if (this.resizable && this.options.resizable) {
                this.setSize(this.startPoint.w + e.clientX - this.startX, this.startPoint.h + e.clientY - this.startY);
                if (this.jodit && this.jodit.events) {
                    this.jodit.events.fire(this, 'resizeDialog', e.clientX - this.startX, e.clientY - this.startY);
                }
                e.stopImmediatePropagation();
                e.preventDefault();
            }
        };
        this.onKeyDown = (e) => {
            if (this.isOpened() && e.which === KEY_ESC) {
                const me = this.getMaxZIndexDialog();
                if (me) {
                    me.close();
                }
                else {
                    this.close();
                }
                e.stopImmediatePropagation();
            }
        };
        this.onResize = () => {
            if (this.options &&
                this.options.resizable &&
                !this.moved &&
                this.isOpened() &&
                !this.offsetX &&
                !this.offsetY) {
                this.setPosition();
            }
        };
        this.document = document;
        this.window = window;
        this.close = (e) => {
            if (this.isDestructed) {
                return;
            }
            if (e) {
                e.stopImmediatePropagation();
                e.preventDefault();
            }
            if (this.jodit && this.jodit.events) {
                this.jodit.events.fire('beforeClose', this);
            }
            this.container &&
                this.container.classList &&
                this.container.classList.remove('active');
            if (this.iSetMaximization) {
                this.maximization(false);
            }
            if (this.destroyAfterClose) {
                this.destruct();
            }
            if (this.jodit && this.jodit.events) {
                this.jodit.events.fire(this, 'afterClose');
                this.jodit.events.fire(this.ownerWindow, 'jodit_close_dialog');
            }
        };
        if (isJoditObject(jodit)) {
            this.window = jodit.ownerWindow;
            this.document = jodit.ownerDocument;
            jodit.events.on('beforeDestruct', () => {
                this.destruct();
            });
        }
        const self = this;
        const opt = jodit && jodit.options
            ? jodit.options.dialog
            : Config_Config.prototype.dialog;
        self.options = { ...opt, ...self.options };
        self.container = this.create.fromHTML('<div style="z-index:' +
            self.options.zIndex +
            '" class="jodit jodit_dialog_box">' +
            '<div class="jodit_dialog_overlay"></div>' +
            '<div class="jodit_dialog">' +
            '<div class="jodit_dialog_header non-selected">' +
            '<div class="jodit_dialog_header-title"></div>' +
            '<div class="jodit_dialog_header-toolbar"></div>' +
            '</div>' +
            '<div class="jodit_dialog_content"></div>' +
            '<div class="jodit_dialog_footer"></div>' +
            (self.options.resizable
                ? '<div class="jodit_dialog_resizer"></div>'
                : '') +
            '</div>' +
            '</div>');
        if (jodit && jodit.id) {
            jodit.markOwner(self.container);
        }
        Object.defineProperty(self.container, '__jodit_dialog', {
            value: self
        });
        self.dialog = self.container.querySelector('.jodit_dialog');
        self.resizer = self.container.querySelector('.jodit_dialog_resizer');
        if (self.jodit && self.jodit.options && self.jodit.options.textIcons) {
            self.container.classList.add('jodit_text_icons');
        }
        self.dialogbox_header = self.container.querySelector('.jodit_dialog_header>.jodit_dialog_header-title');
        self.dialogbox_content = self.container.querySelector('.jodit_dialog_content');
        self.dialogbox_footer = self.container.querySelector('.jodit_dialog_footer');
        self.dialogbox_toolbar = self.container.querySelector('.jodit_dialog_header>.jodit_dialog_header-toolbar');
        self.destination.appendChild(self.container);
        self.container.addEventListener('close_dialog', self.close);
        self.toolbar.build(self.options.buttons, self.dialogbox_toolbar);
        self.events
            .on(this.window, 'mousemove', self.onMouseMove)
            .on(this.window, 'mouseup', self.onMouseUp)
            .on(this.window, 'keydown', self.onKeyDown)
            .on(this.window, 'resize', self.onResize);
        const headerBox = self.container.querySelector('.jodit_dialog_header');
        headerBox &&
            headerBox.addEventListener('mousedown', self.onHeaderMouseDown.bind(self));
        if (self.options.resizable) {
            self.resizer.addEventListener('mousedown', self.onResizerMouseDown.bind(self));
        }
        fullsize(self);
    }
    setElements(root, elements) {
        const elements_list = [];
        asArray(elements).forEach((elm) => {
            if (Array.isArray(elm)) {
                const div = this.create.div('jodit_dialog_column');
                elements_list.push(div);
                root.appendChild(div);
                return this.setElements(div, elm);
            }
            const element = typeof elm === 'string' ? this.create.fromHTML(elm) : elm;
            elements_list.push(element);
            if (element.parentNode !== root) {
                root.appendChild(element);
            }
        });
        Array.from(root.childNodes).forEach((elm) => {
            if (elements_list.indexOf(elm) === -1) {
                root.removeChild(elm);
            }
        });
    }
    onResizerMouseDown(e) {
        this.resizable = true;
        this.startX = e.clientX;
        this.startY = e.clientY;
        this.startPoint.w = this.dialog.offsetWidth;
        this.startPoint.h = this.dialog.offsetHeight;
        this.lockSelect();
        if (this.jodit.events) {
            this.jodit.events.fire(this, 'startResize');
        }
    }
    setSize(w, h) {
        if (w) {
            css_css(this.dialog, 'width', w);
        }
        if (h) {
            css_css(this.dialog, 'height', h);
        }
    }
    setPosition(x, y) {
        const w = this.window.innerWidth, h = this.window.innerHeight;
        let left = w / 2 - this.dialog.offsetWidth / 2, top = h / 2 - this.dialog.offsetHeight / 2;
        if (left < 0) {
            left = 0;
        }
        if (top < 0) {
            top = 0;
        }
        if (x !== undefined && y !== undefined) {
            this.offsetX = x;
            this.offsetY = y;
            this.moved = Math.abs(x - left) > 100 || Math.abs(y - top) > 100;
        }
        this.dialog.style.left = (x || left) + 'px';
        this.dialog.style.top = (y || top) + 'px';
    }
    setTitle(content) {
        this.setElements(this.dialogbox_header, content);
    }
    setContent(content) {
        this.setElements(this.dialogbox_content, content);
    }
    setFooter(content) {
        this.setElements(this.dialogbox_footer, content);
        this.dialog.classList.toggle('with_footer', !!content);
    }
    getZIndex() {
        return parseInt(this.container.style.zIndex || '0', 10);
    }
    getMaxZIndexDialog() {
        let maxzi = 0, dlg, zIndex, res = this;
        $$('.jodit_dialog_box', this.destination).forEach((dialog) => {
            dlg = dialog.__jodit_dialog;
            zIndex = parseInt(css_css(dialog, 'zIndex'), 10);
            if (dlg.isOpened() && !isNaN(zIndex) && zIndex > maxzi) {
                res = dlg;
                maxzi = zIndex;
            }
        });
        return res;
    }
    setMaxZIndex() {
        let maxzi = 0, zIndex = 0;
        $$('.jodit_dialog_box', this.destination).forEach(dialog => {
            zIndex = parseInt(css_css(dialog, 'zIndex'), 10);
            maxzi = Math.max(isNaN(zIndex) ? 0 : zIndex, maxzi);
        });
        this.container.style.zIndex = (maxzi + 1).toString();
    }
    maximization(condition) {
        if (typeof condition !== 'boolean') {
            condition = !this.container.classList.contains('jodit_dialog_box-fullsize');
        }
        this.container.classList.toggle('jodit_dialog_box-fullsize', condition);
        [this.destination, this.destination.parentNode].forEach((box) => {
            box &&
                box.classList &&
                box.classList.toggle('jodit_fullsize_box', condition);
        });
        this.iSetMaximization = condition;
        return condition;
    }
    open(content, title, destroyAfter, modal) {
        if (this.jodit && this.jodit.events) {
            if (this.jodit.events.fire(this, 'beforeOpen') === false) {
                return;
            }
        }
        this.destroyAfterClose = destroyAfter === true;
        if (title !== undefined) {
            this.setTitle(title);
        }
        if (content) {
            this.setContent(content);
        }
        this.container.classList.add('active');
        if (modal) {
            this.container.classList.add('jodit_modal');
        }
        this.setPosition(this.offsetX, this.offsetY);
        this.setMaxZIndex();
        if (this.options.fullsize) {
            this.maximization(true);
        }
        if (this.jodit && this.jodit.events) {
            this.jodit.events.fire('afterOpen', this);
        }
    }
    isOpened() {
        return (!this.isDestructed &&
            this.container &&
            this.container.classList.contains('active'));
    }
    destruct() {
        if (this.isInDestruct) {
            return;
        }
        if (this.events) {
            this.events
                .off(this.window, 'mousemove', this.onMouseMove)
                .off(this.window, 'mouseup', this.onMouseUp)
                .off(this.window, 'keydown', this.onKeyDown)
                .off(this.window, 'resize', this.onResize);
        }
        super.destruct();
    }
}


// CONCATENATED MODULE: ./src/modules/dialog/alert.ts


const Alert = (msg, title, callback, className = 'jodit_alert') => {
    if (typeof title === 'function') {
        callback = title;
        title = undefined;
    }
    const dialog = new dialog_Dialog(), container = dialog.create.div(className), okButton = dialog.create.fromHTML('<a href="javascript:void(0)" style="float:right;" class="jodit_button">' +
        ToolbarIcon.getIcon('cancel') +
        '<span>' +
        Jodit_Jodit.prototype.i18n('Ok') +
        '</span></a>');
    asArray(msg).forEach(oneMessage => {
        container.appendChild(Dom_Dom.isNode(oneMessage, dialog.window)
            ? oneMessage
            : dialog.create.fromHTML(oneMessage));
    });
    okButton.addEventListener('click', () => {
        if (!callback ||
            typeof callback !== 'function' ||
            callback(dialog) !== false) {
            dialog.close();
        }
    });
    dialog.setFooter([okButton]);
    dialog.open(container, title || '&nbsp;', true, true);
    okButton.focus();
    return dialog;
};




// CONCATENATED MODULE: ./src/modules/dialog/promt.ts


const Promt = (msg, title, callback, placeholder, defaultValue) => {
    const dialog = new dialog_Dialog(), cancelButton = dialog.create.fromHTML('<a href="javascript:void(0)" style="float:right;" class="jodit_button">' +
        ToolbarIcon.getIcon('cancel') +
        '<span>' +
        Jodit_Jodit.prototype.i18n('Cancel') +
        '</span></a>'), okButton = dialog.create.fromHTML('<a href="javascript:void(0)" style="float:left;" class="jodit_button">' +
        ToolbarIcon.getIcon('check') +
        '<span>' +
        Jodit_Jodit.prototype.i18n('Ok') +
        '</span></a>'), form = dialog.create.element('form', {
        class: 'jodit_prompt'
    }), inputElement = dialog.create.element('input', {
        autofocus: true,
        class: 'jodit_input'
    }), labelElement = dialog.create.element('label');
    if (typeof title === 'function') {
        callback = title;
        title = undefined;
    }
    if (placeholder) {
        inputElement.setAttribute('placeholder', placeholder);
    }
    labelElement.appendChild(dialog.create.text(msg));
    form.appendChild(labelElement);
    form.appendChild(inputElement);
    cancelButton.addEventListener('click', dialog.close, false);
    const onclick = () => {
        if (!callback ||
            typeof callback !== 'function' ||
            callback(inputElement.value) !== false) {
            dialog.close();
        }
    };
    okButton.addEventListener('click', onclick);
    form.addEventListener('submit', () => {
        onclick();
        return false;
    });
    dialog.setFooter([okButton, cancelButton]);
    dialog.open(form, title || '&nbsp;', true, true);
    inputElement.focus();
    if (defaultValue !== undefined && defaultValue.length) {
        inputElement.value = defaultValue;
        inputElement.select();
    }
    return dialog;
};


// CONCATENATED MODULE: ./src/modules/dialog/confirm.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */


const Confirm = (msg, title, callback) => {
    const dialog = new dialog_Dialog(), $div = dialog.create.fromHTML('<form class="jodit_prompt"></form>'), $label = dialog.create.element('label');
    if (typeof title === 'function') {
        callback = title;
        title = undefined;
    }
    $label.appendChild(dialog.create.fromHTML(msg));
    $div.appendChild($label);
    const $cancel = dialog.create.fromHTML('<a href="javascript:void(0)" style="float:right;" class="jodit_button">' +
        ToolbarIcon.getIcon('cancel') +
        '<span>' +
        Jodit_Jodit.prototype.i18n('Cancel') +
        '</span>' +
        '</a>');
    $cancel.addEventListener('click', () => {
        if (callback) {
            callback(false);
        }
        dialog.close();
    });
    const onok = () => {
        if (callback) {
            callback(true);
        }
        dialog.close();
    };
    const $ok = dialog.create.fromHTML('<a href="javascript:void(0)" style="float:left;" class="jodit_button">' +
        ToolbarIcon.getIcon('check') +
        '<span>' +
        Jodit_Jodit.prototype.i18n('Yes') +
        '</span>' +
        '</a>');
    $ok.addEventListener('click', onok);
    $div.addEventListener('submit', () => {
        onok();
        return false;
    });
    dialog.setFooter([$ok, $cancel]);
    dialog.open($div, title || '&nbsp;', true, true);
    $ok.focus();
    return dialog;
};


// CONCATENATED MODULE: ./src/modules/dialog/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





// CONCATENATED MODULE: ./src/modules/filebrowser/consts.ts
const F_CLASS = 'jodit_filebrowser';
const ITEM_CLASS = F_CLASS + '_files_item';
const ICON_LOADER = '<i class="jodit_icon-loader"></i>';

// CONCATENATED MODULE: ./src/modules/filebrowser/config.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */





Config_Config.prototype.filebrowser = {
    extraButtons: [],
    filter(item, search) {
        search = search.toLowerCase();
        if (typeof item === 'string') {
            return item.toLowerCase().indexOf(search) !== -1;
        }
        if ('string' === typeof item.name) {
            return item.name.toLowerCase().indexOf(search) !== -1;
        }
        if ('string' === typeof item.file) {
            return item.file.toLowerCase().indexOf(search) !== -1;
        }
        return true;
    },
    sortBy: 'changed-desc',
    sort(a, b, sortBy) {
        const [sortAttr, arrow] = sortBy.toLowerCase().split('-'), asc = arrow === 'asc';
        const compareStr = (f, s) => {
            if (f < s) {
                return asc ? -1 : 1;
            }
            if (f > s) {
                return asc ? 1 : -1;
            }
            return 0;
        };
        if (typeof a === 'string') {
            return compareStr(a.toLowerCase(), b.toLowerCase());
        }
        if (a[sortAttr] === undefined || sortAttr === 'name') {
            if (typeof a.name === 'string') {
                return compareStr(a.name.toLowerCase(), b.name.toLowerCase());
            }
            if (typeof a.file === 'string') {
                return compareStr(a.file.toLowerCase(), b.file.toLowerCase());
            }
            return 0;
        }
        switch (sortAttr) {
            case 'changed': {
                const f = new Date(a.changed).getTime(), s = new Date(b.changed).getTime();
                return asc ? f - s : s - f;
            }
            case 'size': {
                const f = humanSizeToBytes(a.size), s = humanSizeToBytes(b.size);
                return asc ? f - s : s - f;
            }
        }
        return 0;
    },
    editImage: true,
    preview: true,
    showPreviewNavigation: true,
    showSelectButtonInPreview: true,
    contextMenu: true,
    howLongShowMsg: 3000,
    createNewFolder: true,
    deleteFolder: true,
    moveFolder: true,
    moveFile: true,
    showFoldersPanel: true,
    width: 859,
    height: 400,
    buttons: [
        'filebrowser.upload',
        'filebrowser.remove',
        'filebrowser.update',
        'filebrowser.select',
        'filebrowser.edit',
        '|',
        'filebrowser.tiles',
        'filebrowser.list',
        '|',
        'filebrowser.filter',
        '|',
        'filebrowser.sort'
    ],
    removeButtons: [],
    fullsize: false,
    showTooltip: true,
    view: null,
    isSuccess(resp) {
        return resp.success;
    },
    getMessage(resp) {
        return resp.data.messages !== undefined &&
            Array.isArray(resp.data.messages)
            ? resp.data.messages.join(' ')
            : '';
    },
    showFileName: true,
    showFileSize: true,
    showFileChangeTime: true,
    saveStateInStorage: true,
    getThumbTemplate(item, source, source_name) {
        const opt = this.options, showName = opt.showFileName, showSize = opt.showFileSize && item.size, showTime = opt.showFileChangeTime && item.time;
        let name = '', info;
        if (item.file !== undefined) {
            name = item.file;
        }
        info = `<div class="${ITEM_CLASS}-info">${showName ? `<span class="${ITEM_CLASS}-info-filename">${name}</span>` : ''}${showSize
            ? `<span class="${ITEM_CLASS}-info-filesize">${item.size}</span>`
            : ''}${showTime
            ? `<span class="${ITEM_CLASS}-info-filechanged">${showTime}</span>`
            : ''}</div>`;
        return `<a
			data-is-file="${item.isImage ? 0 : 1}"
			draggable="true"
			class="${ITEM_CLASS}"
			href="${item.fileURL}"
			data-source="${source_name}"
			data-path="${item.path}"
			data-name="${name}"
			title="${name}"
			data-url="${item.fileURL}">
				<img
					data-is-file="${item.isImage ? 0 : 1}"
					data-src="${item.fileURL}"
					src="${item.imageURL}"
					alt="${name}"
					loading="lazy"
				/>
				${showName || showSize || showTime ? info : ''}
			</a>`;
    },
    ajax: {
        url: '',
        async: true,
        data: {},
        cache: true,
        contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
        method: 'POST',
        processData: true,
        dataType: 'json',
        headers: {},
        prepareData(data) {
            return data;
        },
        process(resp) {
            return resp;
        }
    },
    create: {
        data: { action: 'folderCreate' }
    },
    getLocalFileByUrl: {
        data: { action: 'getLocalFileByUrl' }
    },
    resize: {
        data: { action: 'imageResize' }
    },
    crop: {
        data: { action: 'imageCrop' }
    },
    fileMove: {
        data: { action: 'fileMove' }
    },
    folderMove: {
        data: { action: 'folderMove' }
    },
    fileRename: {
        data: { action: 'fileRename' }
    },
    folderRename: {
        data: { action: 'folderRename' }
    },
    fileRemove: {
        data: { action: 'fileRemove' }
    },
    folderRemove: {
        data: { action: 'folderRemove' }
    },
    items: {
        data: { action: 'files' }
    },
    folder: {
        data: { action: 'folders' }
    },
    permissions: {
        data: { action: 'permissions' }
    },
    uploader: null
};
Config_Config.prototype.controls.filebrowser = {
    upload: {
        icon: 'plus',
        isInput: true,
        exec: () => {
        },
        isDisable: (browser) => !browser.dataProvider.canI('FileUpload'),
        getContent: (filebrowser, control) => {
            const btn = filebrowser.create.fromHTML('<span class="jodit_upload_button">' +
                ToolbarIcon.getIcon('plus') +
                '<input type="file" accept="' +
                (filebrowser.state.onlyImages ? 'image/*' : '*') +
                '" tabindex="-1" dir="auto" multiple=""/>' +
                '</span>'), input = btn.querySelector('input');
            filebrowser.events
                .on('updateToolbar', () => {
                if (control && control.isDisable) {
                    control.isDisable(filebrowser, control)
                        ? input.setAttribute('disabled', 'disabled')
                        : input.removeAttribute('disabled');
                }
            })
                .fire('bindUploader.filebrowser', btn);
            return btn;
        }
    },
    remove: {
        icon: 'bin',
        isDisable: (browser) => {
            return (!browser.state.activeElements.length ||
                !browser.dataProvider.canI('FileRemove'));
        },
        exec: (editor) => {
            editor.events.fire('fileRemove.filebrowser');
        }
    },
    update: {
        exec: (editor) => {
            editor.events.fire('update.filebrowser');
        }
    },
    select: {
        icon: 'check',
        isDisable: (browser) => !browser.state.activeElements.length,
        exec: (editor) => {
            editor.events.fire('select.filebrowser');
        }
    },
    edit: {
        icon: 'pencil',
        isDisable: (browser) => {
            const selected = browser.state.activeElements;
            return (selected.length !== 1 ||
                !selected[0].isImage ||
                !(browser.dataProvider.canI('ImageCrop') ||
                    browser.dataProvider.canI('ImageResize')));
        },
        exec: editor => {
            editor.events.fire('edit.filebrowser');
        }
    },
    tiles: {
        icon: 'th',
        isActive: (filebrowser) => filebrowser.state.view === 'tiles',
        exec: (filebrowser) => {
            filebrowser.events.fire('view.filebrowser', 'tiles');
        }
    },
    list: {
        icon: 'th-list',
        isActive: (filebrowser) => filebrowser.state.view === 'list',
        exec: (filebrowser) => {
            filebrowser.events.fire('view.filebrowser', 'list');
        }
    },
    filter: {
        isInput: true,
        getContent: (filebrowser) => {
            const input = filebrowser.create.element('input', {
                class: 'jodit_input',
                placeholder: filebrowser.i18n('Filter')
            });
            filebrowser.events.on(input, 'keydown mousedown', debounce(() => {
                filebrowser.events.fire('filter.filebrowser', input.value);
            }, filebrowser.defaultTimeout));
            return input;
        }
    },
    sort: {
        isInput: true,
        getContent: (fb) => {
            const select = fb.create.fromHTML('<select class="jodit_input jodit_select">' +
                `<option value="changed-asc">${fb.i18n('Sort by changed')} (â¬)</option>` +
                `<option value="changed-desc">${fb.i18n('Sort by changed')} (â¬)</option>` +
                `<option value="name-asc">${fb.i18n('Sort by name')} (â¬)</option>` +
                `<option value="name-desc">${fb.i18n('Sort by name')} (â¬)</option>` +
                `<option value="size-asc">${fb.i18n('Sort by size')} (â¬)</option>` +
                `<option value="size-desc">${fb.i18n('Sort by size')} (â¬)</option>` +
                '</select>');
            fb.events
                .on('sort.filebrowser', (value) => {
                if (select.value !== value) {
                    select.value = value;
                }
            })
                .on(select, 'change', () => {
                fb.events.fire('sort.filebrowser', select.value);
            });
            return select;
        }
    }
};

// CONCATENATED MODULE: ./src/modules/filebrowser/dataProvider.ts


const DEFAULT_SOURCE_NAME = 'default';
const possableRules = [
    'allowFiles',
    'allowFileMove',
    'allowFileUpload',
    'allowFileUploadRemote',
    'allowFileRemove',
    'allowFileRename',
    'allowFolders',
    'allowFolderMove',
    'allowFolderCreate',
    'allowFolderRemove',
    'allowFolderRename',
    'allowImageResize',
    'allowImageCrop'
];
class dataProvider_dataProvider {
    constructor(options, parent) {
        this.options = options;
        this.parent = parent;
        this.__currentPermissions = null;
        this.currentPath = '';
        this.currentSource = DEFAULT_SOURCE_NAME;
        this.currentBaseUrl = '';
        this.getPathByUrl = (url, success, onFailed) => {
            const action = 'getLocalFileByUrl';
            this.options[action].data.url = url;
            return this.get(action, (resp) => {
                if (this.options.isSuccess(resp)) {
                    success(resp.data.path, resp.data.name, resp.data.source);
                }
                else {
                    onFailed(type_error(this.options.getMessage(resp)));
                }
            }, onFailed);
        };
    }
    canI(action) {
        const rule = 'allow' + action;
        if (false) {}
        return (this.__currentPermissions === null ||
            this.__currentPermissions[rule] === undefined ||
            this.__currentPermissions[rule]);
    }
    get(name, success, error) {
        const opts = extend(true, {}, this.options.ajax, this.options[name] !== undefined
            ? this.options[name]
            : this.options.ajax);
        if (opts.prepareData) {
            opts.data = opts.prepareData.call(this, opts.data);
        }
        const ajax = new Ajax_Ajax(this.parent, opts);
        const promise = ajax.send();
        if (success) {
            promise.then(success);
        }
        if (error) {
            promise.catch(error);
        }
        return promise;
    }
    async permissions(path = this.currentPath, source = this.currentSource) {
        if (!this.options.permissions) {
            return Promise.resolve();
        }
        this.options.permissions.data.path = path;
        this.options.permissions.data.source = source;
        if (this.options.permissions.url) {
            return this.get('permissions').then(resp => {
                let process = this.options.permissions.process;
                if (!process) {
                    process = this.options.ajax.process;
                }
                if (process) {
                    const respData = process.call(self, resp);
                    if (respData.data.permissions) {
                        this.__currentPermissions = respData.data.permissions;
                    }
                }
            });
        }
        return Promise.resolve();
    }
    async items(path = this.currentPath, source = this.currentSource) {
        const opt = this.options;
        if (!opt.items) {
            return Promise.reject('Set Items api options');
        }
        opt.items.data.path = path;
        opt.items.data.source = source;
        return this.get('items');
    }
    async tree(path = this.currentPath, source = this.currentSource) {
        path = normalizeRelativePath(path);
        await this.permissions(path, source);
        if (!this.options.folder) {
            return Promise.reject('Set Folder Api options');
        }
        this.options.folder.data.path = path;
        this.options.folder.data.source = source;
        return this.get('folder');
    }
    createFolder(name, path, source) {
        if (!this.options.create) {
            return Promise.reject('Set Create api options');
        }
        this.options.create.data.source = source;
        this.options.create.data.path = path;
        this.options.create.data.name = name;
        return this.get('create').then(resp => {
            this.currentPath = path;
            this.currentSource = source;
            return resp;
        });
    }
    move(filepath, path, source, isFile) {
        const mode = isFile
            ? 'fileMove'
            : 'folderMove';
        const option = this.options[mode];
        if (!option) {
            return Promise.reject('Set Move api options');
        }
        option.data.from = filepath;
        option.data.path = path;
        option.data.source = source;
        return this.get(mode);
    }
    fileRemove(path, file, source) {
        if (!this.options.fileRemove) {
            return Promise.reject('Set fileRemove api options');
        }
        this.options.fileRemove.data.path = path;
        this.options.fileRemove.data.name = file;
        this.options.fileRemove.data.source = source;
        return this.get('fileRemove');
    }
    folderRemove(path, file, source) {
        if (!this.options.folderRemove) {
            return Promise.reject('Set folderRemove api options');
        }
        this.options.folderRemove.data.path = path;
        this.options.folderRemove.data.name = file;
        this.options.folderRemove.data.source = source;
        return this.get('folderRemove');
    }
    folderRename(path, name, newname, source) {
        if (!this.options.folderRename) {
            return Promise.reject('Set folderRename api options');
        }
        this.options.folderRename.data.path = path;
        this.options.folderRename.data.name = name;
        this.options.folderRename.data.newname = newname;
        this.options.folderRename.data.source = source;
        return this.get('folderRename');
    }
    fileRename(path, name, newname, source) {
        if (!this.options.fileRename) {
            return Promise.reject('Set fileRename api options');
        }
        this.options.fileRename.data.path = path;
        this.options.fileRename.data.name = name;
        this.options.fileRename.data.newname = newname;
        this.options.fileRename.data.source = source;
        return this.get('fileRename');
    }
    crop(path, source, name, newname, box) {
        if (!this.options.crop) {
            this.options.crop = {
                data: {}
            };
        }
        if (this.options.crop.data === undefined) {
            this.options.crop.data = {
                action: 'crop'
            };
        }
        this.options.crop.data.newname = newname || name;
        if (box) {
            this.options.crop.data.box = box;
        }
        this.options.crop.data.path = path;
        this.options.crop.data.name = name;
        this.options.crop.data.source = source;
        return this.get('crop');
    }
    resize(path, source, name, newname, box) {
        if (!this.options.resize) {
            this.options.resize = {
                data: {}
            };
        }
        if (this.options.resize.data === undefined) {
            this.options.resize.data = {
                action: 'resize'
            };
        }
        this.options.resize.data.newname = newname || name;
        if (box) {
            this.options.resize.data.box = box;
        }
        this.options.resize.data.path = path;
        this.options.resize.data.name = name;
        this.options.resize.data.source = source;
        return this.get('resize');
    }
}

// CONCATENATED MODULE: ./src/modules/filebrowser/builders/contextMenu.ts





const CLASS_PREVIEW = F_CLASS + '_preview_', preview_tpl_next = (next = 'next', right = 'right') => `<a href="javascript:void(0)" class="${CLASS_PREVIEW}navigation ${CLASS_PREVIEW}navigation-${next}">` +
    '' +
    ToolbarIcon.getIcon('angle-' + right) +
    '</a>';
/* harmony default export */ var contextMenu = ((self) => {
    if (!self.options.contextMenu) {
        return () => { };
    }
    const contextmenu = new ContextMenu_ContextMenu(self.jodit || self);
    return function (e) {
        let item = this, opt = self.options, ga = (attr) => item.getAttribute(attr) || '';
        self.async.setTimeout(() => {
            contextmenu.show(e.pageX, e.pageY, [
                ga('data-is-file') !== '1' &&
                    opt.editImage &&
                    (self.dataProvider.canI('ImageResize') ||
                        self.dataProvider.canI('ImageCrop'))
                    ? {
                        icon: 'pencil',
                        title: 'Edit',
                        exec: () => {
                            self.openImageEditor(ga('href'), ga('data-name'), ga('data-path'), ga('data-source'));
                        }
                    }
                    : false,
                self.dataProvider.canI('FileRename')
                    ? {
                        icon: 'italic',
                        title: 'Rename',
                        exec: async () => {
                            self.events.fire('fileRename.filebrowser', ga('data-name'), ga('data-path'), ga('data-source'));
                        }
                    }
                    : false,
                self.dataProvider.canI('FileRemove')
                    ? {
                        icon: 'bin',
                        title: 'Delete',
                        exec: async () => {
                            await self.deleteFile(ga('data-name'), ga('data-source'));
                            self.state.activeElements = [];
                            self.loadTree();
                        }
                    }
                    : false,
                opt.preview
                    ? {
                        icon: 'eye',
                        title: 'Preview',
                        exec: () => {
                            var _a, _b;
                            const preview = new dialog_Dialog(self), temp_content = self.create.div(F_CLASS + '_preview', ICON_LOADER), preview_box = self.create.div(F_CLASS + '_preview_box'), next = self.create.fromHTML(preview_tpl_next()), prev = self.create.fromHTML(preview_tpl_next('prev', 'left')), addLoadHandler = (src) => {
                                const image = self.create.element('img');
                                image.setAttribute('src', src);
                                const onload = () => {
                                    var _a, _b;
                                    image.removeEventListener('load', onload);
                                    temp_content.innerHTML = '';
                                    if (opt.showPreviewNavigation) {
                                        if (Dom_Dom.prevWithClass(item, ITEM_CLASS)) {
                                            temp_content.appendChild(prev);
                                        }
                                        if (Dom_Dom.nextWithClass(item, ITEM_CLASS)) {
                                            temp_content.appendChild(next);
                                        }
                                    }
                                    temp_content.appendChild(preview_box);
                                    preview_box.appendChild(image);
                                    preview.setPosition();
                                    (_b = (_a = self) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.fire('previewOpenedAndLoaded');
                                };
                                image.addEventListener('load', onload);
                                if (image.complete) {
                                    onload();
                                }
                            };
                            addLoadHandler(ga('href'));
                            self.events.on([next, prev], 'click', function () {
                                if (this.classList.contains(CLASS_PREVIEW +
                                    'navigation-next')) {
                                    item = (Dom_Dom.nextWithClass(item, ITEM_CLASS));
                                }
                                else {
                                    item = (Dom_Dom.prevWithClass(item, ITEM_CLASS));
                                }
                                if (!item) {
                                    throw type_error('Need element');
                                }
                                Dom_Dom.detach(temp_content);
                                Dom_Dom.detach(preview_box);
                                temp_content.innerHTML = ICON_LOADER;
                                addLoadHandler(ga('href'));
                            });
                            preview.setContent(temp_content);
                            preview.setPosition();
                            preview.open();
                            (_b = (_a = self) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.fire('previewOpened');
                        }
                    }
                    : false,
                {
                    icon: 'upload',
                    title: 'Download',
                    exec: () => {
                        const url = ga('href');
                        if (url) {
                            self.ownerWindow.open(url);
                        }
                    }
                }
            ], self.dialog.getZIndex() + 1);
        }, self.defaultTimeout);
        e.stopPropagation();
        e.preventDefault();
        return false;
    };
});


// CONCATENATED MODULE: ./src/modules/events/observeObject.ts
class ObserveObject {
    constructor(data) {
        this.data = data;
        this.__onEvents = {};
        this.__lockEvent = {};
        Object.keys(data).forEach((key) => {
            Object.defineProperty(this, key, {
                set: (value) => {
                    this.fire(['beforeChange', `beforeChange.${key}`], key, value);
                    data[key] = value;
                    this.fire(['change', `change.${key}`], key, value);
                },
                get: () => {
                    return data[key];
                }
            });
        });
    }
    on(event, callback) {
        if (Array.isArray(event)) {
            event.map((e) => this.on(e, callback));
            return this;
        }
        if (!this.__onEvents[event]) {
            this.__onEvents[event] = [];
        }
        this.__onEvents[event].push(callback);
        return this;
    }
    fire(event, ...attr) {
        if (Array.isArray(event)) {
            event.map((e) => this.fire(e, ...attr));
            return;
        }
        try {
            if (!this.__lockEvent[event] && this.__onEvents[event]) {
                this.__lockEvent[event] = true;
                this.__onEvents[event].forEach(clb => clb.call(this, ...attr));
            }
        }
        catch (_a) { }
        finally {
            this.__lockEvent[event] = false;
        }
    }
    static create(data) {
        return (new ObserveObject(data));
    }
}

// CONCATENATED MODULE: ./src/modules/filebrowser/builders/item.ts


class item_FileBrowserItem {
    constructor(data) {
        this.data = data;
        extend(this, data);
    }
    static create(data) {
        return (new item_FileBrowserItem(data));
    }
    get path() {
        return normalizePath(this.data.source.path ? this.data.source.path + '/' : '/');
    }
    get imageURL() {
        const timestamp = new Date().getTime().toString(), { thumbIsAbsolute, source, thumb, file } = this.data, path = thumb || file;
        return (thumbIsAbsolute && path) ?
            path :
            normalizeURL(source.baseurl, source.path, path || '') + '?_tmst=' + timestamp;
    }
    get fileURL() {
        let { name, file, fileIsAbsolute, source } = this.data;
        if (file !== undefined) {
            name = file;
        }
        return (fileIsAbsolute && name) ? name : normalizeURL(source.baseurl, source.path, name || '');
    }
    get time() {
        const { changed } = this.data;
        return (changed &&
            (typeof changed === 'number' ? new Date(changed).toLocaleString() : changed)) || '';
    }
    get uniqueHashKey() {
        const data = this.data;
        let key = [data.sourceName, data.name, data.file, this.time, data.thumb].join('_');
        key = key.toLowerCase().replace(/[^0-9a-z\-.]/g, '-');
        return key;
    }
}

// CONCATENATED MODULE: ./src/modules/filebrowser/fileBrowser.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
























const fileBrowser_DEFAULT_SOURCE_NAME = 'default', ITEM_ACTIVE_CLASS = ITEM_CLASS + '-active-true';
class fileBrowser_FileBrowser extends viewWithToolbar_ViewWithToolbar {
    constructor(editor, options) {
        super(editor, options);
        this.loader = this.create.div(F_CLASS + '_loader', ICON_LOADER);
        this.browser = this.create.div(F_CLASS + ' non-selected');
        this.status_line = this.create.div(F_CLASS + '_status');
        this.tree = this.create.div(F_CLASS + '_tree');
        this.files = this.create.div(F_CLASS + '_files');
        this.state = ObserveObject.create({
            activeElements: [],
            elements: [],
            folders: [],
            view: 'tiles',
            sortBy: 'changed-desc',
            filterWord: '',
            onlyImages: false
        });
        this.errorHandler = (resp) => {
            if (resp instanceof Error) {
                this.status(this.i18n(resp.message));
            }
            else {
                this.status(this.options.getMessage(resp));
            }
        };
        this.status = (message, success) => {
            if (typeof message !== 'string') {
                message = message.message;
            }
            this.status_line.classList.remove('success');
            this.status_line.classList.add('active');
            const messageBox = this.create.div();
            messageBox.textContent = message;
            this.status_line.appendChild(messageBox);
            if (success) {
                this.status_line.classList.add('success');
            }
            this.async.setTimeout(() => {
                this.status_line.classList.remove('active');
                Dom_Dom.detach(this.status_line);
            }, {
                timeout: this.options.howLongShowMsg,
                label: 'fileBrowser.status'
            });
        };
        this.close = () => {
            this.dialog.close();
        };
        this.open = (callback, onlyImages = false) => {
            this.state.onlyImages = onlyImages;
            return new Promise((resolve, reject) => {
                if (!this.options.items || !this.options.items.url) {
                    throw type_error('Need set options.filebrowser.ajax.url');
                }
                let localTimeout = 0;
                this.events
                    .off(this.files, 'dblclick')
                    .on(this.files, 'dblclick', this.onSelect(callback), 'a')
                    .on(this.files, 'touchstart', () => {
                    const now = new Date().getTime();
                    if (now - localTimeout <
                        EMULATE_DBLCLICK_TIMEOUT) {
                        this.onSelect(callback)();
                    }
                    localTimeout = now;
                }, 'a')
                    .off('select.filebrowser')
                    .on('select.filebrowser', this.onSelect(callback));
                const header = this.create.div();
                this.toolbar.build(this.options.buttons, header);
                this.dialog.dialogbox_header.classList.add(F_CLASS + '_title_box');
                this.dialog.open(this.browser, header);
                this.events.fire('sort.filebrowser', this.state.sortBy);
                this.loadTree().then(resolve, reject);
            });
        };
        this.openImageEditor = (href, name, path, source, onSuccess, onFailed) => {
            return this.getInstance('ImageEditor').open(href, (newname, box, success, failed) => {
                let promise;
                if (box.action === 'resize') {
                    promise = this.dataProvider.resize(path, source, name, newname, box.box);
                }
                else {
                    promise = this.dataProvider.crop(path, source, name, newname, box.box);
                }
                promise
                    .then(resp => {
                    if (this.options.isSuccess(resp)) {
                        this.loadTree().then(() => {
                            success();
                            if (onSuccess) {
                                onSuccess();
                            }
                        });
                    }
                    else {
                        failed(type_error(this.options.getMessage(resp)));
                        if (onFailed) {
                            onFailed(type_error(this.options.getMessage(resp)));
                        }
                    }
                })
                    .catch(error => {
                    failed(error);
                    if (onFailed) {
                        onFailed(error);
                    }
                });
            });
        };
        this.elementsMap = {};
        const self = this, doc = editor ? editor.ownerDocument : document, editorDoc = editor ? editor.editorDocument : doc;
        if (editor) {
            this.id = editor.id;
        }
        self.options = new OptionsDefault(extend(true, {}, self.options, Config_Config.defaultOptions.filebrowser, options, editor ? editor.options.filebrowser : undefined));
        self.storage = storage_Storage.makeStorage(this.options.filebrowser.saveStateInStorage);
        self.dataProvider = new dataProvider_dataProvider(self.options, self.jodit || self);
        self.dialog = new dialog_Dialog(editor || self, {
            fullsize: self.options.fullsize,
            buttons: ['dialog.fullsize', 'dialog.close']
        });
        if (self.options.showFoldersPanel) {
            self.browser.appendChild(self.tree);
        }
        self.browser.appendChild(self.files);
        self.browser.appendChild(self.status_line);
        this.initEventsListeners();
        this.initNativeEventsListeners();
        self.dialog.setSize(self.options.width, self.options.height);
        [
            'getLocalFileByUrl',
            'crop',
            'resize',
            'create',
            'fileMove',
            'folderMove',
            'fileRename',
            'folderRename',
            'fileRemove',
            'folderRemove',
            'folder',
            'items',
            'permissions'
        ].forEach(key => {
            if (this.options[key] !== null) {
                this.options[key] = extend(true, {}, this.options.ajax, this.options[key]);
            }
        });
        self.stateToView();
        const view = this.storage.get(F_CLASS + '_view');
        if (view && this.options.view === null) {
            self.state.view = view === 'list' ? 'list' : 'tiles';
        }
        else {
            self.state.view = self.options.view === 'list' ? 'list' : 'tiles';
        }
        const sortBy = self.storage.get(F_CLASS + '_sortby');
        if (sortBy) {
            const parts = sortBy.split('-');
            self.state.sortBy = ['changed', 'name', 'size'].includes(parts[0])
                ? sortBy
                : 'changed-desc';
        }
        else {
            self.state.sortBy = self.options.sortBy || 'changed-desc';
        }
        self.dataProvider.currentBaseUrl = $$('base', editorDoc).length
            ? $$('base', editorDoc)[0].getAttribute('href') || ''
            : location.protocol + '//' + location.host;
        self.initUploader(editor);
    }
    get defaultTimeout() {
        return this.jodit && this.jodit !== this
            ? this.jodit.defaultTimeout
            : Config_Config.defaultOptions.observer.timeout;
    }
    async loadItems(path = this.dataProvider.currentPath, source = this.dataProvider.currentSource) {
        this.files.classList.add('active');
        this.files.appendChild(this.loader.cloneNode(true));
        return this.dataProvider
            .items(path, source)
            .then(resp => {
            let process = this.options.items.process;
            if (!process) {
                process = this.options.ajax.process;
            }
            if (process) {
                const respData = process.call(self, resp);
                this.generateItemsList(respData.data.sources);
                this.state.activeElements = [];
            }
        })
            .catch((error) => {
            Alert(error.message);
            this.errorHandler(error);
        });
    }
    async loadTree() {
        const path = this.dataProvider.currentPath, source = this.dataProvider.currentSource, error = (e) => {
            throw e instanceof Error ? e : error(e);
        };
        if (this.uploader) {
            this.uploader.setPath(path);
            this.uploader.setSource(source);
        }
        this.tree.classList.add('active');
        Dom_Dom.detach(this.tree);
        this.tree.appendChild(this.loader.cloneNode(true));
        if (this.options.showFoldersPanel) {
            const tree = this.dataProvider
                .tree(path, source)
                .then(resp => {
                let process = this.options.folder.process;
                if (!process) {
                    process = this.options.ajax.process;
                }
                if (process) {
                    const respData = process.call(self, resp);
                    this.generateFolderTree(respData.data.sources);
                }
            })
                .catch(e => {
                this.errorHandler(error(this.jodit.i18n('Error on load folders')));
                error(e);
            });
            const items = this.loadItems(path, source);
            return Promise.all([tree, items]).catch(error);
        }
        else {
            this.tree.classList.remove('active');
        }
    }
    async deleteFile(name, source) {
        return this.dataProvider
            .fileRemove(this.dataProvider.currentPath, name, source)
            .then(resp => {
            if (this.options.remove && this.options.remove.process) {
                resp = this.options.remove.process.call(this, resp);
            }
            if (!this.options.isSuccess(resp)) {
                throw type_error(this.options.getMessage(resp));
            }
            else {
                this.status(this.options.getMessage(resp) ||
                    this.i18n('File "%s" was deleted', name), true);
            }
        })
            .catch(this.status);
    }
    generateFolderTree(sources) {
        const folders = [];
        each(sources, (source_name, source) => {
            source.folders.forEach((name) => {
                folders.push({
                    name,
                    source,
                    sourceName: source_name
                });
            });
        });
        this.state.folders = folders;
    }
    generateItemsList(sources) {
        const elements = [];
        const state = this.state, canBeFile = (item) => !this.state.onlyImages ||
            item.isImage === undefined ||
            item.isImage, inFilter = (item) => !state.filterWord.length ||
            this.options.filter === undefined ||
            this.options.filter(item, state.filterWord);
        each(sources, (source_name, source) => {
            if (source.files && source.files.length) {
                if (typeof this.options.sort === 'function') {
                    source.files.sort((a, b) => this.options.sort(a, b, state.sortBy));
                }
                source.files.forEach((item) => {
                    if (inFilter(item) && canBeFile(item)) {
                        elements.push(item_FileBrowserItem.create({
                            ...item,
                            sourceName: source_name,
                            source
                        }));
                    }
                });
            }
        });
        this.state.elements = elements;
    }
    onSelect(callback) {
        return () => {
            if (this.state.activeElements.length) {
                const urls = [];
                this.state.activeElements.forEach(elm => {
                    const url = elm.fileURL;
                    url && urls.push(url);
                });
                this.close();
                if (typeof callback === 'function') {
                    callback({
                        baseurl: '',
                        files: urls
                    });
                }
            }
            return false;
        };
    }
    isOpened() {
        return this.dialog.isOpened() && this.browser.style.display !== 'none';
    }
    elementToItem(elm) {
        const { key } = elm.dataset, { item } = this.elementsMap[key || ''];
        return item;
    }
    stateToView() {
        const { state, files, create, options } = this, getDomElement = (item) => {
            const key = item.uniqueHashKey;
            if (this.elementsMap[key]) {
                return this.elementsMap[key].elm;
            }
            const elm = create.fromHTML(options.getThumbTemplate.call(this, item, item.source, item.sourceName.toString()));
            elm.dataset.key = key;
            this.elementsMap[key] = {
                item,
                elm
            };
            return this.elementsMap[key].elm;
        };
        state
            .on('beforeChange.activeElements', () => {
            state.activeElements.forEach(item => {
                const key = item.uniqueHashKey, { elm } = this.elementsMap[key];
                elm && elm.classList.remove(ITEM_ACTIVE_CLASS);
            });
        })
            .on('change.activeElements', () => {
            this.events.fire('changeSelection');
            state.activeElements.forEach(item => {
                const key = item.uniqueHashKey, { elm } = this.elementsMap[key];
                elm && elm.classList.add(ITEM_ACTIVE_CLASS);
            });
        })
            .on('change.view', () => {
            files.classList.remove(F_CLASS + '_files_view-tiles');
            files.classList.remove(F_CLASS + '_files_view-list');
            files.classList.add(F_CLASS + '_files_view-' + state.view);
            this.storage.set(F_CLASS + '_view', state.view);
        })
            .on('change.sortBy', () => {
            this.storage.set(F_CLASS + '_sortby', state.sortBy);
        })
            .on('change.elements', debounce(() => {
            Dom_Dom.detach(files);
            if (state.elements.length) {
                state.elements.forEach(item => {
                    this.files.appendChild(getDomElement(item));
                });
            }
            else {
                files.appendChild(create.div(F_CLASS + '_no_files', this.i18n('There are no files')));
            }
        }, this.defaultTimeout))
            .on('change.folders', debounce(() => {
            Dom_Dom.detach(this.tree);
            let lastSource = fileBrowser_DEFAULT_SOURCE_NAME, lastSource2 = null;
            const appendCreateButton = (source, sourceName, force = false) => {
                if (source &&
                    lastSource2 &&
                    (source !== lastSource2 || force) &&
                    options.createNewFolder &&
                    this.dataProvider.canI('FolderCreate')) {
                    this.tree.appendChild(create.a('jodit_button addfolder', {
                        href: 'javascript:void(0)',
                        'data-path': normalizePath(source.path + '/'),
                        'data-source': sourceName
                    }, ToolbarIcon.getIcon('plus') +
                        ' ' +
                        this.i18n('Add folder')));
                    lastSource2 = source;
                }
            };
            state.folders.forEach(folder => {
                const { name, source, sourceName } = folder;
                if (sourceName && sourceName !== lastSource) {
                    this.tree.appendChild(create.div(F_CLASS + '_source_title', sourceName));
                    lastSource = sourceName;
                }
                const folderElm = create.a(F_CLASS + '_tree_item', {
                    draggable: 'draggable',
                    href: 'javascript:void(0)',
                    'data-path': normalizePath(source.path, name + '/'),
                    'data-name': name,
                    'data-source': sourceName,
                    'data-source-path': source.path
                }, create.span(F_CLASS + '_tree_item_title', name));
                appendCreateButton(source, sourceName);
                lastSource2 = source;
                this.tree.appendChild(folderElm);
                if (name === '..' || name === '.') {
                    return;
                }
                if (options.deleteFolder &&
                    this.dataProvider.canI('FolderRename')) {
                    folderElm.appendChild(create.element('i', {
                        class: 'jodit_icon_folder jodit_icon_folder_rename',
                        title: this.i18n('Rename')
                    }, ToolbarIcon.getIcon('pencil')));
                }
                if (options.deleteFolder &&
                    this.dataProvider.canI('FolderRemove')) {
                    folderElm.appendChild(create.element('i', {
                        class: 'jodit_icon_folder jodit_icon_folder_remove',
                        title: this.i18n('Delete')
                    }, ToolbarIcon.getIcon('cancel')));
                }
            });
            appendCreateButton(lastSource2, lastSource, true);
        }, this.defaultTimeout));
    }
    initEventsListeners() {
        const state = this.state, self = this;
        self.events
            .on('view.filebrowser', (view) => {
            if (view !== state.view) {
                state.view = view;
            }
        })
            .on('sort.filebrowser', (value) => {
            if (value !== state.sortBy) {
                state.sortBy = value;
                self.loadItems();
            }
        })
            .on('filter.filebrowser', (value) => {
            if (value !== state.filterWord) {
                state.filterWord = value;
                self.loadItems();
            }
        })
            .on('fileRemove.filebrowser', () => {
            if (self.state.activeElements.length) {
                Confirm(self.i18n('Are you sure?'), '', (yes) => {
                    if (yes) {
                        const promises = [];
                        self.state.activeElements.forEach(item => {
                            promises.push(self.deleteFile(item.file || item.name || '', item.sourceName));
                        });
                        self.state.activeElements = [];
                        Promise.all(promises).then(() => {
                            return self.loadTree();
                        });
                    }
                });
            }
        })
            .on('edit.filebrowser', () => {
            if (self.state.activeElements.length === 1) {
                const [file] = this.state.activeElements;
                self.openImageEditor(file.fileURL, file.file || '', file.path, file.sourceName);
            }
        })
            .on('fileRename.filebrowser', (name, path, source) => {
            if (self.state.activeElements.length === 1) {
                Promt(self.i18n('Enter new name'), self.i18n('Rename'), (newName) => {
                    if (!isValidName(newName)) {
                        self.status(self.i18n('Enter new name'));
                        return false;
                    }
                    self.dataProvider
                        .fileRename(path, name, newName, source)
                        .then(resp => {
                        if (self.options.fileRename &&
                            self.options.fileRename.process) {
                            resp = self.options.fileRename.process.call(self, resp);
                        }
                        if (!self.options.isSuccess(resp)) {
                            throw type_error(self.options.getMessage(resp));
                        }
                        else {
                            self.state.activeElements = [];
                            self.status(self.options.getMessage(resp), true);
                        }
                        self.loadItems();
                    })
                        .catch(self.status);
                    return;
                }, self.i18n('type name'), name);
            }
        })
            .on('update.filebrowser', () => {
            self.loadTree();
        });
    }
    initNativeEventsListeners() {
        let dragElement = false;
        const self = this;
        self.events
            .on(self.tree, 'click', function (e) {
            const a = this
                .parentNode, path = a.getAttribute('data-path') || '';
            Confirm(self.i18n('Are you sure?'), self.i18n('Delete'), (yes) => {
                if (yes) {
                    self.dataProvider
                        .folderRemove(path, a.getAttribute('data-name') || '', a.getAttribute('data-source') || '')
                        .then(resp => {
                        if (self.options.folderRemove &&
                            self.options.folderRemove.process) {
                            resp = self.options.folderRemove.process.call(self, resp);
                        }
                        if (!self.options.isSuccess(resp)) {
                            throw type_error(self.options.getMessage(resp));
                        }
                        else {
                            self.state.activeElements = [];
                            self.status(self.options.getMessage(resp), true);
                        }
                        self.loadTree();
                    })
                        .catch(self.status);
                }
            });
            e.stopImmediatePropagation();
            return false;
        }, 'a>.jodit_icon_folder_remove')
            .on(self.tree, 'click', function (e) {
            const a = this
                .parentNode, name = a.getAttribute('data-name') || '', path = a.getAttribute('data-source-path') || '';
            Promt(self.i18n('Enter new name'), self.i18n('Rename'), (newName) => {
                if (!isValidName(newName)) {
                    self.status(self.i18n('Enter new name'));
                    return false;
                }
                self.dataProvider
                    .folderRename(path, a.getAttribute('data-name') || '', newName, a.getAttribute('data-source') || '')
                    .then(resp => {
                    if (self.options.folderRename &&
                        self.options.folderRename.process) {
                        resp = self.options.folderRename.process.call(self, resp);
                    }
                    if (!self.options.isSuccess(resp)) {
                        throw type_error(self.options.getMessage(resp));
                    }
                    else {
                        self.state.activeElements = [];
                        self.status(self.options.getMessage(resp), true);
                    }
                    self.loadTree();
                })
                    .catch(self.status);
                return;
            }, self.i18n('type name'), name);
            e.stopImmediatePropagation();
            return false;
        }, 'a>.jodit_icon_folder_rename')
            .on(self.tree, 'click', function () {
            if (this.classList.contains('addfolder')) {
                Promt(self.i18n('Enter Directory name'), self.i18n('Create directory'), (name) => {
                    self.dataProvider
                        .createFolder(name, this.getAttribute('data-path') || '', this.getAttribute('data-source') || '')
                        .then(resp => {
                        if (self.options.isSuccess(resp)) {
                            self.loadTree();
                        }
                        else {
                            self.status(self.options.getMessage(resp));
                        }
                        return resp;
                    }, self.status);
                }, self.i18n('type name'));
            }
            else {
                self.dataProvider.currentPath =
                    this.getAttribute('data-path') || '';
                self.dataProvider.currentSource =
                    this.getAttribute('data-source') || '';
                self.loadTree();
            }
        }, 'a')
            .on(self.tree, 'dragstart', function () {
            if (self.options.moveFolder) {
                dragElement = this;
            }
        }, 'a')
            .on(self.tree, 'drop', function () {
            if ((self.options.moveFile || self.options.moveFolder) &&
                dragElement) {
                let path = dragElement.getAttribute('data-path') || '';
                if (!self.options.moveFolder &&
                    dragElement.classList.contains(F_CLASS + '_tree_item')) {
                    return false;
                }
                if (dragElement.classList.contains(ITEM_CLASS)) {
                    path += dragElement.getAttribute('data-name');
                    if (!self.options.moveFile) {
                        return false;
                    }
                }
                self.dataProvider
                    .move(path, this.getAttribute('data-path') || '', this.getAttribute('data-source') || '', dragElement.classList.contains(ITEM_CLASS))
                    .then(resp => {
                    if (self.options.isSuccess(resp)) {
                        self.loadTree();
                    }
                    else {
                        self.status(self.options.getMessage(resp));
                    }
                }, self.status);
                dragElement = false;
            }
        }, 'a')
            .on(self.files, 'contextmenu', contextMenu(self), 'a')
            .on(self.files, 'click', (e) => {
            if (!ctrlKey(e)) {
                this.state.activeElements = [];
            }
        })
            .on(self.files, 'click', function (e) {
            const item = self.elementToItem(this);
            if (!item) {
                return;
            }
            if (!ctrlKey(e)) {
                self.state.activeElements = [item];
            }
            else {
                self.state.activeElements = [
                    ...self.state.activeElements,
                    item
                ];
            }
            e.stopPropagation();
            return false;
        }, 'a')
            .on(self.files, 'dragstart', function () {
            if (self.options.moveFile) {
                dragElement = this;
            }
        }, 'a')
            .on(self.dialog.container, 'drop', (e) => e.preventDefault());
    }
    initUploader(editor) {
        var _a, _b;
        const self = this, uploaderOptions = extend(true, {}, Config_Config.defaultOptions.uploader, self.options.uploader, {
            ...(_b = (_a = editor) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.uploader
        });
        const uploadHandler = () => {
            this.loadItems();
        };
        self.uploader = self.getInstance('Uploader', uploaderOptions);
        self.uploader.setPath(self.dataProvider.currentPath);
        self.uploader.setSource(self.dataProvider.currentSource);
        self.uploader.bind(self.browser, uploadHandler, self.errorHandler);
        self.events.on('bindUploader.filebrowser', (button) => {
            self.uploader.bind(button, uploadHandler, self.errorHandler);
        });
    }
    destruct() {
        this.dialog.destruct();
        delete this.dialog;
        this.events && this.events.off('.filebrowser');
        this.uploader && this.uploader.destruct();
        delete this.uploader;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/ImageEditor.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */






Config_Config.prototype.imageeditor = {
    min_width: 20,
    min_height: 20,
    closeAfterSave: false,
    width: '85%',
    height: '85%',
    crop: true,
    resize: true,
    resizeUseRatio: true,
    resizeMinWidth: 20,
    resizeMinHeight: 20,
    cropUseRatio: true,
    cropDefaultWidth: '70%',
    cropDefaultHeight: '70%'
};
const jie = 'jodit_image_editor';
const ImageEditor_gi = ToolbarIcon.getIcon.bind(ToolbarIcon);
class ImageEditor_ImageEditor extends Component_Component {
    constructor(editor) {
        super(editor);
        this.resizeUseRatio = true;
        this.cropUseRatio = true;
        this.clicked = false;
        this.activeTab = 'resize';
        this.cropBox = {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        };
        this.resizeBox = {
            w: 0,
            h: 0
        };
        this.calcValueByPercent = (value, percent) => {
            const percentStr = percent.toString();
            const valueNbr = parseFloat(value.toString());
            let match;
            match = /^[\-+]?[0-9]+(px)?$/.exec(percentStr);
            if (match) {
                return parseInt(percentStr, 10);
            }
            match = /^([\-+]?[0-9.]+)%$/.exec(percentStr);
            if (match) {
                return Math.round(valueNbr * (parseFloat(match[1]) / 100));
            }
            return valueNbr || 0;
        };
        this.calcCropBox = () => {
            const w = this.crop_box.parentNode.offsetWidth * 0.8, h = this.crop_box.parentNode.offsetHeight * 0.8;
            let wn = w, hn = h;
            if (w > this.naturalWidth && h > this.naturalHeight) {
                wn = this.naturalWidth;
                hn = this.naturalHeight;
            }
            else if (this.ratio > w / h) {
                wn = w;
                hn = this.naturalHeight * (w / this.naturalWidth);
            }
            else {
                wn = this.naturalWidth * (h / this.naturalHeight);
                hn = h;
            }
            css_css(this.crop_box, {
                width: wn,
                height: hn
            });
        };
        this.showCrop = () => {
            if (!this.cropImage) {
                return;
            }
            this.calcCropBox();
            const w = this.cropImage.offsetWidth ||
                this.image.offsetWidth ||
                this.image.naturalWidth;
            this.new_w = this.calcValueByPercent(w, this.options.cropDefaultWidth);
            const h = this.cropImage.offsetHeight ||
                this.image.offsetHeight ||
                this.image.naturalHeight;
            if (this.cropUseRatio) {
                this.new_h = this.new_w / this.ratio;
            }
            else {
                this.new_h = this.calcValueByPercent(h, this.options.cropDefaultHeight);
            }
            css_css(this.cropHandler, {
                backgroundImage: 'url(' + this.cropImage.getAttribute('src') + ')',
                width: this.new_w,
                height: this.new_h,
                left: w / 2 - this.new_w / 2,
                top: h / 2 - this.new_h / 2
            });
            this.jodit.events.fire(this.cropHandler, 'updatesize');
        };
        this.updateCropBox = () => {
            if (!this.cropImage) {
                return;
            }
            const ratioX = this.cropImage.offsetWidth / this.naturalWidth, ratioY = this.cropImage.offsetHeight / this.naturalHeight;
            this.cropBox.x = css_css(this.cropHandler, 'left') / ratioX;
            this.cropBox.y = css_css(this.cropHandler, 'top') / ratioY;
            this.cropBox.w = this.cropHandler.offsetWidth / ratioX;
            this.cropBox.h = this.cropHandler.offsetHeight / ratioY;
            this.sizes.textContent =
                this.cropBox.w.toFixed(0) + 'x' + this.cropBox.h.toFixed(0);
        };
        this.updateResizeBox = () => {
            this.resizeBox.w = this.image.offsetWidth || this.naturalWidth;
            this.resizeBox.h = this.image.offsetHeight || this.naturalHeight;
        };
        this.setHandlers = () => {
            const self = this;
            self.jodit.events
                .on([
                self.editor.querySelector('.jodit_bottomright'),
                self.cropHandler
            ], `mousedown.${jie}`, (e) => {
                self.target = e.target;
                e.preventDefault();
                e.stopImmediatePropagation();
                self.clicked = true;
                self.start_x = e.clientX;
                self.start_y = e.clientY;
                if (self.activeTab === 'crop') {
                    self.top_x = css_css(self.cropHandler, 'left');
                    self.top_y = css_css(self.cropHandler, 'top');
                    self.width = self.cropHandler.offsetWidth;
                    self.height = self.cropHandler.offsetHeight;
                }
                else {
                    self.width = self.image.offsetWidth;
                    self.height = self.image.offsetHeight;
                }
            })
                .off(this.jodit.ownerWindow, `.${jie}` + self.jodit.id)
                .on(this.jodit.ownerWindow, `mousemove.${jie}` + self.jodit.id, throttle((e) => {
                if (self.clicked) {
                    self.diff_x = e.clientX - self.start_x;
                    self.diff_y = e.clientY - self.start_y;
                    if ((self.activeTab === 'resize' &&
                        self.resizeUseRatio) ||
                        (self.activeTab === 'crop' && self.cropUseRatio)) {
                        if (self.diff_x) {
                            self.new_w = self.width + self.diff_x;
                            self.new_h = Math.round(self.new_w / self.ratio);
                        }
                        else {
                            self.new_h = self.height + self.diff_y;
                            self.new_w = Math.round(self.new_h * self.ratio);
                        }
                    }
                    else {
                        self.new_w = self.width + self.diff_x;
                        self.new_h = self.height + self.diff_y;
                    }
                    if (self.activeTab === 'resize') {
                        if (self.new_w > self.options.resizeMinWidth) {
                            css_css(self.image, 'width', self.new_w + 'px');
                            self.widthInput.value = self.new_w.toString();
                        }
                        if (self.new_h > self.options.resizeMinHeight) {
                            css_css(self.image, 'height', self.new_h + 'px');
                            self.heightInput.value = self.new_h.toString();
                        }
                        this.jodit.events.fire(self.resizeHandler, 'updatesize');
                    }
                    else {
                        if (self.target !== self.cropHandler) {
                            if (self.top_x + self.new_w >
                                self.cropImage.offsetWidth) {
                                self.new_w =
                                    self.cropImage.offsetWidth - self.top_x;
                            }
                            if (self.top_y + self.new_h >
                                self.cropImage.offsetHeight) {
                                self.new_h =
                                    self.cropImage.offsetHeight -
                                        self.top_y;
                            }
                            css_css(self.cropHandler, {
                                width: self.new_w,
                                height: self.new_h
                            });
                        }
                        else {
                            if (self.top_x +
                                self.diff_x +
                                self.cropHandler.offsetWidth >
                                self.cropImage.offsetWidth) {
                                self.diff_x =
                                    self.cropImage.offsetWidth -
                                        self.top_x -
                                        self.cropHandler.offsetWidth;
                            }
                            css_css(self.cropHandler, 'left', self.top_x + self.diff_x);
                            if (self.top_y +
                                self.diff_y +
                                self.cropHandler.offsetHeight >
                                self.cropImage.offsetHeight) {
                                self.diff_y =
                                    self.cropImage.offsetHeight -
                                        self.top_y -
                                        self.cropHandler.offsetHeight;
                            }
                            css_css(self.cropHandler, 'top', self.top_y + self.diff_y);
                        }
                        this.jodit.events.fire(self.cropHandler, 'updatesize');
                    }
                    e.stopImmediatePropagation();
                }
            }, 5))
                .on(this.jodit.ownerWindow, `resize.${jie}` + self.jodit.id, () => {
                this.jodit.events.fire(self.resizeHandler, 'updatesize');
                self.showCrop();
                this.jodit.events.fire(self.cropHandler, 'updatesize');
            })
                .on(this.jodit.ownerWindow, `mouseup.${jie} ${self.jodit.id} keydown.${jie}` +
                self.jodit.id, (e) => {
                if (self.clicked) {
                    self.clicked = false;
                    e.stopImmediatePropagation();
                }
            });
            $$('.jodit_button_group', self.editor).forEach(group => {
                const input = group.querySelector('input');
                self.jodit.events.on(group, 'click change', function () {
                    input.checked = !input.checked;
                    self.jodit.events.fire(input, 'change');
                }, 'button');
            });
            self.jodit.events
                .on(this.editor, 'click.' + jie, function () {
                $$(`.${jie}_slider,.${jie}_area`, self.editor).forEach(elm => elm.classList.remove('active'));
                const slide = this.parentNode;
                slide.classList.add('active');
                self.activeTab =
                    slide.getAttribute('data-area') ||
                        'resize';
                const tab = self.editor.querySelector(`.${jie}_area.${jie}_area_` + self.activeTab);
                if (tab) {
                    tab.classList.add('active');
                }
                if (self.activeTab === 'crop') {
                    self.showCrop();
                }
            }, `.${jie}_slider-title`)
                .on(self.widthInput, `change.${jie} mousedown.${jie} keydown.${jie}`, debounce(() => {
                const value = parseInt(self.widthInput.value, 10);
                let another;
                if (value > self.options.min_width) {
                    css_css(self.image, 'width', value + 'px');
                    if (self.resizeUseRatio) {
                        another = Math.round(value / self.ratio);
                        if (another > self.options.min_height) {
                            css_css(self.image, 'height', another + 'px');
                            self.heightInput.value = another.toString();
                        }
                    }
                }
                this.jodit.events.fire(self.resizeHandler, 'updatesize');
            }, 200))
                .on(self.heightInput, `change.${jie} mousedown.${jie} keydown.${jie}`, debounce(() => {
                if (this.isDestructed) {
                    return;
                }
                const value = parseInt(self.heightInput.value, 10);
                let another;
                if (value > self.options.min_height) {
                    css_css(self.image, 'height', value + 'px');
                    if (self.resizeUseRatio) {
                        another = Math.round(value * self.ratio);
                        if (another > self.options.min_width) {
                            css_css(self.image, 'width', another + 'px');
                            self.widthInput.value = another.toString();
                        }
                    }
                }
                this.jodit.events.fire(self.resizeHandler, 'updatesize');
            }, 200));
            const rationResizeButton = self.editor.querySelector(`.${jie}_keep_spect_ratio`);
            if (rationResizeButton) {
                rationResizeButton.addEventListener('change', () => {
                    self.resizeUseRatio = rationResizeButton.checked;
                });
            }
            const rationCropButton = self.editor.querySelector(`.${jie}_keep_spect_ratio_crop`);
            if (rationCropButton) {
                rationCropButton.addEventListener('change', () => {
                    self.cropUseRatio = rationCropButton.checked;
                });
            }
            self.jodit.events
                .on(self.resizeHandler, 'updatesize', () => {
                css_css(self.resizeHandler, {
                    top: 0,
                    left: 0,
                    width: (self.image.offsetWidth || self.naturalWidth) + 'px',
                    height: (self.image.offsetHeight || self.naturalHeight) + 'px'
                });
                this.updateResizeBox();
            })
                .on(self.cropHandler, 'updatesize', () => {
                if (!self.cropImage) {
                    return;
                }
                let new_x = css_css(self.cropHandler, 'left'), new_y = css_css(self.cropHandler, 'top'), new_width = self.cropHandler.offsetWidth, new_height = self.cropHandler.offsetHeight;
                if (new_x < 0) {
                    new_x = 0;
                }
                if (new_y < 0) {
                    new_y = 0;
                }
                if (new_x + new_width > self.cropImage.offsetWidth) {
                    new_width = self.cropImage.offsetWidth - new_x;
                    if (self.cropUseRatio) {
                        new_height = new_width / self.ratio;
                    }
                }
                if (new_y + new_height > self.cropImage.offsetHeight) {
                    new_height = self.cropImage.offsetHeight - new_y;
                    if (self.cropUseRatio) {
                        new_width = new_height * self.ratio;
                    }
                }
                css_css(self.cropHandler, {
                    width: new_width,
                    height: new_height,
                    left: new_x,
                    top: new_y,
                    backgroundPosition: -new_x - 1 + 'px ' + (-new_y - 1) + 'px',
                    backgroundSize: self.cropImage.offsetWidth +
                        'px ' +
                        self.cropImage.offsetHeight +
                        'px'
                });
                self.updateCropBox();
            });
            self.buttons.forEach(button => {
                button.addEventListener('mousedown', e => {
                    e.stopImmediatePropagation();
                });
                button.addEventListener('click', () => {
                    const data = {
                        action: self.activeTab,
                        box: self.activeTab === 'resize'
                            ? self.resizeBox
                            : self.cropBox
                    };
                    switch (button.getAttribute('data-action')) {
                        case 'saveas':
                            Promt(self.jodit.i18n('Enter new name'), self.jodit.i18n('Save in new file'), (name) => {
                                if (!trim(name)) {
                                    Alert(self.jodit.i18n('The name should not be empty'));
                                    return false;
                                }
                                self.onSave(name, data, self.hide, (e) => {
                                    Alert(e.message);
                                });
                            });
                            break;
                        case 'save':
                            self.onSave(undefined, data, self.hide, (e) => {
                                Alert(e.message);
                            });
                            break;
                        case 'reset':
                            if (self.activeTab === 'resize') {
                                css_css(self.image, {
                                    width: null,
                                    height: null
                                });
                                self.widthInput.value = self.naturalWidth.toString();
                                self.heightInput.value = self.naturalHeight.toString();
                                self.jodit.events.fire(self.resizeHandler, 'updatesize');
                            }
                            else {
                                self.showCrop();
                            }
                            break;
                    }
                });
            });
        };
        this.hide = () => {
            this.dialog.close();
        };
        this.open = (url, save) => {
            return this.jodit.async.promise(resolve => {
                const timestamp = new Date().getTime();
                this.image = this.jodit.create.element('img');
                $$('img,.jodit_icon-loader', this.resize_box).forEach(Dom_Dom.safeRemove);
                $$('img,.jodit_icon-loader', this.crop_box).forEach(Dom_Dom.safeRemove);
                css_css(this.cropHandler, 'background', 'transparent');
                this.onSave = save;
                this.resize_box.appendChild(this.jodit.create.element('i', { class: 'jodit_icon-loader' }));
                this.crop_box.appendChild(this.jodit.create.element('i', { class: 'jodit_icon-loader' }));
                if (/\?/.test(url)) {
                    url += '&_tst=' + timestamp;
                }
                else {
                    url += '?_tst=' + timestamp;
                }
                this.image.setAttribute('src', url);
                this.dialog.open();
                const onload = () => {
                    if (this.isDestructed) {
                        return;
                    }
                    this.image.removeEventListener('load', onload);
                    this.naturalWidth = this.image.naturalWidth;
                    this.naturalHeight = this.image.naturalHeight;
                    this.widthInput.value = this.naturalWidth.toString();
                    this.heightInput.value = this.naturalHeight.toString();
                    this.ratio = this.naturalWidth / this.naturalHeight;
                    this.resize_box.appendChild(this.image);
                    this.cropImage = this.image.cloneNode(true);
                    this.crop_box.appendChild(this.cropImage);
                    $$('.jodit_icon-loader', this.editor).forEach(Dom_Dom.safeRemove);
                    if (this.activeTab === 'crop') {
                        this.showCrop();
                    }
                    this.jodit.events.fire(this.resizeHandler, 'updatesize');
                    this.jodit.events.fire(this.cropHandler, 'updatesize');
                    this.dialog.setPosition();
                    this.jodit.events.fire('afterImageEditor');
                    resolve(this.dialog);
                };
                this.image.addEventListener('load', onload);
                if (this.image.complete) {
                    onload();
                }
            });
        };
        this.options =
            editor && editor.options
                ? editor.options.imageeditor
                : Config_Config.defaultOptions.imageeditor;
        const o = this.options;
        const i = editor.i18n;
        this.resizeUseRatio = o.resizeUseRatio;
        this.cropUseRatio = o.cropUseRatio;
        const r = this.resizeUseRatio;
        const c = this.cropUseRatio;
        this.buttons = [
            this.jodit.create.fromHTML('<button data-action="reset" type="button" class="jodit_button">' +
                ImageEditor_gi('update') +
                '&nbsp;' +
                i('Reset') +
                '</button>'),
            this.jodit.create.fromHTML('<button data-action="save" type="button" class="jodit_button jodit_button_success">' +
                ImageEditor_gi('save') +
                '&nbsp;' +
                i('Save') +
                '</button>'),
            this.jodit.create.fromHTML('<button data-action="saveas" type="button" class="jodit_button jodit_button_success">' +
                ImageEditor_gi('save') +
                '&nbsp;' +
                i('Save as ...') +
                '</button>')
        ];
        this.activeTab = o.resize ? 'resize' : 'crop';
        const act = (el, className = 'active') => el ? className : '';
        const switcher = (label, className, active = true) => `<div class="jodit_form_group">
			<label>${i(label)}</label>
			<div class="jodit_button_group jodit_button_radio_group">
				<input ${act(active, 'checked')} type="checkbox" class="${jie}_${className} jodit_input"/>

				<button type="button" data-yes="1" class="jodit_button jodit_status_success">${i('Yes')}</button>

				<button type="button" class="jodit_button jodit_status_danger">${i('No')}</button>
			</div>
		</div>`;
        this.editor = this.jodit.create.fromHTML(`<form class="${jie} jodit_properties">
							<div class="jodit_grid">
								<div class="jodit_col-lg-3-4">
								${o.resize
            ? `<div class="${jie}_area ${jie}_area_resize active">
												<div class="${jie}_box"></div>
												<div class="${jie}_resizer">
													<i class="jodit_bottomright"></i>
												</div>
											</div>`
            : ''}
								${o.crop
            ? `<div class="${jie}_area ${jie}_area_crop ${act(!o.resize)}">
												<div class="${jie}_box">
													<div class="${jie}_croper">
														<i class="jodit_bottomright"></i>
														<i class="jodit_sizes"></i>
													</div>
												</div>
											</div>`
            : ''}
								</div>
								<div class="jodit_col-lg-1-4">
								${o.resize
            ? `<div data-area="resize" class="${jie}_slider active">
												<div class="${jie}_slider-title">
													${ImageEditor_gi('resize')}
													${i('Resize')}
												</div>
												<div class="${jie}_slider-content">
													<div class="jodit_form_group">
														<label for="${jie}_width">
															${i('Width')}
														</label>
														<input type="number" class="${jie}_width jodit_input"/>
													</div>
													<div class="jodit_form_group">
														<label for="${jie}_height">
															${i('Height')}
														</label>
														<input type="number" class="${jie}_height jodit_input"/>
													</div>
													${switcher('Keep Aspect Ratio', 'keep_spect_ratio', r)}
												</div>
											</div>`
            : ''}
								${o.crop
            ? `<div data-area="crop" class="${jie}_slider ${act(!o.resize)}'">
												<div class="${jie}_slider-title">
													${ImageEditor_gi('crop')}
													${i('Crop')}
												</div>
												<div class="${jie}_slider-content">
													${switcher('Keep Aspect Ratio', 'keep_spect_ratio_crop', c)}
												</div>
											</div>`
            : ''}
								</div>
							</div>
						</form>`);
        this.widthInput = this.editor.querySelector(`.${jie}_width`);
        this.heightInput = this.editor.querySelector(`.${jie}_height`);
        this.resize_box = this.editor.querySelector(`.${jie}_area.${jie}_area_resize .${jie}_box`);
        this.crop_box = this.editor.querySelector(`.${jie}_area.${jie}_area_crop .${jie}_box`);
        this.sizes = this.editor.querySelector(`.${jie}_area.${jie}_area_crop .jodit_sizes`);
        this.resizeHandler = this.editor.querySelector(`.${jie}_resizer`);
        this.cropHandler = this.editor.querySelector(`.${jie}_croper`);
        this.dialog = new dialog_Dialog(editor);
        this.dialog.setContent(this.editor);
        this.dialog.setSize(this.options.width, this.options.height);
        this.dialog.setTitle(this.buttons);
        this.setHandlers();
    }
    destruct() {
        if (this.isDestructed) {
            return;
        }
        if (this.dialog) {
            this.dialog.destruct();
            delete this.dialog;
        }
        Dom_Dom.safeRemove(this.editor);
        delete this.widthInput;
        delete this.heightInput;
        delete this.resize_box;
        delete this.crop_box;
        delete this.sizes;
        delete this.resizeHandler;
        delete this.cropHandler;
        delete this.editor;
        if (this.jodit.events) {
            this.jodit.events.off(`.${jie}`);
        }
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/Uploader.ts







Config_Config.prototype.enableDragAndDropFileToEditor = true;
Config_Config.prototype.uploader = {
    url: '',
    insertImageAsBase64URI: false,
    imagesExtensions: ['jpg', 'png', 'jpeg', 'gif'],
    headers: null,
    data: null,
    filesVariableName(i) {
        return `files[${i}]`;
    },
    withCredentials: false,
    pathVariableName: 'path',
    format: 'json',
    method: 'POST',
    prepareData(formData) {
        return formData;
    },
    isSuccess(resp) {
        return resp.success;
    },
    getMessage(resp) {
        return resp.data.messages !== undefined &&
            Array.isArray(resp.data.messages)
            ? resp.data.messages.join(' ')
            : '';
    },
    process(resp) {
        return resp.data;
    },
    error(e) {
        this.jodit.events.fire('errorMessage', e.message, 'error', 4000);
    },
    defaultHandlerSuccess(resp) {
        if (resp.files && resp.files.length) {
            resp.files.forEach((filename, index) => {
                const [tagName, attr] = resp.isImages && resp.isImages[index]
                    ? ['img', 'src']
                    : ['a', 'href'];
                const elm = this.jodit.create.inside.element(tagName);
                elm.setAttribute(attr, resp.baseurl + filename);
                if (tagName === 'a') {
                    elm.textContent = resp.baseurl + filename;
                }
                if (isJoditObject(this.jodit)) {
                    if (tagName === 'img') {
                        this.jodit.selection.insertImage(elm, null, this.jodit.options.imageDefaultWidth);
                    }
                    else {
                        this.jodit.selection.insertNode(elm);
                    }
                }
            });
        }
    },
    defaultHandlerError(e) {
        this.jodit.events.fire('errorMessage', e.message);
    },
    contentType(requestData) {
        return this.jodit.ownerWindow.FormData !== undefined &&
            typeof requestData !== 'string'
            ? false
            : 'application/x-www-form-urlencoded; charset=UTF-8';
    }
};
class Uploader_Uploader extends Component_Component {
    constructor(editor, options) {
        super(editor);
        this.path = '';
        this.source = 'default';
        this.ajaxInstances = [];
        this.options = extend(true, {}, Config_Config.defaultOptions.uploader, isJoditObject(editor) ? editor.options.uploader : null, options);
    }
    static dataURItoBlob(dataURI) {
        const byteString = atob(dataURI.split(',')[1]), mimeString = dataURI
            .split(',')[0]
            .split(':')[1]
            .split(';')[0], ab = new ArrayBuffer(byteString.length), ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i += 1) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ia], { type: mimeString });
    }
    buildData(data) {
        if (this.options.buildData &&
            typeof this.options.buildData === 'function') {
            return this.options.buildData.call(this, data);
        }
        const FD = this.jodit.ownerWindow.FormData;
        if (FD !== undefined) {
            if (data instanceof FD) {
                return data;
            }
            if (typeof data === 'string') {
                return data;
            }
            const newdata = new FD();
            Object.keys(data).forEach(key => {
                newdata.append(key, data[key]);
            });
            return newdata;
        }
        return data;
    }
    send(data, success) {
        const requestData = this.buildData(data), sendData = (request) => {
            const ajax = new Ajax_Ajax(this.jodit || this, {
                xhr: () => {
                    const xhr = new XMLHttpRequest();
                    if (this.jodit.ownerWindow.FormData !==
                        undefined &&
                        xhr.upload) {
                        xhr.upload.addEventListener('progress', evt => {
                            if (evt.lengthComputable) {
                                let percentComplete = evt.loaded / evt.total;
                                percentComplete *= 100;
                                this.jodit.progressbar
                                    .show()
                                    .progress(percentComplete);
                                if (percentComplete >= 100) {
                                    this.jodit.progressbar.hide();
                                }
                            }
                        }, false);
                    }
                    else {
                        this.jodit.progressbar.hide();
                    }
                    return xhr;
                },
                method: this.options.method || 'POST',
                data: request,
                url: this.options.url,
                headers: this.options.headers,
                queryBuild: this.options.queryBuild,
                contentType: this.options.contentType.call(this, request),
                dataType: this.options.format || 'json',
                withCredentials: this.options.withCredentials || false
            });
            this.ajaxInstances.push(ajax);
            const removeAjaxInstanceFromList = () => {
                const index = this.ajaxInstances.indexOf(ajax);
                if (index !== -1) {
                    this.ajaxInstances.splice(index, 1);
                }
            };
            return ajax
                .send()
                .then(resp => {
                removeAjaxInstanceFromList();
                success.call(this, resp);
            })
                .catch(error => {
                removeAjaxInstanceFromList();
                this.options.error.call(this, error);
            });
        };
        if (requestData instanceof Promise) {
            return requestData.then(sendData).catch(error => {
                this.options.error.call(this, error);
            });
        }
        else {
            return sendData(requestData);
        }
    }
    sendFiles(files, handlerSuccess, handlerError, process) {
        if (!files) {
            return Promise.reject(type_error('Need files'));
        }
        const uploader = this;
        let fileList = Array.from(files);
        if (!fileList.length) {
            return Promise.reject(type_error('Need files'));
        }
        const promises = [];
        if (this.options.insertImageAsBase64URI) {
            let file, i;
            for (i = 0; i < fileList.length; i += 1) {
                file = fileList[i];
                if (file && file.type) {
                    const mime = file.type.match(/\/([a-z0-9]+)/i);
                    const extension = mime[1]
                        ? mime[1].toLowerCase()
                        : '';
                    if (this.options.imagesExtensions.includes(extension)) {
                        const reader = new FileReader();
                        promises.push(new Promise((resolve, reject) => {
                            reader.onerror = reject;
                            reader.onloadend = () => {
                                const resp = {
                                    baseurl: '',
                                    files: [reader.result],
                                    isImages: [true]
                                };
                                if (typeof (handlerSuccess ||
                                    uploader.options
                                        .defaultHandlerSuccess) === 'function') {
                                    (handlerSuccess ||
                                        uploader.options
                                            .defaultHandlerSuccess).call(uploader, resp);
                                }
                                resolve(resp);
                            };
                            reader.readAsDataURL(file);
                        }));
                        fileList[i] = null;
                    }
                }
            }
        }
        fileList = fileList.filter(a => a);
        if (fileList.length) {
            const form = new FormData();
            form.append(this.options.pathVariableName, uploader.path);
            form.append('source', uploader.source);
            let file;
            for (let i = 0; i < fileList.length; i += 1) {
                file = fileList[i];
                if (file) {
                    const mime = file.type.match(/\/([a-z0-9]+)/i);
                    const extension = mime && mime[1] ? mime[1].toLowerCase() : '';
                    let newName = fileList[i].name ||
                        Math.random()
                            .toString()
                            .replace('.', '');
                    if (extension) {
                        let extForReg = extension;
                        if (['jpeg', 'jpg'].includes(extForReg)) {
                            extForReg = 'jpeg|jpg';
                        }
                        const reEnd = new RegExp('.(' + extForReg + ')$', 'i');
                        if (!reEnd.test(newName)) {
                            newName += '.' + extension;
                        }
                    }
                    form.append(this.options.filesVariableName(i), fileList[i], newName);
                }
            }
            if (process) {
                process(form);
            }
            if (uploader.options.data && isPlainObject(uploader.options.data)) {
                Object.keys(uploader.options.data).forEach((key) => {
                    form.append(key, uploader.options.data[key]);
                });
            }
            uploader.options.prepareData.call(this, form);
            promises.push(uploader
                .send(form, (resp) => {
                if (this.options.isSuccess.call(uploader, resp)) {
                    if (typeof (handlerSuccess ||
                        uploader.options.defaultHandlerSuccess) === 'function') {
                        (handlerSuccess ||
                            uploader.options
                                .defaultHandlerSuccess).call(uploader, uploader.options.process.call(uploader, resp));
                    }
                }
                else {
                    if (typeof (handlerError ||
                        uploader.options.defaultHandlerError)) {
                        (handlerError ||
                            uploader.options
                                .defaultHandlerError).call(uploader, type_error(uploader.options.getMessage.call(uploader, resp)));
                        return;
                    }
                }
            })
                .then(() => {
                this.jodit.events &&
                    this.jodit.events.fire('filesWereUploaded');
            }));
        }
        return Promise.all(promises);
    }
    setPath(path) {
        this.path = path;
    }
    setSource(source) {
        this.source = source;
    }
    bind(form, handlerSuccess, handlerError) {
        const self = this, onPaste = (e) => {
            let i, file, extension, cData = e.clipboardData;
            const process = (formdata) => {
                if (file) {
                    formdata.append('extension', extension);
                    formdata.append('mimetype', file.type);
                }
            };
            if (cData && cData.files && cData.files.length) {
                this.sendFiles(cData.files, handlerSuccess, handlerError);
                return false;
            }
            if (browser('ff') || IS_IE) {
                if (cData &&
                    (!cData.types ||
                        !cData.types.length ||
                        cData.types[0] !== TEXT_PLAIN)) {
                    const div = this.jodit.create.div('', {
                        tabindex: -1,
                        style: 'left: -9999px; top: 0; width: 0; height: 100%;line-height: 140%; ' +
                            'overflow: hidden; position: fixed; z-index: 2147483647; word-break: break-all;',
                        contenteditable: true
                    });
                    this.jodit.ownerDocument.body.appendChild(div);
                    const selection = this.jodit && isJoditObject(this.jodit)
                        ? this.jodit.selection.save()
                        : null, restore = () => selection &&
                        this.jodit &&
                        isJoditObject(this.jodit) &&
                        this.jodit.selection.restore(selection);
                    div.focus();
                    this.jodit.async.setTimeout(() => {
                        const child = div.firstChild;
                        Dom_Dom.safeRemove(div);
                        if (child && child.hasAttribute('src')) {
                            const src = child.getAttribute('src') || '';
                            restore();
                            self.sendFiles([Uploader_Uploader.dataURItoBlob(src)], handlerSuccess, handlerError);
                        }
                    }, this.jodit.defaultTimeout);
                }
                return;
            }
            if (cData && cData.items && cData.items.length) {
                const items = cData.items;
                for (i = 0; i < items.length; i += 1) {
                    if (items[i].kind === 'file' &&
                        items[i].type === 'image/png') {
                        file = items[i].getAsFile();
                        if (file) {
                            const mime = file.type.match(/\/([a-z0-9]+)/i);
                            extension = mime[1]
                                ? mime[1].toLowerCase()
                                : '';
                            this.sendFiles([file], handlerSuccess, handlerError, process);
                        }
                        e.preventDefault();
                        break;
                    }
                }
            }
        };
        if (this.jodit && this.jodit.editor !== form) {
            self.jodit.events.on(form, 'paste', onPaste);
        }
        else {
            self.jodit.events.on('beforePaste', onPaste);
        }
        const hasFiles = (event) => Boolean(event.dataTransfer &&
            event.dataTransfer.files &&
            event.dataTransfer.files.length !== 0);
        self.jodit.events
            .on(form, 'dragend dragover dragenter dragleave drop', (e) => {
            e.preventDefault();
        })
            .on(form, 'dragover', (event) => {
            if (hasFiles(event)) {
                form.classList.contains('jodit_draghover') ||
                    form.classList.add('jodit_draghover');
                event.preventDefault();
            }
        })
            .on(form, 'dragend', (event) => {
            if (hasFiles(event)) {
                form.classList.contains('jodit_draghover') &&
                    form.classList.remove('jodit_draghover');
                event.preventDefault();
            }
        })
            .on(form, 'drop', (event) => {
            form.classList.remove('jodit_draghover');
            if (hasFiles(event) &&
                event.dataTransfer &&
                event.dataTransfer.files) {
                event.preventDefault();
                event.stopImmediatePropagation();
                this.sendFiles(event.dataTransfer.files, handlerSuccess, handlerError);
            }
        });
        const inputFile = form.querySelector('input[type=file]');
        if (inputFile) {
            self.jodit.events.on(inputFile, 'change', function () {
                self.sendFiles(this.files, handlerSuccess, handlerError).then(() => {
                    inputFile.value = '';
                    if (!/safari/i.test(navigator.userAgent)) {
                        inputFile.type = '';
                        inputFile.type = 'file';
                    }
                });
            });
        }
    }
    uploadRemoteImage(url, handlerSuccess, handlerError) {
        const uploader = this;
        uploader.send({
            action: 'fileUploadRemote',
            url
        }, (resp) => {
            if (uploader.options.isSuccess.call(uploader, resp)) {
                if (typeof handlerSuccess === 'function') {
                    handlerSuccess.call(uploader, this.options.process.call(this, resp));
                }
                else {
                    this.options.defaultHandlerSuccess.call(uploader, this.options.process.call(this, resp));
                }
            }
            else {
                if (typeof (handlerError || uploader.options.defaultHandlerError) === 'function') {
                    (handlerError || this.options.defaultHandlerError).call(uploader, type_error(uploader.options.getMessage.call(this, resp)));
                    return;
                }
            }
        });
    }
    destruct() {
        this.setStatus(STATUSES.beforeDestruct);
        this.ajaxInstances.forEach(ajax => {
            try {
                ajax.abort();
            }
            catch (_a) { }
        });
        delete this.options;
        super.destruct();
    }
}

// CONCATENATED MODULE: ./src/modules/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */



























// EXTERNAL MODULE: ./src/styles/icons/about.svg
var about = __webpack_require__(1);

// EXTERNAL MODULE: ./src/styles/icons/addcolumn.svg
var addcolumn = __webpack_require__(2);

// EXTERNAL MODULE: ./src/styles/icons/addrow.svg
var addrow = __webpack_require__(3);

// EXTERNAL MODULE: ./src/styles/icons/angle-down.svg
var angle_down = __webpack_require__(4);

// EXTERNAL MODULE: ./src/styles/icons/angle-left.svg
var angle_left = __webpack_require__(5);

// EXTERNAL MODULE: ./src/styles/icons/angle-right.svg
var angle_right = __webpack_require__(6);

// EXTERNAL MODULE: ./src/styles/icons/angle-up.svg
var angle_up = __webpack_require__(7);

// EXTERNAL MODULE: ./src/styles/icons/arrows-alt.svg
var arrows_alt = __webpack_require__(8);

// EXTERNAL MODULE: ./src/styles/icons/arrows-h.svg
var arrows_h = __webpack_require__(9);

// EXTERNAL MODULE: ./src/styles/icons/attachment.svg
var attachment = __webpack_require__(10);

// EXTERNAL MODULE: ./src/styles/icons/bin.svg
var bin = __webpack_require__(11);

// EXTERNAL MODULE: ./src/styles/icons/bold.svg
var icons_bold = __webpack_require__(12);

// EXTERNAL MODULE: ./src/styles/icons/brush.svg
var brush = __webpack_require__(13);

// EXTERNAL MODULE: ./src/styles/icons/cancel.svg
var icons_cancel = __webpack_require__(14);

// EXTERNAL MODULE: ./src/styles/icons/center.svg
var center = __webpack_require__(15);

// EXTERNAL MODULE: ./src/styles/icons/chain-broken.svg
var chain_broken = __webpack_require__(16);

// EXTERNAL MODULE: ./src/styles/icons/check.svg
var check = __webpack_require__(17);

// EXTERNAL MODULE: ./src/styles/icons/check-square.svg
var check_square = __webpack_require__(18);

// EXTERNAL MODULE: ./src/styles/icons/copyformat.svg
var copyformat = __webpack_require__(19);

// EXTERNAL MODULE: ./src/styles/icons/crop.svg
var crop = __webpack_require__(20);

// EXTERNAL MODULE: ./src/styles/icons/copy.svg
var icons_copy = __webpack_require__(21);

// EXTERNAL MODULE: ./src/styles/icons/cut.svg
var cut = __webpack_require__(22);

// EXTERNAL MODULE: ./src/styles/icons/dedent.svg
var dedent = __webpack_require__(23);

// EXTERNAL MODULE: ./src/styles/icons/dots.svg
var dots = __webpack_require__(24);

// EXTERNAL MODULE: ./src/styles/icons/dropdown-arrow.svg
var dropdown_arrow = __webpack_require__(25);

// EXTERNAL MODULE: ./src/styles/icons/enter.svg
var icons_enter = __webpack_require__(26);

// EXTERNAL MODULE: ./src/styles/icons/eraser.svg
var eraser = __webpack_require__(27);

// EXTERNAL MODULE: ./src/styles/icons/eye.svg
var eye = __webpack_require__(28);

// EXTERNAL MODULE: ./src/styles/icons/file.svg
var icons_file = __webpack_require__(29);

// EXTERNAL MODULE: ./src/styles/icons/folder.svg
var icons_folder = __webpack_require__(30);

// EXTERNAL MODULE: ./src/styles/icons/font.svg
var icons_font = __webpack_require__(31);

// EXTERNAL MODULE: ./src/styles/icons/fontsize.svg
var fontsize = __webpack_require__(32);

// EXTERNAL MODULE: ./src/styles/icons/fullsize.svg
var icons_fullsize = __webpack_require__(33);

// EXTERNAL MODULE: ./src/styles/icons/hr.svg
var icons_hr = __webpack_require__(34);

// EXTERNAL MODULE: ./src/styles/icons/image.svg
var icons_image = __webpack_require__(35);

// EXTERNAL MODULE: ./src/styles/icons/indent.svg
var icons_indent = __webpack_require__(36);

// EXTERNAL MODULE: ./src/styles/icons/info-circle.svg
var info_circle = __webpack_require__(37);

// EXTERNAL MODULE: ./src/styles/icons/italic.svg
var italic = __webpack_require__(38);

// EXTERNAL MODULE: ./src/styles/icons/justify.svg
var icons_justify = __webpack_require__(39);

// EXTERNAL MODULE: ./src/styles/icons/left.svg
var icons_left = __webpack_require__(40);

// EXTERNAL MODULE: ./src/styles/icons/link.svg
var icons_link = __webpack_require__(41);

// EXTERNAL MODULE: ./src/styles/icons/lock.svg
var lock = __webpack_require__(42);

// EXTERNAL MODULE: ./src/styles/icons/menu.svg
var menu = __webpack_require__(43);

// EXTERNAL MODULE: ./src/styles/icons/merge.svg
var merge = __webpack_require__(44);

// EXTERNAL MODULE: ./src/styles/icons/ol.svg
var ol = __webpack_require__(45);

// EXTERNAL MODULE: ./src/styles/icons/omega.svg
var omega = __webpack_require__(46);

// EXTERNAL MODULE: ./src/styles/icons/outdent.svg
var outdent = __webpack_require__(47);

// EXTERNAL MODULE: ./src/styles/icons/palette.svg
var palette = __webpack_require__(48);

// EXTERNAL MODULE: ./src/styles/icons/paragraph.svg
var paragraph = __webpack_require__(49);

// EXTERNAL MODULE: ./src/styles/icons/paste.svg
var icons_paste = __webpack_require__(50);

// EXTERNAL MODULE: ./src/styles/icons/pencil.svg
var pencil = __webpack_require__(51);

// EXTERNAL MODULE: ./src/styles/icons/plus.svg
var plus = __webpack_require__(52);

// EXTERNAL MODULE: ./src/styles/icons/print.svg
var print = __webpack_require__(53);

// EXTERNAL MODULE: ./src/styles/icons/redo.svg
var redo = __webpack_require__(54);

// EXTERNAL MODULE: ./src/styles/icons/resize.svg
var icons_resize = __webpack_require__(55);

// EXTERNAL MODULE: ./src/styles/icons/resizer.svg
var icons_resizer = __webpack_require__(56);

// EXTERNAL MODULE: ./src/styles/icons/right.svg
var icons_right = __webpack_require__(57);

// EXTERNAL MODULE: ./src/styles/icons/save.svg
var icons_save = __webpack_require__(58);

// EXTERNAL MODULE: ./src/styles/icons/select-all.svg
var select_all = __webpack_require__(59);

// EXTERNAL MODULE: ./src/styles/icons/shrink.svg
var shrink = __webpack_require__(60);

// EXTERNAL MODULE: ./src/styles/icons/source.svg
var icons_source = __webpack_require__(61);

// EXTERNAL MODULE: ./src/styles/icons/splitg.svg
var splitg = __webpack_require__(62);

// EXTERNAL MODULE: ./src/styles/icons/splitv.svg
var splitv = __webpack_require__(63);

// EXTERNAL MODULE: ./src/styles/icons/strikethrough.svg
var strikethrough = __webpack_require__(64);

// EXTERNAL MODULE: ./src/styles/icons/subscript.svg
var subscript = __webpack_require__(65);

// EXTERNAL MODULE: ./src/styles/icons/superscript.svg
var superscript = __webpack_require__(66);

// EXTERNAL MODULE: ./src/styles/icons/table.svg
var icons_table = __webpack_require__(67);

// EXTERNAL MODULE: ./src/styles/icons/th.svg
var th = __webpack_require__(68);

// EXTERNAL MODULE: ./src/styles/icons/th-list.svg
var th_list = __webpack_require__(69);

// EXTERNAL MODULE: ./src/styles/icons/ul.svg
var icons_ul = __webpack_require__(70);

// EXTERNAL MODULE: ./src/styles/icons/underline.svg
var underline = __webpack_require__(71);

// EXTERNAL MODULE: ./src/styles/icons/undo.svg
var undo = __webpack_require__(72);

// EXTERNAL MODULE: ./src/styles/icons/unlink.svg
var icons_unlink = __webpack_require__(73);

// EXTERNAL MODULE: ./src/styles/icons/unlock.svg
var unlock = __webpack_require__(74);

// EXTERNAL MODULE: ./src/styles/icons/update.svg
var icons_update = __webpack_require__(75);

// EXTERNAL MODULE: ./src/styles/icons/upload.svg
var upload = __webpack_require__(76);

// EXTERNAL MODULE: ./src/styles/icons/valign.svg
var valign = __webpack_require__(77);

// EXTERNAL MODULE: ./src/styles/icons/video.svg
var video = __webpack_require__(78);

// CONCATENATED MODULE: ./src/styles/icons/index.ts
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */
















































































// CONCATENATED MODULE: ./src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Jodit", function() { return src_Jodit; });
/*!
 * Jodit Editor (https://xdsoft.net/jodit/)
 * Licensed under GNU General Public License version 2 or later or a commercial license or MIT;
 * For GPL see LICENSE-GPL.txt in the project root for license information.
 * For MIT see LICENSE-MIT.txt in the project root for license information.
 * For commercial licenses see https://xdsoft.net/jodit/commercial/
 * Copyright (c) 2013-2020 Valeriy Chupurnov. All rights reserved. https://xdsoft.net
 */

if (false) {}








Object.keys(constants_namespaceObject).forEach((key) => {
    Jodit_Jodit[key] = constants_namespaceObject[key];
});
const esFilter = (key) => key !== '__esModule';
Object.keys(icons_namespaceObject)
    .filter(esFilter)
    .forEach((key) => {
    ToolbarIcon.setIcon(key.replace('_', '-'), icons_namespaceObject[key]);
});
Object.keys(modules_namespaceObject)
    .filter(esFilter)
    .forEach((key) => {
    Jodit_Jodit.modules[key] = modules_namespaceObject[key];
});
['Confirm', 'Alert', 'Promt'].forEach((key) => {
    Jodit_Jodit[key] = modules_namespaceObject[key];
});
Object.keys(plugins_namespaceObject)
    .filter(esFilter)
    .forEach((key) => {
    Jodit_Jodit.plugins.add(key, plugins_namespaceObject[key]);
});
Object.keys(langs)
    .filter(esFilter)
    .forEach((key) => {
    Jodit_Jodit.lang[key] = langs[key];
});
Jodit_Jodit.defaultOptions = Config_Config.defaultOptions;
OptionsDefault.prototype = Jodit_Jodit.defaultOptions;
const src_Jodit = Jodit_Jodit;
/* harmony default export */ var src_0 = __webpack_exports__["default"] = (Jodit_Jodit);


/***/ })
/******/ ]);
});
